                        ; --------------------------------------
                        ; zasm: assemble "lcd_test.asm"
                        ; date: 2019-04-30 15:36:21
                        ; --------------------------------------


                        ; Calling convention used in this program
                        ; ---------------------------------------
                        ;
                        ; Unless otherwise noted, the first parameter, and the return value are stored as follows:
                        ; 8 bits: L
                        ; 16 bits: HL
                        ; 32 bits: DEHL
                        ;
                        ; Additional parameters are passed on the stack, left-to-right.
                        ; Parameters and return values larger than 32 bits are passed on the stack (return value
                        ; space set up by caller as a hidden first argument).
                        ; Callee saves/restores any modified registers.
                        ; Caller pops arguments after call returns.
                        ; AF registers are scratch (caller preserves, if needed).
                        
                        ; same as 'rom', except that the default fill byte for 'defs' etc. is 0x00
                        #target bin
                        
                        #include "z80.inc"
                        ; Macros and definitions related to the Z80 and its instruction set
                        
                        M_deref_hl	macro
                            ; hl = (hl)
                            ; destroys A
                            ld	    a, (hl)
                            inc	    hl
                            ld	    h, (hl)
                            ld	    l, a
                            endm
                        
                        M_out		macro port, val
                            ; destroys A
                            ld	    a, &val
                            out	    &port, a
                            endm
                        #include "lcd.inc"
0050:                   PORT_LCDBASE	equ 0x50		; base port address for RA8876 chip
0050:                   PORT_LCDCMD	equ PORT_LCDBASE	; port address for RA8876 command/status register
0051:                   PORT_LCDDAT	equ PORT_LCDBASE + 1	; port address for RA8876 data register
                        
                        ; Register numbers within the RA8876 chip
0000:                   LCDREG_SRR	equ 0x00		; Software Reset Register
0001:                   LCDREG_CCR	equ 0x01		; Chip Configuration Register
0002:                   LCDREG_MACR	equ 0x02		; Memory Access Control Register
0003:                   LCDREG_ICR	equ 0x03		; Input Control Register
0004:                   LCDREG_MRWDP	equ 0x04		; Memory Data Read/Write Port
0005:                   LCDREG_PPLLC1	equ 0x05		; SCLK PLL Control Register 1
0006:                   LCDREG_PPLLC2	equ 0x06		; SCLK PLL Control Register 2
0007:                   LCDREG_MPLLC1	equ 0x07		; MCLK PLL Control Register 1
0008:                   LCDREG_MPLLC2	equ 0x08		; MCLK PLL Control Register 2
0009:                   LCDREG_SPLLC1	equ 0x09		; CCLK PLL Control Register 1
000A:                   LCDREG_SPLLC2	equ 0x0A		; CCLK PLL Control Register 2
000B:                   LCDREG_INTEN	equ 0x0B		; Interrupt Enable Register
000C:                   LCDREG_INTF	equ 0x0C		; Interrupt Event Flag Register
000D:                   LCDREG_MINTFR	equ 0x0D		; Mask Interrupt Flag Register
000E:                   LCDREG_PUENR	equ 0x0E		; Pull-up Enable Register
000F:                   LCDREG_PSFSR	equ 0x0F		; PDAT for PIO/Key Function Select Register
0010:                   LCDREG_MPWCTR	equ 0x10		; Main/PIP Window Control Register
0011:                   LCDREG_PIPCDEP	equ 0x11		; PIP Window Color Depth Setting
0012:                   LCDREG_DPCR	equ 0x12		; Display Configuration Register
0013:                   LCDREG_PCSR	equ 0x13		; Panel scan Clock & Data Setting Register
0014:                   LCDREG_HDWR	equ 0x14		; Horizontal Display Width Register
0015:                   LCDREG_HDWFTR	equ 0x15		; Horizontal Display Width Fine Tune Register
0016:                   LCDREG_HNDR	equ 0x16		; Horizontal Non-Display Period Register
0017:                   LCDREG_HNDFTR	equ 0x17		; Horizontal Non-Display Period Fine Tune Register
0018:                   LCDREG_HSTR	equ 0x18		; HSYNC Start Position Register
0019:                   LCDREG_HPWR	equ 0x19		; HSYNC Pulse Width Register
001A:                   LCDREG_VDHR0	equ 0x1A		; Vertical Display Height Register 0
001B:                   LCDREG_VDHR1	equ 0x1B		; Vertical Display Height Register 1
001C:                   LCDREG_VNDR0	equ 0x1C		; Vertical Non-Display Period Register 0
001D:                   LCDREG_VNDR1	equ 0x1D		; Vertical Non-Display Period Register 1
001E:                   LCDREG_VSTR	equ 0x1E		; VSYNC Start Position Register
001F:                   LCDREG_VPWR	equ 0x1F		; VSYNC Pulse Width Register
0020:                   LCDREG_MISA0	equ 0x20		; Main Image Start Address 0
0021:                   LCDREG_MISA1	equ 0x21		; Main Image Start Address 1
0022:                   LCDREG_MISA2	equ 0x22		; Main Image Start Address 2
0023:                   LCDREG_MISA3	equ 0x23		; Main Image Start Address 3
0024:                   LCDREG_MIW0	equ 0x24		; Main Image Width 0
0025:                   LCDREG_MIW1	equ 0x25		; Main Image Width 1
0026:                   LCDREG_MWULX0	equ 0x26		; Main Window Upper-Left corner X-coordinates 0
0027:                   LCDREG_MWULX1	equ 0x27		; Main Window Upper-Left corner X-coordinates 1
0028:                   LCDREG_MWULY0	equ 0x28		; Main Window Upper-Left corner Y-coordinates 0
0029:                   LCDREG_MWULY1	equ 0x29		; Main Window Upper-Left corner Y-coordinates 1
                        
0050:                   LCDREG_CVSSA0	equ 0x50		; Canvas Start Address 0
0051:                   LCDREG_CVSSA1	equ 0x51		; Canvas Start Address 1
0052:                   LCDREG_CVSSA2	equ 0x52		; Canvas Start Address 2
0053:                   LCDREG_CVSSA3	equ 0x53		; Canvas Start Address 3
0054:                   LCDREG_CVS_IMWTH0 equ 0x54		; Canvas Image Width 0
0055:                   LCDREG_CVS_IMWTH1 equ 0x55		; Canvas Image Width 1
0056:                   LCDREG_AWUL_X0	equ 0x56		; Active Window Upper-Left corner X-coordinates 0
0057:                   LCDREG_AWUL_X1	equ 0x57		; Active Window Upper-Left corner X-coordinates 1
0058:                   LCDREG_AWUL_Y0	equ 0x58		; Active Window Upper-Left corner Y-coordinates 0
0059:                   LCDREG_AWUL_Y1	equ 0x59		; Active Window Upper-Left corner Y-coordinates 1
005A:                   LCDREG_AW_WTH0	equ 0x5A		; Active Window Width 0
005B:                   LCDREG_AW_WTH1	equ 0x5B		; Active Window Width 1
005C:                   LCDREG_AW_HT0	equ 0x5C		; Active Window Height 0
005D:                   LCDREG_AW_HT1	equ 0x5D		; Active Window Height 1
005E:                   LCDREG_AW_COLOR equ 0x5E		; Color Depth of Canvas & Active Window
                        
0067:                   LCDREG_DCR0	equ 0x67		; Draw Line/Triangle Control Register 0
0068:                   LCDREG_DLHSR0	equ 0x68		; Draw Line/Square/Triangle Point 1 X-coordinates 0
0069:                   LCDREG_DLHSR1	equ 0x69		; Draw Line/Square/Triangle Point 1 X-coordinates 1
006A:                   LCDREG_DLVSR0	equ 0x6A		; Draw Line/Square/Triangle Point 1 Y-coordinates 0
006B:                   LCDREG_DLVSR1	equ 0x6B		; Draw Line/Square/Triangle Point 1 Y-coordinates 1
006C:                   LCDREG_DLHER0	equ 0x6C		; Draw Line/Square/Triangle Point 2 X-coordinates 0
006D:                   LCDREG_DLHER1	equ 0x6D		; Draw Line/Square/Triangle Point 2 X-coordinates 1
006E:                   LCDREG_DLVER0	equ 0x6E		; Draw Line/Square/Triangle Point 2 Y-coordinates 0
006F:                   LCDREG_DLVER1	equ 0x6F		; Draw Line/Square/Triangle Point 2 Y-coordinates 1
0070:                   LCDREG_DTPH0	equ 0x70		; Draw Triangle Point 3 X-coordinates 0
0071:                   LCDREG_DTPH1	equ 0x71		; Draw Triangle Point 3 X-coordinates 1
0072:                   LCDREG_DTPV0	equ 0x72		; Draw Triangle Point 3 Y-coordinates 0
0073:                   LCDREG_DTPV1	equ 0x73		; Draw Triangle Point 3 Y-coordinates 1
                        ; Registers 0x74-0x75 reserved
0076:                   LCDREG_DCR1	equ 0x76		; Draw Circle/Ellipse/Ellipse Curve/Circle Square Ctl Reg
0077:                   LCDREG_ELL_A0	equ 0x77		; Draw Circle/Ellipse/Circle Square Major radius Setting Reg
0078:                   LCDREG_ELL_A1	equ 0x78		; Draw Circle/Ellipse/Circle Square Major radius Setting Reg
0079:                   LCDREG_ELL_B0	equ 0x79		; Draw Circle/Ellipse/Circle Square Minor radius Setting Reg
007A:                   LCDREG_ELL_B1	equ 0x7A		; Draw Circle/Ellipse/Circle Square Minor radius Setting Reg
007B:                   LCDREG_DEHR0	equ 0x7B		; Draw Circle/Ellipse/Circle Square Center X-coords 0
007C:                   LCDREG_DEHR1	equ 0x7C		; Draw Circle/Ellipse/Circle Square Center X-coords 1
007D:                   LCDREG_DEVR0	equ 0x7D		; Draw Circle/Ellipse/Circle Square Center Y-coords 0
007E:                   LCDREG_DEVR1	equ 0x7E		; Draw Circle/Ellipse/Circle Square Center Y-coords 1
                        
00D2:                   LCDREG_FGCR	equ 0xD2		; Foreground Color Register - Red
00D3:                   LCDREG_FGCG	equ 0xD3		; Foreground Color Register - Green
00D4:                   LCDREG_FGCB	equ 0xD4		; Foreground Color Register - Blue
                        
00E0:                   LCDREG_SDRAR	equ 0xE0		; SDRAM Attribute Register
00E1:                   LCDREG_SDRMD	equ 0xE1		; SDRAM mode register & extended mode register
00E2:                   LCDREG_SDR_REF_ITVL0 equ 0xE2		; SDRAM auto refresh interval
00E3:                   LCDREG_SDR_REF_ITVL1 equ 0xE3		; SDRAM auto refresh interval
00E4:                   LCDREG_SDRCR	equ 0xE4		; SDRAM Control Register
                        
                        M_lcdwrite	macro regnum, val
                            ; destroys A
                            ld	    a, &regnum
                            out	    (PORT_LCDCMD), a
                            ld	    a, &val
                            out	    (PORT_LCDDAT), a
                            endm
                        #include "7segdisp.inc"
0000:                   PORT_SEG0	equ 0x00	    ; port address for first 7-segment display element
0010:                   PORT_SEG1	equ 0x10	    ; port address for second 7-segment display element
                        
                        ; 7-segment display map
                        ;      A
                        ;  +-------+
                        ;  |       |
                        ; F|       |B
                        ;  |   G   |
                        ;  +-------+
                        ;  |       |
                        ; E|       |C
                        ;  |   D   |
                        ;  +-------+  .DP
                        
                        ; These values are the bit masks.
0001:                   SEG_A		equ 0x01	; segment A
0002:                   SEG_B		equ 0x02	; segment B
0004:                   SEG_C		equ 0x04	; segment C
0008:                   SEG_D		equ 0x08	; segment D
0010:                   SEG_E		equ 0x10	; segment E
0020:                   SEG_F		equ 0x20	; segment F
0040:                   SEG_G		equ 0x40	; segment G
0080:                   SEG_DP		equ 0x80	; decimal point
                        
                        ; These are the bit numbers (useful for bit, set, and res instructions).
0000:                   SEG_IDX_A	equ 0
0001:                   SEG_IDX_B	equ 1
0002:                   SEG_IDX_C	equ 2
0003:                   SEG_IDX_D	equ 3
0004:                   SEG_IDX_E	equ 4
0005:                   SEG_IDX_F	equ 5
0006:                   SEG_IDX_G	equ 6
0007:                   SEG_IDX_DP	equ 7
                        #include "joystick.inc"
0000:                   PORT_JOY0	equ 0x00	    ; port address for first joystick (read-only)
0010:                   PORT_JOY1	equ 0x10	    ; port address for second joystick (read-only)
                        
                        ; Bit masks for the values in the joystick status register.
                        ; These bits are active-low (normally high).
0001:                   JOY_UP		equ 0x01
0002:                   JOY_DOWN	equ 0x02
0004:                   JOY_LEFT	equ 0x04
0008:                   JOY_RIGHT	equ 0x08
0010:                   JOY_FIRE	equ 0x10
0020:                   JOY_SDWP	equ 0x20	    ; only on PORT_JOY1 (second port)
0040:                   JOY_SDCD	equ 0x40	    ; only on PORT_JOY1 (second port)
0080:                   JOY_RESERVED	equ 0x80
                        
                        ; The bit numbers (useful for bit, set, and res instructions).
0000:                   JOY_IDX_UP	equ 0
0001:                   JOY_IDX_DOWN	equ 1
0002:                   JOY_IDX_LEFT	equ 2
0003:                   JOY_IDX_RIGHT	equ 3
0004:                   JOY_IDX_FIRE	equ 4
0005:                   JOY_IDX_SDWP	equ 5
0006:                   JOY_IDX_SDCD	equ 6
                        #include "z84c20.inc"
                        ; The Z84C20 is the Z80's PIO peripheral. See um0081.pdf for documentation.
                        
0030:                   PORT_PIOBASE	equ 0x30		; base port address for PIO chip
0030:                   PORT_PIOADAT	equ PORT_PIOBASE	; port address for PIO port A, data register
0031:                   PORT_PIOBDAT	equ PORT_PIOBASE + 1    ; port address for PIO port B, data register
0032:                   PORT_PIOACTL	equ PORT_PIOBASE + 2    ; port address for PIO port A, control register
0033:                   PORT_PIOBCTL	equ PORT_PIOBASE + 3    ; port address for PIO port B, control register
                        
                        ; PIO Control Register commands
0000:                   PIOC_IVEC	equ 0x00	; OR in the high 7 bits of the interrupt vector
000F:                   PIOC_MODE	equ 0x0F	; OR in the desired PIOMODE_xxx setting
0007:                   PIOC_ICTL	equ 0x07	; OR in the desired PIOICTL_xxx settings
                        
                        ; PIOC_MODE values
0000:                   PIOMODE_OUTPUT	equ 0x00
0040:                   PIOMODE_INPUT	equ 0x40
0080:                   PIOMODE_BIDIREC	equ 0x80
00C0:                   PIOMODE_CONTROL	equ 0xC0	; next control byte written must be the IO direction byte
                        				; 1 = input, 0 = output
                        
                        ; PIOC_ICTL values
0080:                   PIOICTL_INTENA	equ 0x80	; enable interrupts
0000:                   PIOICTL_INTDIS	equ 0x00	; disable interrupts
0040:                   PIOICTL_AND	equ 0x40	; AND inputs together for port monitoring interrupt
0000:                   PIOICTL_OR	equ 0x00	; OR inputs together for port monitoring interrupt
0020:                   PIOICTL_HIGH	equ 0x20	; interrupt on high (1) inputs
0000:                   PIOICTL_LOW	equ 0x00	; interrupt on low (0) inputs
0010:                   PIOICTL_MASKNXT equ 0x10	; next control byte written must be the input interrupt mask
                        				; 1 = input masked, 0 = input enabled
                        
                        M_pio_reset	macro
                            ld	    a, PIOC_MODE | PIOMODE_INPUT
                            out	    (PORT_PIOACTL), a
                            out	    (PORT_PIOBCTL), a
                            ld	    a, PIOC_ICTL | PIOICTL_INTDIS
                            out	    (PORT_PIOACTL), a
                            out	    (PORT_PIOBCTL), a
                            endm
                        #include "z84c30.inc"
                        ; The Z84C30 is the Z80's CTC peripheral. See um0081.pdf for documentation.
                        
0040:                   PORT_CTCBASE	equ 0x40		; base port address for CTC chip
0040:                   PORT_CTCIVEC	equ PORT_CTCBASE	; port address for Interrupt Vector Register
0040:                   PORT_CTC0	equ PORT_CTCBASE	; port address for CTC channel 0
0041:                   PORT_CTC1	equ PORT_CTCBASE + 1	; port address for CTC channel 1
0042:                   PORT_CTC2	equ PORT_CTCBASE + 2	; port address for CTC channel 2
0043:                   PORT_CTC3	equ PORT_CTCBASE + 3	; port address for CTC channel 3
                        
                        ; CTC Channel Control Word bits
0080:                   CTC_INTENA	equ 0x80		; enable interrupts
0000:                   CTC_INTDIS	equ 0x00		; disable interrupts
0040:                   CTC_MODECTR	equ 0x40		; COUNTER mode
0000:                   CTC_MODETMR	equ 0x00		; TIMER mode
0020:                   CTC_SCALE256	equ 0x20		; prescale by 256
0000:                   CTC_SCALE16	equ 0x00		; prescale by 16
0010:                   CTC_RISING	equ 0x10		; CLK/TRG on rising edges
0000:                   CTC_FALLING	equ 0x00		; CLK/TRG on falling edges
0008:                   CTC_CLKTRG	equ 0x08		; CLK/TRG pulse starts timer
0000:                   CTC_AUTO	equ 0x00		; automatic timer start after loading time constant
0004:                   CTC_TIMENXT	equ 0x04		; next control byte written is the time constant
0002:                   CTC_RESET	equ 0x02		; software reset
0001:                   CTC_CONTROL	equ 0x01		; always set to indicate this is a control word, not IVEC 
                        
                        M_ctc_reset	macro
                            ld	    a, CTC_CONTROL | CTC_RESET | CTC_INTDIS
                            out	    (PORT_CTC0), a
                            out	    (PORT_CTC1), a
                            out	    (PORT_CTC2), a
                            out	    (PORT_CTC3), a
                            endm
                        #include "z84c40.inc"
                        ; The Z84C40 is the Z80's SIO peripheral. See um0081.pdf for documentation.
                        
0020:                   PORT_SIOBASE	    equ 0x20		    ; base port address for SIO chip
0020:                   PORT_SIOADAT	    equ PORT_SIOBASE	    ; port address for SIO port A, data register
0021:                   PORT_SIOBDAT	    equ PORT_SIOBASE + 1    ; port address for SIO port B, data register
0022:                   PORT_SIOACTL	    equ PORT_SIOBASE + 2    ; port address for SIO port A, control register
0023:                   PORT_SIOBCTL	    equ PORT_SIOBASE + 3    ; port address for SIO port B, control register
                        
                        ; WR0 "CRC Reset Code" values (bits 7-6)
0000:                   SIOWR0_CRC_NOP		equ 0x00	    ; no CRC reset code
0040:                   SIOWR0_CRC_RST_RX_CHK	equ 1 << 6	    ; reset RX CRC checker
0080:                   SIOWR0_CRC_RST_TX_GEN	equ 2 << 6	    ; reset TX CRC generator
00C0:                   SIOWR0_CRC_RST_TX_UNDR  equ 3 << 6	    ; reset TX underrun/EOM latch
                        
                        ; WR0 "Command" values (bits 5-3)
0000:                   SIOWR0_CMD_NOP		equ 0x00	    ; no command
0008:                   SIOWR0_CMD_SND_ABRT	equ 1 << 3	    ; send abort (SDLC only)
0010:                   SIOWR0_CMD_RST_EXTINT	equ 2 << 3	    ; reset external/status interrupts
0018:                   SIOWR0_CMD_RST_CHAN	equ 3 << 3	    ; reset channel
0020:                   SIOWR0_CMD_INTENA_NXTRX	equ 4 << 3	    ; enable interrupt on next receive character
0028:                   SIOWR0_CMD_RST_TXINTPND equ 5 << 3	    ; reset TX interrupt pending
0030:                   SIOWR0_CMD_RST_ERR	equ 6 << 3	    ; reset error latches
0038:                   SIOWR0_CMD_INTRETN	equ 7 << 3	    ; return from interrupt (not needed with Z80)
                        
                        ; WR0 "Pointer" values (bits 2-0)
0000:                   SIOWR0_PTR_R0		equ 0x00	    ; set pointer to register 0
0001:                   SIOWR0_PTR_R1		equ 0x01	    ; set pointer to register 1
0002:                   SIOWR0_PTR_R2		equ 0x02	    ; set pointer to register 2
0003:                   SIOWR0_PTR_R3		equ 0x03	    ; set pointer to register 3
0004:                   SIOWR0_PTR_R4		equ 0x04	    ; set pointer to register 4
0005:                   SIOWR0_PTR_R5		equ 0x05	    ; set pointer to register 5
0006:                   SIOWR0_PTR_R6		equ 0x06	    ; set pointer to register 6
0007:                   SIOWR0_PTR_R7		equ 0x07	    ; set pointer to register 7
                        
                        ; WR1 interrupt & wait/ready control bits
0001:                   SIOWR1_EXTINTENA	equ 0x01	    ; external/status interrupt enable
0002:                   SIOWR1_TXINTENA		equ 0x02	    ; TX interrupt enable
0004:                   SIOWR1_STATIVEC		equ 0x04	    ; status affects interrupt vector (set in ch. B only)
0000:                   SIOWR1_RXINT_DISABLE	equ 0 << 3	    ; RX interrupts disabled
0008:                   SIOWR1_RXINT_FIRST	equ 1 << 3	    ; RX interrupt on first character
0010:                   SIOWR1_RXINT_ALLPRTY	equ 2 << 3	    ; RX interrupt on all characters, parity err is SR cond
0018:                   SIOWR1_RXINT_ALLNPRTY	equ 3 << 3	    ; RX interrupt on all characters, parity err no intr
                        ; bits 7-5 are for WAIT/READY functions, which we don't use (always write as 0)
                        
                        ; WR2 is the interrupt vector register (set in channel B only)
                        
                        ; WR3 receiver logic control bits
0001:                   SIOWR3_RXENA		equ 0x01	    ; receiver enable
0002:                   SIOWR3_SYNC_INHIBIT	equ 0x02	    ; sync character load inhibit
0004:                   SIOWR3_ADDR_SRCHMODE	equ 0x04	    ; address search mode
0008:                   SIOWR3_RXCRCENA		equ 0x08	    ; receiver CRC enable
0010:                   SIOWR3_ENTER_HUNT	equ 0x10	    ; enter hunt phase
0020:                   SIOWR3_AUTO_ENABLES	equ 0x20	    ; auto enables (DCD/CTS are RX/TX enables)
0000:                   SIOWR3_RX_5_BITS	equ 0 << 6	    ; receive 5 bits/character
0040:                   SIOWR3_RX_7_BITS	equ 1 << 6	    ; receive 7 bits/character
0080:                   SIOWR3_RX_6_BITS	equ 2 << 6	    ; receive 6 bits/character
00C0:                   SIOWR3_RX_8_BITS	equ 3 << 6	    ; receive 8 bits/character
                        
                        ; WR4 RX/TX configuration (set first before WR1, WR3, WR5, WR6, and WR7)
0001:                   SIOWR4_PARITY		equ 0x01	    ; parity on/off
0002:                   SIOWR4_PRTY_EVEN	equ 0x02	    ; even parity
0000:                   SIOWR4_PRTY_ODD		equ 0x00	    ; odd parity
0000:                   SIOWR4_TXSTOP_SYNC	equ 0 << 2	    ; synchronous mode (no TX stop bits)
0004:                   SIOWR4_TXSTOP_1		equ 1 << 2	    ; 1 TX stop bit
0008:                   SIOWR4_TXSTOP_1_5	equ 2 << 2	    ; 1.5 TX stop bits
000C:                   SIOWR4_TXSTOP_2		equ 3 << 2	    ; 2 TX stop bits
                        ; bits 5-4 set the sync modes, which we don't use (always write as 0)
0000:                   SIOWR4_CLK_x1		equ 0 << 6	    ; data rate x1 = clock rate
0040:                   SIOWR4_CLK_x16		equ 1 << 6	    ; data rate x16 = clock rate
0080:                   SIOWR4_CLK_x32		equ 2 << 6	    ; data rate x32 = clock rate
00C0:                   SIOWR4_CLK_x64		equ 3 << 6	    ; data rate x64 = clock rate
                        
                        ; WR5 transmitter logic control bits
0001:                   SIOWR5_TXCRCENA		equ 0x01	    ; transmitter CRC enable
0002:                   SIOWR5_RTS		equ 0x02	    ; request to send
0004:                   SIOWR5_CRC16_SDLC	equ 0x04	    ; CRC-16 vs. SDLC polynomial
0008:                   SIOWR5_TXENA		equ 0x08	    ; transmitter enable
0010:                   SIOWR5_SND_BRK		equ 0x10	    ; send break
0000:                   SIOWR5_TX_5_BITS	equ 0 << 5	    ; transmit 5 bits/character
0020:                   SIOWR5_TX_7_BITS	equ 1 << 5	    ; transmit 7 bits/character
0040:                   SIOWR5_TX_6_BITS	equ 2 << 5	    ; transmit 6 bits/character
0060:                   SIOWR5_TX_8_BITS	equ 3 << 5	    ; transmit 8 bits/character
0080:                   SIOWR5_DTR		equ 0x80	    ; data terminal ready
                        
                        ; WR6 transmitter sync register for use in synchronous modes, which we don't use
                        ; WR7 receiver sync register for use in synchronous modes, which we don't use
                        
                        ; RR0 status bits (mostly normal operation)
0001:                   SIORR0_RCA		equ 0x01	    ; RX character available
0002:                   SIORR0_INTPND		equ 0x02	    ; interrupt pending (channel A only)
0004:                   SIORR0_TBE		equ 0x04	    ; TX buffer empty
0008:                   SIORR0_DCD		equ 0x08	    ; latched DCD input bit
0010:                   SIORR0_SYNC		equ 0x10	    ; latched SYNC input bit (hunt in SDLC)
0020:                   SIORR0_CTS		equ 0x20	    ; latched CTS input bit
0040:                   SIORR0_TX_UNDR		equ 0x40	    ; TX underrun / end of message
0080:                   SIORR0_BRK_ABRT		equ 0x80	    ; break/abort detected
                        ; As bit numbers, useful for the "bit" instruction, to test individual bit flags
0000:                   SIORR0_IDX_RCA		equ 0
0001:                   SIORR0_IDX_INTPND	equ 1
0002:                   SIORR0_IDX_TBE		equ 2
0003:                   SIORR0_IDX_DCD		equ 3
0004:                   SIORR0_IDX_SYNC		equ 4
0005:                   SIORR0_IDX_CTS		equ 5
0006:                   SIORR0_IDX_TX_UNDR	equ 6
0007:                   SIORR0_IDX_BRK_ABRT	equ 7
                        
                        ; RR1 status bits (mostly errors)
0001:                   SIORR1_ALLSENT		equ 0x01	    ; all characters fully sent
                        ; bits 3-1 are SDLC-only
0010:                   SIORR1_PRTYERR		equ 0x10	    ; parity error
0020:                   SIORR1_ROE		equ 0x20	    ; RX overrun error
0040:                   SIORR1_CRCFRMERR	equ 0x40	    ; CRC/framing error
                        ; bit 7 is SDLC-only
                        
                        ; RR2 is the interrupt vector register (read from channel B only)
                        ; - if "Status Affects Vector" bit is set, this will be the current vector value,
                        ;   modified by whatever interrupt conditions are pending
                        
                        M_sio_reset	macro
                            ld	    a, SIOWR0_CMD_RST_CHAN
                            out	    (PORT_SIOACTL), a
                            out	    (PORT_SIOBCTL), a
                            endm
                        #include "ascii.inc"
0000:                   NUL	equ 0x00
0001:                   SOH	equ 0x01
0004:                   EOT	equ 0x04
0006:                   ACK	equ 0x06
0007:                   BEL	equ 0x07
0008:                   BS	equ 0x08
0009:                   HT	equ 0x09
000A:                   LF	equ 0x0A
000D:                   CR	equ 0x0D
0015:                   NAK	equ 0x15
001B:                   ESC	equ 0x1B
                        
                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                        ; our code will load immediately above the ROM
                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
4000:                   #code TEXT,0x4000
                        
4000:                   init::
                            ; zero the DATA segment
4000: 21DD42   [10]         ld	    hl, DATA
4003: 010200   [20]         ld	    bc, DATA_size
4006: CD4D42   [37]         call    bzero
4009: CD6042   [54]         call    seg_init
                            ; run the test program
400C: CD1040   [71]         call    lcd_test
400F: C9       [81]         ret
                        
                        ; void lcd_test()
                        ; - exercise the LCD panel
                        #local
4010:                   lcd_test::
4010: E5       [11]         push    hl
4011: CD3840   [28]         call    lcd_init
4014: 2EFA     [35]         ld	    l, 250
4016:                   loop:
4016: CD3B42   [17]         call    lcd_bl_on
4019: CDC342   [34]         call    delay_ms
401C: CDC342   [51]         call    delay_ms
401F: CDC342   [68]         call    delay_ms
4022: CDC342   [85]         call    delay_ms
4025: CD4442   [102]        call    lcd_bl_off
4028: CDC342   [119]        call    delay_ms
402B: CDC342   [136]        call    delay_ms
402E: CDC342   [153]        call    delay_ms
4031: CDC342   [170]        call    delay_ms
4034: 18E0     [182]        jr	    loop
4036: E1       [192]        pop	    hl
4037: C9       [202]        ret
                        #endlocal
                        
                        ; void lcd_init()
                        ; - set up the LCD panel by programming the RA8876 registers
                        #local
4038:                   lcd_init::
4038: E5       [11]         push    hl
4039: DB50     [22]         in	    a, (PORT_LCDCMD)	    ; read status byte
403B: 6F       [26]         ld	    l, a
403C: CD6842   [43]         call    seg_writehex
                            ; RA8876_initial()
                            ;	RA8876_SW_Reset();
                            M_out   (PORT_LCDCMD), LCDREG_SRR
                            ; destroys A
403F: 3E00     [50]         ld	    a, LCDREG_SRR
4041: D350     [61]         out	    (PORT_LCDCMD), a
4043: DB51     [72]         in	    a, (PORT_LCDDAT)
4045: F601     [79]         or	    0x01
4047: D351     [90]         out	    (PORT_LCDDAT), a
4049:                   wait_reset:
4049: DB51     [11]         in	    a, (PORT_LCDDAT)
404B: E601     [18]         and	    0x01
404D: 20FA     [25|30]      jr	    nz, wait_reset
                            ;	RA8876_PLL_Initial(); 
                            M_lcdwrite LCDREG_PPLLC1, 2
                            ; destroys A
404F: 3E05     [32]         ld	    a, LCDREG_PPLLC1
4051: D350     [43]         out	    (PORT_LCDCMD), a
4053: 3E02     [50]         ld	    a, 2
4055: D351     [61]         out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MPLLC1, 2
                            ; destroys A
4057: 3E07     [68]         ld	    a, LCDREG_MPLLC1
4059: D350     [79]         out	    (PORT_LCDCMD), a
405B: 3E02     [86]         ld	    a, 2
405D: D351     [97]         out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_SPLLC1, 2
                            ; destroys A
405F: 3E09     [104]        ld	    a, LCDREG_SPLLC1
4061: D350     [115]        out	    (PORT_LCDCMD), a
4063: 3E02     [122]        ld	    a, 2
4065: D351     [133]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_PPLLC2, 7
                            ; destroys A
4067: 3E06     [140]        ld	    a, LCDREG_PPLLC2
4069: D350     [151]        out	    (PORT_LCDCMD), a
406B: 3E07     [158]        ld	    a, 7
406D: D351     [169]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MPLLC2, 19
                            ; destroys A
406F: 3E08     [176]        ld	    a, LCDREG_MPLLC2
4071: D350     [187]        out	    (PORT_LCDCMD), a
4073: 3E13     [194]        ld	    a, 19
4075: D351     [205]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_SPLLC2, 19
                            ; destroys A
4077: 3E0A     [212]        ld	    a, LCDREG_SPLLC2
4079: D350     [223]        out	    (PORT_LCDCMD), a
407B: 3E13     [230]        ld	    a, 19
407D: D351     [241]        out	    (PORT_LCDDAT), a
                            M_out   (PORT_LCDCMD), LCDREG_CCR
                            ; destroys A
407F: 3E01     [248]        ld	    a, LCDREG_CCR
4081: D350     [259]        out	    (PORT_LCDCMD), a
                            M_out   (PORT_LCDDAT), 0x00
                            ; destroys A
4083: 3E00     [266]        ld	    a, 0x00
4085: D351     [277]        out	    (PORT_LCDDAT), a
4087: CDCF42   [294]        call    delay_1ms
                            M_out   (PORT_LCDDAT), 0x80
                            ; destroys A
408A: 3E80     [301]        ld	    a, 0x80
408C: D351     [312]        out	    (PORT_LCDDAT), a
408E: CDCF42   [329]        call    delay_1ms
                            ;	RA8876_SDRAM_initail();
                            M_lcdwrite LCDREG_SDRAR, 0x29
                            ; destroys A
4091: 3EE0     [336]        ld	    a, LCDREG_SDRAR
4093: D350     [347]        out	    (PORT_LCDCMD), a
4095: 3E29     [354]        ld	    a, 0x29
4097: D351     [365]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_SDRMD, 0x03
                            ; destroys A
4099: 3EE1     [372]        ld	    a, LCDREG_SDRMD
409B: D350     [383]        out	    (PORT_LCDCMD), a
409D: 3E03     [390]        ld	    a, 0x03
409F: D351     [401]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_SDR_REF_ITVL0, 0x0B
                            ; destroys A
40A1: 3EE2     [408]        ld	    a, LCDREG_SDR_REF_ITVL0
40A3: D350     [419]        out	    (PORT_LCDCMD), a
40A5: 3E0B     [426]        ld	    a, 0x0B
40A7: D351     [437]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_SDR_REF_ITVL1, 0x03
                            ; destroys A
40A9: 3EE3     [444]        ld	    a, LCDREG_SDR_REF_ITVL1
40AB: D350     [455]        out	    (PORT_LCDCMD), a
40AD: 3E03     [462]        ld	    a, 0x03
40AF: D351     [473]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_SDRCR, 0x01
                            ; destroys A
40B1: 3EE4     [480]        ld	    a, LCDREG_SDRCR
40B3: D350     [491]        out	    (PORT_LCDCMD), a
40B5: 3E01     [498]        ld	    a, 0x01
40B7: D351     [509]        out	    (PORT_LCDDAT), a
40B9:                   wait_sdram:
40B9: DB50     [11]         in	    a, (PORT_LCDCMD)
40BB: E604     [18]         and	    0x04
40BD: 28FA     [25|30]      jr	    z, wait_sdram
40BF: CDCF42   [42]         call delay_1ms
                            ;	TFT_24bit();
                            ;	Host_Bus_8bit();
                            M_out   (PORT_LCDCMD), LCDREG_CCR
                            ; destroys A
40C2: 3E01     [49]         ld	    a, LCDREG_CCR
40C4: D350     [60]         out	    (PORT_LCDCMD), a
40C6: DB51     [71]         in	    a, (PORT_LCDDAT)
40C8: E6E6     [78]         and	    ~0x19
40CA: D351     [89]         out	    (PORT_LCDDAT), a
                            ;	RGB_8b_16bpp();
                            ;	MemWrite_Left_Right_Top_Down();
                            M_lcdwrite LCDREG_MACR, 0x00
                            ; destroys A
40CC: 3E02     [96]         ld	    a, LCDREG_MACR
40CE: D350     [107]        out	    (PORT_LCDCMD), a
40D0: 3E00     [114]        ld	    a, 0x00
40D2: D351     [125]        out	    (PORT_LCDDAT), a
                            ;	Graphic_Mode();
                            ;	Memory_Select_SDRAM();   
                            M_out   (PORT_LCDCMD), LCDREG_ICR
                            ; destroys A
40D4: 3E03     [132]        ld	    a, LCDREG_ICR
40D6: D350     [143]        out	    (PORT_LCDCMD), a
40D8: DB51     [154]        in	    a, (PORT_LCDDAT)
40DA: E6F8     [161]        and	    ~0x07
40DC: D351     [172]        out	    (PORT_LCDDAT), a
                            ;	HSCAN_L_to_R();
                            ;	VSCAN_T_to_B();
                            ;	PDATA_Set_RGB();
                            ;	PCLK_Falling();
                            M_out   (PORT_LCDCMD), LCDREG_DPCR
                            ; destroys A
40DE: 3E12     [179]        ld	    a, LCDREG_DPCR
40E0: D350     [190]        out	    (PORT_LCDCMD), a
40E2: DB51     [201]        in	    a, (PORT_LCDDAT)
40E4: E6E0     [208]        and	    ~0x1F
40E6: F680     [215]        or	    0x80
40E8: D351     [226]        out	    (PORT_LCDDAT), a
                            ;	DE_High_Active();
                            ;	HSYNC_High_Active();
                            ;	VSYNC_High_Active(); 
                            M_out   (PORT_LCDCMD), LCDREG_PCSR
                            ; destroys A
40EA: 3E13     [233]        ld	    a, LCDREG_PCSR
40EC: D350     [244]        out	    (PORT_LCDCMD), a
40EE: DB51     [255]        in	    a, (PORT_LCDDAT)
40F0: E6DF     [262]        and	    ~0x20
40F2: F6C0     [269]        or	    0xC0
40F4: D351     [280]        out	    (PORT_LCDDAT), a
                            ;	LCD_HorizontalWidth_VerticalHeight(1024,600);
                            M_lcdwrite LCDREG_HDWR, 127
                            ; destroys A
40F6: 3E14     [287]        ld	    a, LCDREG_HDWR
40F8: D350     [298]        out	    (PORT_LCDCMD), a
40FA: 3E7F     [305]        ld	    a, 127
40FC: D351     [316]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_HDWFTR, 0
                            ; destroys A
40FE: 3E15     [323]        ld	    a, LCDREG_HDWFTR
4100: D350     [334]        out	    (PORT_LCDCMD), a
4102: 3E00     [341]        ld	    a, 0
4104: D351     [352]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_VDHR0, 0x57
                            ; destroys A
4106: 3E1A     [359]        ld	    a, LCDREG_VDHR0
4108: D350     [370]        out	    (PORT_LCDCMD), a
410A: 3E57     [377]        ld	    a, 0x57
410C: D351     [388]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_VDHR1, 0x02
                            ; destroys A
410E: 3E1B     [395]        ld	    a, LCDREG_VDHR1
4110: D350     [406]        out	    (PORT_LCDCMD), a
4112: 3E02     [413]        ld	    a, 0x02
4114: D351     [424]        out	    (PORT_LCDDAT), a
                            ;	LCD_Horizontal_Non_Display(160);		   //30
                            M_lcdwrite LCDREG_HNDR, 19
                            ; destroys A
4116: 3E16     [431]        ld	    a, LCDREG_HNDR
4118: D350     [442]        out	    (PORT_LCDCMD), a
411A: 3E13     [449]        ld	    a, 19
411C: D351     [460]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_HNDFTR, 0
                            ; destroys A
411E: 3E17     [467]        ld	    a, LCDREG_HNDFTR
4120: D350     [478]        out	    (PORT_LCDCMD), a
4122: 3E00     [485]        ld	    a, 0
4124: D351     [496]        out	    (PORT_LCDDAT), a
                            ;	LCD_HSYNC_Start_Position(160);
                            M_lcdwrite LCDREG_HSTR, 19
                            ; destroys A
4126: 3E18     [503]        ld	    a, LCDREG_HSTR
4128: D350     [514]        out	    (PORT_LCDCMD), a
412A: 3E13     [521]        ld	    a, 19
412C: D351     [532]        out	    (PORT_LCDDAT), a
                            ;	LCD_HSYNC_Pulse_Width(70);
                            M_lcdwrite LCDREG_HPWR, 7
                            ; destroys A
412E: 3E19     [539]        ld	    a, LCDREG_HPWR
4130: D350     [550]        out	    (PORT_LCDCMD), a
4132: 3E07     [557]        ld	    a, 7
4134: D351     [568]        out	    (PORT_LCDDAT), a
                            ;	LCD_Vertical_Non_Display(23);		   //16
                            M_lcdwrite LCDREG_VNDR0, 22
                            ; destroys A
4136: 3E1C     [575]        ld	    a, LCDREG_VNDR0
4138: D350     [586]        out	    (PORT_LCDCMD), a
413A: 3E16     [593]        ld	    a, 22
413C: D351     [604]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_VNDR1, 0
                            ; destroys A
413E: 3E1D     [611]        ld	    a, LCDREG_VNDR1
4140: D350     [622]        out	    (PORT_LCDCMD), a
4142: 3E00     [629]        ld	    a, 0
4144: D351     [640]        out	    (PORT_LCDDAT), a
                            ;	LCD_VSYNC_Start_Position(12);
                            M_lcdwrite LCDREG_VSTR, 11
                            ; destroys A
4146: 3E1E     [647]        ld	    a, LCDREG_VSTR
4148: D350     [658]        out	    (PORT_LCDCMD), a
414A: 3E0B     [665]        ld	    a, 11
414C: D351     [676]        out	    (PORT_LCDDAT), a
                            ;	LCD_VSYNC_Pulse_Width(10);
                            M_lcdwrite LCDREG_VPWR, 9
                            ; destroys A
414E: 3E1F     [683]        ld	    a, LCDREG_VPWR
4150: D350     [694]        out	    (PORT_LCDCMD), a
4152: 3E09     [701]        ld	    a, 9
4154: D351     [712]        out	    (PORT_LCDDAT), a
                            ;	Select_Main_Window_16bpp();
                            ; This is the default, so we don't really need to do this.
                            M_out   (PORT_LCDCMD), LCDREG_MPWCTR
                            ; destroys A
4156: 3E10     [719]        ld	    a, LCDREG_MPWCTR
4158: D350     [730]        out	    (PORT_LCDCMD), a
415A: DB51     [741]        in	    a, (PORT_LCDDAT)
415C: E6F7     [748]        and	    ~0x08
415E: F604     [755]        or	    0x04
4160: D351     [766]        out	    (PORT_LCDDAT), a
                            ;	Main_Image_Start_Address(0);				
                            ; The default is start address 0, so we don't really need to do this.
                            M_lcdwrite LCDREG_MISA0, 0
                            ; destroys A
4162: 3E20     [773]        ld	    a, LCDREG_MISA0
4164: D350     [784]        out	    (PORT_LCDCMD), a
4166: 3E00     [791]        ld	    a, 0
4168: D351     [802]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MISA1, 0
                            ; destroys A
416A: 3E21     [809]        ld	    a, LCDREG_MISA1
416C: D350     [820]        out	    (PORT_LCDCMD), a
416E: 3E00     [827]        ld	    a, 0
4170: D351     [838]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MISA2, 0
                            ; destroys A
4172: 3E22     [845]        ld	    a, LCDREG_MISA2
4174: D350     [856]        out	    (PORT_LCDCMD), a
4176: 3E00     [863]        ld	    a, 0
4178: D351     [874]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MISA3, 0
                            ; destroys A
417A: 3E23     [881]        ld	    a, LCDREG_MISA3
417C: D350     [892]        out	    (PORT_LCDCMD), a
417E: 3E00     [899]        ld	    a, 0
4180: D351     [910]        out	    (PORT_LCDDAT), a
                            ;	Main_Image_Width(1024);							
                            M_lcdwrite LCDREG_MIW0, 0
                            ; destroys A
4182: 3E24     [917]        ld	    a, LCDREG_MIW0
4184: D350     [928]        out	    (PORT_LCDCMD), a
4186: 3E00     [935]        ld	    a, 0
4188: D351     [946]        out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MIW1, 4
                            ; destroys A
418A: 3E25     [953]        ld	    a, LCDREG_MIW1
418C: D350     [964]        out	    (PORT_LCDCMD), a
418E: 3E04     [971]        ld	    a, 4
4190: D351     [982]        out	    (PORT_LCDDAT), a
                            ;	Main_Window_Start_XY(0,0);	
                            ; The default is (0,0), so we don't really need to do this.
                            M_lcdwrite LCDREG_MWULX0, 0
                            ; destroys A
4192: 3E26     [989]        ld	    a, LCDREG_MWULX0
4194: D350     [1000]       out	    (PORT_LCDCMD), a
4196: 3E00     [1007]       ld	    a, 0
4198: D351     [1018]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MWULX1, 0
                            ; destroys A
419A: 3E27     [1025]       ld	    a, LCDREG_MWULX1
419C: D350     [1036]       out	    (PORT_LCDCMD), a
419E: 3E00     [1043]       ld	    a, 0
41A0: D351     [1054]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MWULY0, 0
                            ; destroys A
41A2: 3E28     [1061]       ld	    a, LCDREG_MWULY0
41A4: D350     [1072]       out	    (PORT_LCDCMD), a
41A6: 3E00     [1079]       ld	    a, 0
41A8: D351     [1090]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_MWULY1, 0
                            ; destroys A
41AA: 3E29     [1097]       ld	    a, LCDREG_MWULY1
41AC: D350     [1108]       out	    (PORT_LCDCMD), a
41AE: 3E00     [1115]       ld	    a, 0
41B0: D351     [1126]       out	    (PORT_LCDDAT), a
                            ;	Canvas_Image_Start_address(0);
                            ; The default is start address 0, so we don't really need to do this.
                            M_lcdwrite LCDREG_CVSSA0, 0
                            ; destroys A
41B2: 3E50     [1133]       ld	    a, LCDREG_CVSSA0
41B4: D350     [1144]       out	    (PORT_LCDCMD), a
41B6: 3E00     [1151]       ld	    a, 0
41B8: D351     [1162]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_CVSSA1, 0
                            ; destroys A
41BA: 3E51     [1169]       ld	    a, LCDREG_CVSSA1
41BC: D350     [1180]       out	    (PORT_LCDCMD), a
41BE: 3E00     [1187]       ld	    a, 0
41C0: D351     [1198]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_CVSSA2, 0
                            ; destroys A
41C2: 3E52     [1205]       ld	    a, LCDREG_CVSSA2
41C4: D350     [1216]       out	    (PORT_LCDCMD), a
41C6: 3E00     [1223]       ld	    a, 0
41C8: D351     [1234]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_CVSSA3, 0
                            ; destroys A
41CA: 3E53     [1241]       ld	    a, LCDREG_CVSSA3
41CC: D350     [1252]       out	    (PORT_LCDCMD), a
41CE: 3E00     [1259]       ld	    a, 0
41D0: D351     [1270]       out	    (PORT_LCDDAT), a
                            ;	Canvas_image_width(1024);
                            M_lcdwrite LCDREG_CVS_IMWTH0, 0
                            ; destroys A
41D2: 3E54     [1277]       ld	    a, LCDREG_CVS_IMWTH0
41D4: D350     [1288]       out	    (PORT_LCDCMD), a
41D6: 3E00     [1295]       ld	    a, 0
41D8: D351     [1306]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_CVS_IMWTH1, 4
                            ; destroys A
41DA: 3E55     [1313]       ld	    a, LCDREG_CVS_IMWTH1
41DC: D350     [1324]       out	    (PORT_LCDCMD), a
41DE: 3E04     [1331]       ld	    a, 4
41E0: D351     [1342]       out	    (PORT_LCDDAT), a
                            ;	Active_Window_XY(0,0);
                            ; The default is (0,0), so we don't really need to do this.
                            M_lcdwrite LCDREG_AWUL_X0, 0
                            ; destroys A
41E2: 3E56     [1349]       ld	    a, LCDREG_AWUL_X0
41E4: D350     [1360]       out	    (PORT_LCDCMD), a
41E6: 3E00     [1367]       ld	    a, 0
41E8: D351     [1378]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_AWUL_X1, 0
                            ; destroys A
41EA: 3E57     [1385]       ld	    a, LCDREG_AWUL_X1
41EC: D350     [1396]       out	    (PORT_LCDCMD), a
41EE: 3E00     [1403]       ld	    a, 0
41F0: D351     [1414]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_AWUL_Y0, 0
                            ; destroys A
41F2: 3E58     [1421]       ld	    a, LCDREG_AWUL_Y0
41F4: D350     [1432]       out	    (PORT_LCDCMD), a
41F6: 3E00     [1439]       ld	    a, 0
41F8: D351     [1450]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_AWUL_Y1, 0
                            ; destroys A
41FA: 3E59     [1457]       ld	    a, LCDREG_AWUL_Y1
41FC: D350     [1468]       out	    (PORT_LCDCMD), a
41FE: 3E00     [1475]       ld	    a, 0
4200: D351     [1486]       out	    (PORT_LCDDAT), a
                            ;	Active_Window_WH(1024,600);
                            M_lcdwrite LCDREG_AW_WTH0, 0
                            ; destroys A
4202: 3E5A     [1493]       ld	    a, LCDREG_AW_WTH0
4204: D350     [1504]       out	    (PORT_LCDCMD), a
4206: 3E00     [1511]       ld	    a, 0
4208: D351     [1522]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_AW_WTH1, 4
                            ; destroys A
420A: 3E5B     [1529]       ld	    a, LCDREG_AW_WTH1
420C: D350     [1540]       out	    (PORT_LCDCMD), a
420E: 3E04     [1547]       ld	    a, 4
4210: D351     [1558]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_AW_HT0, 88
                            ; destroys A
4212: 3E5C     [1565]       ld	    a, LCDREG_AW_HT0
4214: D350     [1576]       out	    (PORT_LCDCMD), a
4216: 3E58     [1583]       ld	    a, 88
4218: D351     [1594]       out	    (PORT_LCDDAT), a
                            M_lcdwrite LCDREG_AW_HT1, 2
                            ; destroys A
421A: 3E5D     [1601]       ld	    a, LCDREG_AW_HT1
421C: D350     [1612]       out	    (PORT_LCDCMD), a
421E: 3E02     [1619]       ld	    a, 2
4220: D351     [1630]       out	    (PORT_LCDDAT), a
                            ;	Memory_XY_Mode();
                            ;	Memory_16bpp_Mode();
                            M_lcdwrite LCDREG_AW_COLOR, 0x01
                            ; destroys A
4222: 3E5E     [1637]       ld	    a, LCDREG_AW_COLOR
4224: D350     [1648]       out	    (PORT_LCDCMD), a
4226: 3E01     [1655]       ld	    a, 0x01
4228: D351     [1666]       out	    (PORT_LCDDAT), a
                            ;	Select_Main_Window_16bpp();
                            ; Unaccountably, the sample code calls this again, even though it was done earlier, and is
                            ; the default, so we skip it.
                            ; Display_ON();
                            M_out   (PORT_LCDCMD), LCDREG_DPCR
                            ; destroys A
422A: 3E12     [1673]       ld	    a, LCDREG_DPCR
422C: D350     [1684]       out	    (PORT_LCDCMD), a
422E: DB51     [1695]       in	    a, (PORT_LCDDAT)
4230: F640     [1702]       or	    0x40
4232: D351     [1713]       out	    (PORT_LCDDAT), a
                            ; delay_ms(20);
4234: 2E14     [1720]       ld	    l, 20
4236: CDC342   [1737]       call    delay_ms
4239: E1       [1747]       pop	    hl
423A: C9       [1757]       ret
                        #endlocal
                        
                        ; void lcd_bl_on()
                        ; - turn on LCD backlight
423B:                   lcd_bl_on::
423B: 3E05     [ 7]         ld	    a, SIOWR0_CMD_NOP | SIOWR0_PTR_R5
423D: D322     [18]         out	    (PORT_SIOACTL), a
423F: 3EEA     [25]         ld	    a, SIOWR5_RTS | SIOWR5_TXENA | SIOWR5_TX_8_BITS | SIOWR5_DTR
4241: D322     [36]         out	    (PORT_SIOACTL), a
4243: C9       [46]         ret
                        
                        ; void lcd_bl_off()
                        ; - turn off LCD backlight
4244:                   lcd_bl_off::
4244: 3E05     [ 7]         ld	    a, SIOWR0_CMD_NOP | SIOWR0_PTR_R5
4246: D322     [18]         out	    (PORT_SIOACTL), a
4248: 3E6A     [25]         ld	    a, SIOWR5_RTS | SIOWR5_TXENA | SIOWR5_TX_8_BITS
424A: D322     [36]         out	    (PORT_SIOACTL), a
424C: C9       [46]         ret
                        
                        ; void bzero(uint8_t *ptr, uint16_t len)
                        ; NOTE: ptr in HL, len in BC
                        ; - zero "len" bytes starting at address "ptr"
                        #local
424D:                   bzero::
424D: D5       [11]         push    de
424E: 78       [15]         ld	    a, b
424F: B1       [19]         or	    c
4250: 280C     [26|31]      jr	    z, done		; len is 0
4252: 3600     [36]         ld	    (hl), 0		; zero first byte of DATA seg
4254: 0B       [42]         dec	    bc
4255: 78       [46]         ld	    a, b
4256: B1       [50]         or	    c
4257: 2805     [57|62]      jr	    z, done		; len is 1
4259: 5D       [61]         ld	    e, l
425A: 54       [65]         ld	    d, h
425B: 13       [71]         inc	    de			; de = hl + 1
425C: EDB0     [87|21]      ldir			; zero last len-1 bytes
425E:                   done:
425E: D1       [10]         pop	    de
425F: C9       [20]         ret
                        #endlocal
                        
                        ; void seg_init()
4260:                   seg_init::
4260: AF       [ 4]         xor	    a
4261: CDB742   [21]         call    seg0_write
4264: CDBD42   [38]         call    seg1_write
4267: C9       [48]         ret
                        
                        ; void seg_writehex(uint8_t val)
                        ; - write the two hex digits of "val" to the 7-segment displays
4268:                   seg_writehex::
4268: E5       [11]         push    hl
4269: CD8F42   [28]         call    seg1_writehex
426C: 7D       [32]         ld	    a, l
426D: 07       [36]         rlca
426E: 07       [40]         rlca
426F: 07       [44]         rlca
4270: 07       [48]         rlca
4271: 6F       [52]         ld	    l, a
4272: CD7742   [69]         call    seg0_writehex
4275: E1       [79]         pop	    hl
4276: C9       [89]         ret
                        
                        #local
                        ; void seg0_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
4277:                   seg0_writehex::
4277: E5       [11]         push    hl
4278: C5       [22]         push    bc
4279: 01A742   [32]         ld	    bc, hex2seg_table
427C: 7D       [36]         ld	    a, l
427D: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
427F: 6F       [47]         ld	    l, a
4280: 2600     [54]         ld	    h, 0
4282: 09       [65]         add	    hl, bc  ; hl = hex2seg_table + (val & 0xF)
4283: 3ADD42   [78]         ld	    a, (Seg0_data)
4286: E680     [85]         and	    SEG_DP
4288: B6       [92]         or	    (hl)    ; a = (*Seg0_data & SEG_DP) | hex2seg_table[val & 0xF]
4289: CDB742   [109]        call    seg0_write
428C: C1       [119]        pop	    bc
428D: E1       [129]        pop	    hl
428E: C9       [139]        ret
                        
                        ; void seg1_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
428F:                   seg1_writehex::
428F: E5       [11]         push    hl
4290: C5       [22]         push    bc
4291: 01A742   [32]         ld	    bc, hex2seg_table
4294: 7D       [36]         ld	    a, l
4295: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
4297: 6F       [47]         ld	    l, a
4298: 2600     [54]         ld	    h, 0
429A: 09       [65]         add	    hl, bc  ; hl = hex2seg_table + (val & 0xF)
429B: 3ADE42   [78]         ld	    a, (Seg1_data)
429E: E680     [85]         and	    SEG_DP
42A0: B6       [92]         or	    (hl)    ; a = (*Seg1_data & SEG_DP) | hex2seg_table[val & 0xF]
42A1: CDBD42   [109]        call    seg1_write
42A4: C1       [119]        pop	    bc
42A5: E1       [129]        pop	    hl
42A6: C9       [139]        ret
                        
42A7:                   hex2seg_table:
                            ; 0
42A7: 3F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F
                            ; 1
42A8: 06                    .byte SEG_B | SEG_C
                            ; 2
42A9: 5B                    .byte SEG_A | SEG_B | SEG_G | SEG_E | SEG_D
                            ; 3
42AA: 4F                    .byte SEG_A | SEG_B | SEG_G | SEG_C | SEG_D
                            ; 4
42AB: 66                    .byte SEG_F | SEG_G | SEG_B | SEG_C
                            ; 5
42AC: 6D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D
                            ; 6
42AD: 7D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; 7
42AE: 07                    .byte SEG_A | SEG_B | SEG_C
                            ; 8
42AF: 7F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G
                            ; 9
42B0: 6F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_F | SEG_G
                            ; A
42B1: 77                    .byte SEG_A | SEG_B | SEG_C | SEG_E | SEG_F | SEG_G
                            ; b
42B2: 7C                    .byte SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; C
42B3: 39                    .byte SEG_A | SEG_D | SEG_E | SEG_F
                            ; d
42B4: 5E                    .byte SEG_B | SEG_C | SEG_D | SEG_E | SEG_G
                            ; E
42B5: 79                    .byte SEG_A | SEG_D | SEG_E | SEG_F | SEG_G
                            ; F
42B6: 71                    .byte SEG_A | SEG_E | SEG_F | SEG_G
                        #endlocal
                        
                        ; void seg0_write(uint8_t bits)
                        ; - parameter passed in A
                        ; - write raw bits to first 7-segment display register
42B7:                   seg0_write::
42B7: 32DD42   [13]         ld	    (Seg0_data), a
42BA: D300     [24]         out	    (PORT_SEG0), a
42BC: C9       [34]         ret
                        
                        ; void seg1_write(uint8_t bits)
                        ; - parameter passed in A
                        ; - write raw bits to second 7-segment display register
42BD:                   seg1_write::
42BD: 32DE42   [13]         ld	    (Seg1_data), a
42C0: D310     [24]         out	    (PORT_SEG1), a
42C2: C9       [34]         ret
                        
                        ; void delay_ms(uint8_t ms)
                        ; - delay for at least the specified number of milliseconds
                        #local
42C3:                   delay_ms::
42C3: 2C       [ 4]         inc	    l
42C4: 2D       [ 8]         dec	    l
42C5: C8       [13|19]      ret	    z		; delay of 0 returns immediately
42C6: C5       [24]         push    bc
42C7: 45       [28]         ld	    b, l
42C8:                   loop:
42C8: CDCF42   [17]         call    delay_1ms
42CB: 10FB     [25|30]      djnz    loop
42CD: C1       [35]         pop	    bc
42CE: C9       [45]         ret
                        #endlocal
                        
                        ; void delay_1ms()
                        ; - delay for 1ms (technically, 0.9999ms)
                        #local
42CF:                   delay_1ms::
42CF: C5       [11]         push    bc		; 11 T-states
                        ; To delay 1ms, we want to wait 10,000 T-states (@10MHz)
                        ; The loop is (38*b + 13*(b-1) + 8) T-states long
                        ; Rearranging: 51*b - 5
                        ; Solve for b: b = (10000 + 5 / 51) = 196.17
42D0: 06C3     [18]         ld	    b, 195	; 7 T-states
42D2:                   loop:
42D2: DD7E01   [19]         ld	    a, (ix+1)	; 19 T-states
42D5: DD7E01   [38]         ld	    a, (ix+1)	; 19 T-states
42D8: 10F8     [46|51]      djnz    loop	; (b-1)*13+8 T-states
42DA: C1       [56]         pop	    bc		; 10 T-states
42DB: 00       [60]         nop			; 4 T-states
42DC: C9       [70]         ret			; 10 T-states
                        ; We also assume the routine is CALLed, for 17 T-states.
                        ; Total delay is therefore:
                        ;   17 + 11 + 7 + 51*195 - 5 + 10 + 4 + 10 = 9,999
                        #endlocal
                        
                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                        ; data segment immediately follows code
                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
42DD:                   #data DATA,TEXT_end
                        ; define static variables here
42DD: 00                Seg0_data:: defs 1	; current value of first 7-segment display byte
42DE: 00                Seg1_data:: defs 1	; current value of second 7-segment display byte


total time: 0.0135 sec.
no errors
