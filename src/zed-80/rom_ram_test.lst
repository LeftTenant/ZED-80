                        ; --------------------------------------
                        ; zasm: assemble "rom_ram_test.asm"
                        ; date: 2019-04-29 14:57:12
                        ; --------------------------------------


                        ; Calling convention used in this file
                        ; ------------------------------------
                        ;
                        ; Unless otherwise noted, the first parameter, and the return value are stored as follows:
                        ; 8 bits: L
                        ; 16 bits: HL
                        ; 32 bits: DEHL
                        ;
                        ; Additional parameters are passed on the stack, left-to-right.
                        ; Parameters and return values larger than 32 bits are passed on the stack (return value
                        ; space set up by caller as a hidden first argument).
                        ; Callee saves/restores any modified registers.
                        ; Caller pops arguments after call returns.
                        ; AF registers are scratch (caller preserves, if needed).
                        
                        ; same as 'bin', except that the default fill byte for 'defs' etc. is 0xff
                        #target rom
                        
                        #include "sysreg.inc"
0070:                   PORT_SYSREG	    equ 0x70		; port address for system control register (U23)
                        
                        ; These values are the bit masks.
0001:                   SYS_MMUEN	    equ 0x01		; MMU enable
0002:                   SYS_SDCLK	    equ 0x02		; SD card input register & card clock
0004:                   SYS_SDCS	    equ 0x04		; SD card chip select (active low)
0008:                   SYS_SDICLR	    equ 0x08		; SD card input register clear (active low)
0010:                   SYS_SDOCLK	    equ 0x10		; SD card output register clock
0020:                   SYS_BDIR	    equ 0x20		; Audio chip BDIR line (bus direction)
0040:                   SYS_BC1		    equ 0x40		; Audio chip BC1 line (bus control 1)
0080:                   SYS_RESERVED	    equ 0x80		; Reserved for future use
                        
                        ; These are the bit numbers (usefil for bit, set, and res instructions).
0000:                   SYS_IDX_MMUEN	    equ 0
0001:                   SYS_IDX_SDCLK	    equ 1
0002:                   SYS_IDX_SDCS	    equ 2
0003:                   SYS_IDX_SDICLR	    equ 3
0004:                   SYS_IDX_SDOCLK	    equ 4
0005:                   SYS_IDX_BDIR	    equ 5
0006:                   SYS_IDX_BC1	    equ 6
0007:                   SYS_IDX_RESERVED    equ 7
                        #include "mmu.inc"
                        ; The MMU consists of four 16KB page frames in the Z80's address space.
                        ; Each page frame has its own 4-bit-wide register, which defines which physical
                        ; page is mapped into that frame. There are 16 physical pages, each 16KB in size,
                        ; for a total of 256KB of physical address space.
                        ; The physical memory map is:
                        ; 0x00000-0x7FFFF: Flash RAM
                        ; 0x80000-0xFFFFF: RAM
                        
0060:                   PORT_MMUBASE	equ 0x60		; base port address for MMU register
0060:                   PORT_MMUPG0	equ PORT_MMUBASE	; port address for MMU page 0 register
0061:                   PORT_MMUPG1	equ PORT_MMUBASE + 1	; port address for MMU page 1 register
0062:                   PORT_MMUPG2	equ PORT_MMUBASE + 2	; port address for MMU page 2 register
0063:                   PORT_MMUPG3	equ PORT_MMUBASE + 3	; port address for MMU page 3 register
                        
0000:                   MMU_ROM_BASE	equ 0			; ROM starts at physical page 0
0008:                   MMU_RAM_BASE	equ 8			; RAM starts at physical page 8
                        #include "7segdisp.inc"
0000:                   PORT_SEG0	equ 0x00	    ; port address for first 7-segment display element
0010:                   PORT_SEG1	equ 0x10	    ; port address for second 7-segment display element
                        
                        ; 7-segment display map
                        ;      A
                        ;  +-------+
                        ;  |       |
                        ; F|       |B
                        ;  |   G   |
                        ;  +-------+
                        ;  |       |
                        ; E|       |C
                        ;  |   D   |
                        ;  +-------+  .DP
                        
                        ; These values are the bit masks.
0001:                   SEG_A		equ 0x01	; segment A
0002:                   SEG_B		equ 0x02	; segment B
0004:                   SEG_C		equ 0x04	; segment C
0008:                   SEG_D		equ 0x08	; segment D
0010:                   SEG_E		equ 0x10	; segment E
0020:                   SEG_F		equ 0x20	; segment F
0040:                   SEG_G		equ 0x40	; segment G
0080:                   SEG_DP		equ 0x80	; decimal point
                        
                        ; These are the bit numbers (useful for bit, set, and res instructions).
0000:                   SEG_IDX_A	equ 0
0001:                   SEG_IDX_B	equ 1
0002:                   SEG_IDX_C	equ 2
0003:                   SEG_IDX_D	equ 3
0004:                   SEG_IDX_E	equ 4
0005:                   SEG_IDX_F	equ 5
0006:                   SEG_IDX_G	equ 6
0007:                   SEG_IDX_DP	equ 7
                        #include "joystick.inc"
0000:                   PORT_JOY0	equ 0x00	    ; port address for first joystick (read-only)
0010:                   PORT_JOY1	equ 0x10	    ; port address for second joystick (read-only)
                        
                        ; Bit masks for the values in the joystick status register.
                        ; These bits are active-low (normally high).
0001:                   JOY_UP		equ 0x01
0002:                   JOY_DOWN	equ 0x02
0004:                   JOY_LEFT	equ 0x04
0008:                   JOY_RIGHT	equ 0x08
0010:                   JOY_FIRE	equ 0x10
0020:                   JOY_SDWP	equ 0x20	    ; only on PORT_JOY1 (second port)
0040:                   JOY_SDCD	equ 0x40	    ; only on PORT_JOY1 (second port)
0080:                   JOY_RESERVED	equ 0x80
                        
                        ; The bit numbers (useful for bit, set, and res instructions).
0000:                   JOY_IDX_UP	equ 0
0001:                   JOY_IDX_DOWN	equ 1
0002:                   JOY_IDX_LEFT	equ 2
0003:                   JOY_IDX_RIGHT	equ 3
0004:                   JOY_IDX_FIRE	equ 4
0005:                   JOY_IDX_SDWP	equ 5
0006:                   JOY_IDX_SDCD	equ 6
                        #include "keyboard.inc"
0090:                   PORT_KBD	equ 0x90	    ; port address for keyboard byte input
                        #include "sound.inc"
                        #include "sysreg.inc"
0070:                   PORT_SYSREG	    equ 0x70		; port address for system control register (U23)
                        
                        ; These values are the bit masks.
0001:                   SYS_MMUEN	    equ 0x01		; MMU enable
0002:                   SYS_SDCLK	    equ 0x02		; SD card input register & card clock
0004:                   SYS_SDCS	    equ 0x04		; SD card chip select (active low)
0008:                   SYS_SDICLR	    equ 0x08		; SD card input register clear (active low)
0010:                   SYS_SDOCLK	    equ 0x10		; SD card output register clock
0020:                   SYS_BDIR	    equ 0x20		; Audio chip BDIR line (bus direction)
0040:                   SYS_BC1		    equ 0x40		; Audio chip BC1 line (bus control 1)
0080:                   SYS_RESERVED	    equ 0x80		; Reserved for future use
                        
                        ; These are the bit numbers (usefil for bit, set, and res instructions).
0000:                   SYS_IDX_MMUEN	    equ 0
0001:                   SYS_IDX_SDCLK	    equ 1
0002:                   SYS_IDX_SDCS	    equ 2
0003:                   SYS_IDX_SDICLR	    equ 3
0004:                   SYS_IDX_SDOCLK	    equ 4
0005:                   SYS_IDX_BDIR	    equ 5
0006:                   SYS_IDX_BC1	    equ 6
0007:                   SYS_IDX_RESERVED    equ 7
                        
                        ; Bus control states
0000:                   SNDBUS_IDLE	    equ 0
0040:                   SNDBUS_READ	    equ SYS_BC1
0020:                   SNDBUS_WRITE	    equ SYS_BDIR
0060:                   SNDBUS_ADDR	    equ SYS_BDIR | SYS_BC1
                        
                        ; Register names and numbers
0000:                   SNDREG_ATPF	    equ 0		; channel A tone period, fine
0001:                   SNDREG_ATPC	    equ 1		; channel A tone period, coarse
0002:                   SNDREG_BTPF	    equ 2		; channel B tone period, fine
0003:                   SNDREG_BTPC	    equ 3		; channel B tone period, coarse
0004:                   SNDREG_CTPF	    equ 4		; channel C tone period, fine
0005:                   SNDREG_CTPC	    equ 5		; channel C tone period, coarse
0006:                   SNDREG_NOISE	    equ 6		; noise period
0007:                   SNDREG_ENABLE	    equ 7		; enables and IO directions
000A:                   SNDREG_AAMP	    equ 10		; channel A amplitude
000B:                   SNDREG_BAMP	    equ 11		; channel B amplitude
000C:                   SNDREG_CAMP	    equ 12		; channel C amplitude
000D:                   SNDREG_ENVF	    equ 13		; envelope period, fine
000E:                   SNDREG_ENVC	    equ 14		; envelope period, coarse
000F:                   SNDREG_ENVS	    equ 15		; envelope shape & cycle
0010:                   SNDREG_PORTA	    equ 16		; IO port A data
0011:                   SNDREG_PORTB	    equ 17		; IO port B data
                        
                        ; SNDREG_ENABLE fields
0001:                   SNDENA_ATONE	    equ 0x01		; ~ channel A tone enable
0002:                   SNDENA_BTONE	    equ 0x02		; ~ channel B tone enable
0004:                   SNDENA_CTONE	    equ 0x04		; ~ channel C tone enable
0008:                   SNDENA_ANOISE	    equ	0x08		; ~ channel A noise enable
0010:                   SNDENA_BNOISE	    equ 0x10		; ~ channel B noise enable
0020:                   SNDENA_CNOISE	    equ 0x20		; ~ channel C noise enable
0040:                   SNDENA_AIODIR	    equ 0x40		; IO port A direction (0=in, 1=out)
0080:                   SNDENA_BIODIR	    equ 0x80		; IO port B direction (0=in, 1=out)
                        #include "z84c20.inc"
                        ; The Z84C20 is the Z80's PIO peripheral. See um0081.pdf for documentation.
                        
0030:                   PORT_PIOBASE	equ 0x30		; base port address for PIO chip
0030:                   PORT_PIOADAT	equ PORT_PIOBASE	; port address for PIO port A, data register
0031:                   PORT_PIOBDAT	equ PORT_PIOBASE + 1    ; port address for PIO port B, data register
0032:                   PORT_PIOACTL	equ PORT_PIOBASE + 2    ; port address for PIO port A, control register
0033:                   PORT_PIOBCTL	equ PORT_PIOBASE + 3    ; port address for PIO port B, control register
                        
                        ; PIO Control Register commands
0000:                   PIOC_IVEC	equ 0x00	; OR in the high 7 bits of the interrupt vector
000F:                   PIOC_MODE	equ 0x0F	; OR in the desired PIOMODE_xxx setting
0007:                   PIOC_ICTL	equ 0x07	; OR in the desired PIOICTL_xxx settings
                        
                        ; PIOC_MODE values
0000:                   PIOMODE_OUTPUT	equ 0x00
0040:                   PIOMODE_INPUT	equ 0x40
0080:                   PIOMODE_BIDIREC	equ 0x80
00C0:                   PIOMODE_CONTROL	equ 0xC0	; next control byte written must be the IO direction byte
                        				; 1 = input, 0 = output
                        
                        ; PIOC_ICTL values
0080:                   PIOICTL_INTENA	equ 0x80	; enable interrupts
0000:                   PIOICTL_INTDIS	equ 0x00	; disable interrupts
0040:                   PIOICTL_AND	equ 0x40	; AND inputs together for port monitoring interrupt
0000:                   PIOICTL_OR	equ 0x00	; OR inputs together for port monitoring interrupt
0020:                   PIOICTL_HIGH	equ 0x20	; interrupt on high (1) inputs
0000:                   PIOICTL_LOW	equ 0x00	; interrupt on low (0) inputs
0010:                   PIOICTL_MASKNXT equ 0x10	; next control byte written must be the input interrupt mask
                        				; 1 = input masked, 0 = input enabled
                        
                        M_pio_reset	macro
                            ld	    a, PIOC_MODE | PIOMODE_INPUT
                            out	    (PORT_PIOACTL), a
                            out	    (PORT_PIOBCTL), a
                            ld	    a, PIOC_ICTL | PIOICTL_INTDIS
                            out	    (PORT_PIOACTL), a
                            out	    (PORT_PIOBCTL), a
                            endm
                        #include "z84c30.inc"
                        ; The Z84C30 is the Z80's CTC peripheral. See um0081.pdf for documentation.
                        
0040:                   PORT_CTCBASE	equ 0x40		; base port address for CTC chip
0040:                   PORT_CTCIVEC	equ PORT_CTCBASE	; port address for Interrupt Vector Register
0040:                   PORT_CTC0	equ PORT_CTCBASE	; port address for CTC channel 0
0041:                   PORT_CTC1	equ PORT_CTCBASE + 1	; port address for CTC channel 1
0042:                   PORT_CTC2	equ PORT_CTCBASE + 2	; port address for CTC channel 2
0043:                   PORT_CTC3	equ PORT_CTCBASE + 3	; port address for CTC channel 3
                        
                        ; CTC Channel Control Word bits
0080:                   CTC_INTENA	equ 0x80		; enable interrupts
0000:                   CTC_INTDIS	equ 0x00		; disable interrupts
0040:                   CTC_MODECTR	equ 0x40		; COUNTER mode
0000:                   CTC_MODETMR	equ 0x00		; TIMER mode
0020:                   CTC_SCALE256	equ 0x20		; prescale by 256
0000:                   CTC_SCALE16	equ 0x00		; prescale by 16
0010:                   CTC_RISING	equ 0x10		; CLK/TRG on rising edges
0000:                   CTC_FALLING	equ 0x00		; CLK/TRG on falling edges
0008:                   CTC_CLKTRG	equ 0x08		; CLK/TRG pulse starts timer
0000:                   CTC_AUTO	equ 0x00		; automatic timer start after loading time constant
0004:                   CTC_TIMENXT	equ 0x04		; next control byte written is the time constant
0002:                   CTC_RESET	equ 0x02		; software reset
0001:                   CTC_CONTROL	equ 0x01		; always set to indicate this is a control word, not IVEC 
                        
                        M_ctc_reset	macro
                            ld	    a, CTC_CONTROL | CTC_RESET | CTC_INTDIS
                            out	    (PORT_CTC0), a
                            out	    (PORT_CTC1), a
                            out	    (PORT_CTC2), a
                            out	    (PORT_CTC3), a
                            endm
                        #include "z84c40.inc"
                        ; The Z84C40 is the Z80's SIO peripheral. See um0081.pdf for documentation.
                        
0020:                   PORT_SIOBASE	    equ 0x20		    ; base port address for SIO chip
0020:                   PORT_SIOADAT	    equ PORT_SIOBASE	    ; port address for SIO port A, data register
0021:                   PORT_SIOBDAT	    equ PORT_SIOBASE + 1    ; port address for SIO port B, data register
0022:                   PORT_SIOACTL	    equ PORT_SIOBASE + 2    ; port address for SIO port A, control register
0023:                   PORT_SIOBCTL	    equ PORT_SIOBASE + 3    ; port address for SIO port B, control register
                        
                        ; WR0 "CRC Reset Code" values (bits 7-6)
0000:                   SIOWR0_CRC_NOP		equ 0x00	    ; no CRC reset code
0040:                   SIOWR0_CRC_RST_RX_CHK	equ 1 << 6	    ; reset RX CRC checker
0080:                   SIOWR0_CRC_RST_TX_GEN	equ 2 << 6	    ; reset TX CRC generator
00C0:                   SIOWR0_CRC_RST_TX_UNDR  equ 3 << 6	    ; reset TX underrun/EOM latch
                        
                        ; WR0 "Command" values (bits 5-3)
0000:                   SIOWR0_CMD_NOP		equ 0x00	    ; no command
0008:                   SIOWR0_CMD_SND_ABRT	equ 1 << 3	    ; send abort (SDLC only)
0010:                   SIOWR0_CMD_RST_EXTINT	equ 2 << 3	    ; reset external/status interrupts
0018:                   SIOWR0_CMD_RST_CHAN	equ 3 << 3	    ; reset channel
0020:                   SIOWR0_CMD_INTENA_NXTRX	equ 4 << 3	    ; enable interrupt on next receive character
0028:                   SIOWR0_CMD_RST_TXINTPND equ 5 << 3	    ; reset TX interrupt pending
0030:                   SIOWR0_CMD_RST_ERR	equ 6 << 3	    ; reset error latches
0038:                   SIOWR0_CMD_INTRETN	equ 7 << 3	    ; return from interrupt (not needed with Z80)
                        
                        ; WR0 "Pointer" values (bits 2-0)
0000:                   SIOWR0_PTR_R0		equ 0x00	    ; set pointer to register 0
0001:                   SIOWR0_PTR_R1		equ 0x01	    ; set pointer to register 1
0002:                   SIOWR0_PTR_R2		equ 0x02	    ; set pointer to register 2
0003:                   SIOWR0_PTR_R3		equ 0x03	    ; set pointer to register 3
0004:                   SIOWR0_PTR_R4		equ 0x04	    ; set pointer to register 4
0005:                   SIOWR0_PTR_R5		equ 0x05	    ; set pointer to register 5
0006:                   SIOWR0_PTR_R6		equ 0x06	    ; set pointer to register 6
0007:                   SIOWR0_PTR_R7		equ 0x07	    ; set pointer to register 7
                        
                        ; WR1 interrupt & wait/ready control bits
0001:                   SIOWR1_EXTINTENA	equ 0x01	    ; external/status interrupt enable
0002:                   SIOWR1_TXINTENA		equ 0x02	    ; TX interrupt enable
0004:                   SIOWR1_STATIVEC		equ 0x04	    ; status affects interrupt vector (set in ch. B only)
0000:                   SIOWR1_RXINT_DISABLE	equ 0 << 3	    ; RX interrupts disabled
0008:                   SIOWR1_RXINT_FIRST	equ 1 << 3	    ; RX interrupt on first character
0010:                   SIOWR1_RXINT_ALLPRTY	equ 2 << 3	    ; RX interrupt on all characters, parity err is SR cond
0018:                   SIOWR1_RXINT_ALLNPRTY	equ 3 << 3	    ; RX interrupt on all characters, parity err no intr
                        ; bits 7-5 are for WAIT/READY functions, which we don't use (always write as 0)
                        
                        ; WR2 is the interrupt vector register (set in channel B only)
                        
                        ; WR3 receiver logic control bits
0001:                   SIOWR3_RXENA		equ 0x01	    ; receiver enable
0002:                   SIOWR3_SYNC_INHIBIT	equ 0x02	    ; sync character load inhibit
0004:                   SIOWR3_ADDR_SRCHMODE	equ 0x04	    ; address search mode
0008:                   SIOWR3_RXCRCENA		equ 0x08	    ; receiver CRC enable
0010:                   SIOWR3_ENTER_HUNT	equ 0x10	    ; enter hunt phase
0020:                   SIOWR3_AUTO_ENABLES	equ 0x20	    ; auto enables (DCD/CTS are RX/TX enables)
0000:                   SIOWR3_RX_5_BITS	equ 0 << 6	    ; receive 5 bits/character
0040:                   SIOWR3_RX_7_BITS	equ 1 << 6	    ; receive 7 bits/character
0080:                   SIOWR3_RX_6_BITS	equ 2 << 6	    ; receive 6 bits/character
00C0:                   SIOWR3_RX_8_BITS	equ 3 << 6	    ; receive 8 bits/character
                        
                        ; WR4 RX/TX configuration (set first before WR1, WR3, WR5, WR6, and WR7)
0001:                   SIOWR4_PARITY		equ 0x01	    ; parity on/off
0002:                   SIOWR4_PRTY_EVEN	equ 0x02	    ; even parity
0000:                   SIOWR4_PRTY_ODD		equ 0x00	    ; odd parity
0000:                   SIOWR4_TXSTOP_SYNC	equ 0 << 2	    ; synchronous mode (no TX stop bits)
0004:                   SIOWR4_TXSTOP_1		equ 1 << 2	    ; 1 TX stop bit
0008:                   SIOWR4_TXSTOP_1_5	equ 2 << 2	    ; 1.5 TX stop bits
000C:                   SIOWR4_TXSTOP_2		equ 3 << 2	    ; 2 TX stop bits
                        ; bits 5-4 set the sync modes, which we don't use (always write as 0)
0000:                   SIOWR4_CLK_x1		equ 0 << 6	    ; data rate x1 = clock rate
0040:                   SIOWR4_CLK_x16		equ 1 << 6	    ; data rate x16 = clock rate
0080:                   SIOWR4_CLK_x32		equ 2 << 6	    ; data rate x32 = clock rate
00C0:                   SIOWR4_CLK_x64		equ 3 << 6	    ; data rate x64 = clock rate
                        
                        ; WR5 transmitter logic control bits
0001:                   SIOWR5_TXCRCENA		equ 0x01	    ; transmitter CRC enable
0002:                   SIOWR5_RTS		equ 0x02	    ; request to send
0004:                   SIOWR5_CRC16_SDLC	equ 0x04	    ; CRC-16 vs. SDLC polynomial
0008:                   SIOWR5_TXENA		equ 0x08	    ; transmitter enable
0010:                   SIOWR5_SND_BRK		equ 0x10	    ; send break
0000:                   SIOWR5_TX_5_BITS	equ 0 << 5	    ; transmit 5 bits/character
0020:                   SIOWR5_TX_7_BITS	equ 1 << 5	    ; transmit 7 bits/character
0040:                   SIOWR5_TX_6_BITS	equ 2 << 5	    ; transmit 6 bits/character
0060:                   SIOWR5_TX_8_BITS	equ 3 << 5	    ; transmit 8 bits/character
0080:                   SIOWR5_DTR		equ 0x80	    ; data terminal ready
                        
                        ; WR6 transmitter sync register for use in synchronous modes, which we don't use
                        ; WR7 receiver sync register for use in synchronous modes, which we don't use
                        
                        ; RR0 status bits (mostly normal operation)
0001:                   SIORR0_RCA		equ 0x01	    ; RX character available
0002:                   SIORR0_INTPND		equ 0x02	    ; interrupt pending (channel A only)
0004:                   SIORR0_TBE		equ 0x04	    ; TX buffer empty
0008:                   SIORR0_DCD		equ 0x08	    ; latched DCD input bit
0010:                   SIORR0_SYNC		equ 0x10	    ; latched SYNC input bit (hunt in SDLC)
0020:                   SIORR0_CTS		equ 0x20	    ; latched CTS input bit
0040:                   SIORR0_TX_UNDR		equ 0x40	    ; TX underrun / end of message
0080:                   SIORR0_BRK_ABRT		equ 0x80	    ; break/abort detected
                        ; As bit numbers, useful for the "bit" instruction, to test individual bit flags
0000:                   SIORR0_IDX_RCA		equ 0
0001:                   SIORR0_IDX_INTPND	equ 1
0002:                   SIORR0_IDX_TBE		equ 2
0003:                   SIORR0_IDX_DCD		equ 3
0004:                   SIORR0_IDX_SYNC		equ 4
0005:                   SIORR0_IDX_CTS		equ 5
0006:                   SIORR0_IDX_TX_UNDR	equ 6
0007:                   SIORR0_IDX_BRK_ABRT	equ 7
                        
                        ; RR1 status bits (mostly errors)
0001:                   SIORR1_ALLSENT		equ 0x01	    ; all characters fully sent
                        ; bits 3-1 are SDLC-only
0010:                   SIORR1_PRTYERR		equ 0x10	    ; parity error
0020:                   SIORR1_ROE		equ 0x20	    ; RX overrun error
0040:                   SIORR1_CRCFRMERR	equ 0x40	    ; CRC/framing error
                        ; bit 7 is SDLC-only
                        
                        ; RR2 is the interrupt vector register (read from channel B only)
                        ; - if "Status Affects Vector" bit is set, this will be the current vector value,
                        ;   modified by whatever interrupt conditions are pending
                        
                        M_sio_reset	macro
                            ld	    a, SIOWR0_CMD_RST_CHAN
                            out	    (PORT_SIOACTL), a
                            out	    (PORT_SIOBCTL), a
                            endm
                        
                        ; We set up the MMU so the Z80's memory map is as follows:
                        ; PG0: 0x0000-0x3FFF ROM physical page 0 (ROM page 0)
                        ; PG1: 0x4000-0x7FFF RAM physical page 8 (RAM page 0)
                        ; PG2: 0x8000-0xBFFF RAM physical page 9 (RAM page 1)
                        ; PG3: 0xC000-0xFFFF RAM physical page A (RAM page 2)
                        
4000:                   #data RAM, 0x4000, 0xC000
                        ; define static variables here
4000: 00                Sysreg::    defs 1	; current value of SYSREG
4001: 00                Seg0_data:: defs 1	; current value of first 7-segment display byte
4002: 00                Seg1_data:: defs 1	; current value of second 7-segment display byte
                        
0000:                   #code ROM, 0, 0x4000
                        
                        ; reset vector
0000:                   RST0::
0000: F3       [ 4]         di
0001: C38800   [14]         jp	    init
0004: FFFFFFFF              defs    0x08-$
                        
0008:                   RST1::
0008: ED4D     [14]         reti
000A: FFFFFFFF              defs    0x10-$
000E: FFFF              
                        
0010:                   RST2::
0010: ED4D     [14]         reti
0012: FFFFFFFF              defs    0x18-$
0016: FFFF              
                        
0018:                   RST3::
0018: ED4D     [14]         reti
001A: FFFFFFFF              defs    0x20-$
001E: FFFF              
                        
0020:                   RST4::
0020: ED4D     [14]         reti
0022: FFFFFFFF              defs    0x28-$
0026: FFFF              
                        
0028:                   RST5::
0028: ED4D     [14]         reti
002A: FFFFFFFF              defs    0x30-$
002E: FFFF              
                        
0030:                   RST6::
0030: ED4D     [14]         reti
0032: FFFFFFFF              defs    0x38-$
0036: FFFF              
                        
                        ; maskable interrupt handler in interrupt mode 1:
0038:                   RST7::
0038: ED4D     [14]         reti
                        
                        ; non maskable interrupt:
                        ; e.g. call debugger and on exit resume.
003A: FFFFFFFF              defs    0x66-$
003E: FF...             
0066:                   NMI::
0066: ED45     [14]         retn
                        
                        ; Empty ISR for interrupts we want to ignore
0068:                   ISR_nop::
0068: FB       [ 4]         ei
0069: ED4D     [18]         reti
                        
006B: FFFFFFFF              defs    0x80-$
006F: FF...             
                        ; Interrupt Vector Table
0080:                   IVT::
                        ; Table starts at 0x0080
                        ; CTC has first 4 slots, so CTC Interrupt Vector register should be 0x80
0080: 6800                  .word   ISR_nop	    ; CTC channel 0
0082: 6800                  .word   ISR_nop	    ; CTC channel 1
0084: 6800                  .word   ISR_nop	    ; CTC channel 2
0086: 9D01                  .word   ISR_ctc3	    ; CTC channel 3
                        ; TODO: ISRs for PIO & SIO
                        
                        ; Set the mode for PIO port B. 'mode' is one of the PIOMODE_xxx constants.
                        M_pio_set_portB_mode	macro mode
                            ld	    a, PIOC_MODE | &mode
                            out	    (PORT_PIOBCTL), a
                            endm
                        
                        ; void init()
0088:                   init::
                            ; Need to initialize MMU without use of RAM, so be careful here
0088: AF       [ 4]         xor	    a
0089: D360     [15]         out	    (PORT_MMUPG0), a	; map frame 0 to 1st page of ROM
008B: 3E08     [22]         ld	    a, MMU_RAM_BASE
008D: D361     [33]         out	    (PORT_MMUPG1), a	; map frame 1 to 1st page of RAM
008F: 3E09     [40]         ld	    a, MMU_RAM_BASE + 1
0091: D362     [51]         out	    (PORT_MMUPG2), a	; map frame 2 to 2nd page of RAM
0093: 3E0A     [58]         ld	    a, MMU_RAM_BASE + 2
0095: D363     [69]         out	    (PORT_MMUPG3), a	; map frame 3 to 3rd page of RAM
0097: 3E0D     [76]         ld	    a, SYS_MMUEN | SYS_SDCS | SYS_SDICLR
0099: D370     [87]         out	    (PORT_SYSREG), a	; enable MMU
009B: 320040   [100]        ld	    (Sysreg), a
                            ; set up a stack
009E: 31FFFF   [110]        ld	    sp, RAM_end-1
                            ; set up interrupts
00A1: 3E00     [117]        ld	    a, hi(IVT)
00A3: ED47     [126]        ld	    i, a	    ; I gets high byte of IVT address
00A5: ED5E     [134]        im	    2		    ; select interrupt mode 2
00A7: FB       [138]        ei
                            ; clear 7-segment display
00A8: 2E00     [145]        ld	    l, 0
00AA: CD1403   [162]        call    seg0_write
00AD: CD1B03   [179]        call    seg1_write
00B0: CDA901   [196]        call    snd_test	    ; boot sound
                        ;    call    ctc_test	    ; need to set up CTC to get SIO working (need baud rate gen)
                        ;    call    sio_test
                        ;    call    figure8
                        ;    call    countup
                        ;    call    pio_test
00B3: CD2C02   [213]        call    joy_test	    ; may as well run the joystick test if we get here
00B6: 18FE     [225]        jr	    $		    ; loop forever
                        
                        ; void countup()
                        #local
00B8:                   countup::
00B8: E5       [11]         push    hl
00B9: 2600     [18]         ld	    h, 0	; counter in h
                        ; increment count every 500ms and toggle DP
00BB:                   forever:
00BB: 6C       [ 4]         ld	    l, h
00BC: CD9002   [21]         call    seg_writehex    ; display counter
00BF: 2E80     [28]         ld	    l, SEG_DP
00C1: CDFE02   [45]         call    seg0_toggle	    ; toggle DP
00C4: 2EFA     [52]         ld	    l, 250
00C6: CD2203   [69]         call    delay_ms	    ; delay 250ms
00C9: CD2203   [86]         call    delay_ms	    ; delay 250ms
00CC: 24       [90]         inc	    h
00CD: 18EC     [102]        jr	    forever
00CF: E1       [112]        pop	    hl
00D0: C9       [122]        ret
                        #endlocal
                        
                        ; void figure8()
                        #local
00D1:                   figure8::
00D1: E5       [11]         push    hl
00D2: C5       [22]         push    bc
                        ; step fig8 every 125ms; toggle DP every 1s
00D3:                   forever:
00D3: 0607     [ 7]         ld	    b, 7
00D5:                   fig8_loop:
00D5: 68       [ 4]         ld	    l, b
00D6: CDE102   [21]         call    seg0_fig8
00D9: 2E7D     [28]         ld	    l, 125
00DB: CD2203   [45]         call    delay_ms
00DE: 05       [49]         dec	    b
00DF: F2D500   [59|59]      jp	    p, fig8_loop
00E2: 2E80     [66]         ld	    l, SEG_DP
00E4: CDFE02   [83]         call    seg0_toggle
00E7: 18EA     [95]         jr	    forever
00E9: C1       [105]        pop	    bc
00EA: E1       [115]        pop	    hl
00EB: C9       [125]        ret
                        #endlocal
                        
                        ; void pio_test()
                        #local
00EC:                   pio_test::
00EC: E5       [11]         push    hl
00ED: C5       [22]         push    bc
                            ; configure PIO ports A and B
00EE: 013204   [32]         ld	    bc, 0x0400 | PORT_PIOACTL
00F1: 211D01   [42]         ld	    hl, pioA_cfg
00F4: EDB3     [58|21]      otir
                        ; Don't configure port B here -- it's used for the audio chip
                        ;    ld	    bc, 0x0300 | PORT_PIOBCTL
                            ; HL already points to pioB_cfg
                        ;    otir
00F6: CD2401   [75]         call    pio_srclr		; clear shift register at startup
00F9:                   forever:
00F9: 2E80     [ 7]         ld	    l, SEG_DP
00FB: CD0903   [24]         call    seg1_toggle
00FE: DB30     [35]         in	    a, (PORT_PIOADAT)	; read PIO port A
0100: 2F       [39]         cpl				; invert SRPRTY and SRSTRT signals
0101: CB6F     [47]         bit	    5, a		; if SRSTRT is high, keep polling
0103: 20F4     [54|59]      jr	    nz, forever
                            ; put SRPRTY onto segment 0's DP
0105: E610     [61]         and	    0x10		; mask off other bits
0107: 87       [65]         add	    a, a
0108: 87       [69]         add	    a, a
0109: 87       [73]         add	    a, a		; shift SRPRTY left 3 bits to bit 7 (SEG_DP)
010A: 6F       [77]         ld	    l, a
010B: CD1403   [94]         call    seg0_write
                            ; read keyboard latch, displaying hex value after inverting
010E: DB90     [105]        in	    a, (PORT_KBD)
0110: 2F       [109]        cpl
0111: 6F       [113]        ld	    l, a
0112: CD2401   [130]        call    pio_srclr		; clear shift register to prepare for next byte
0115: CD9002   [147]        call    seg_writehex
0118: 18DF     [159]        jr	    forever
011A: C1       [169]        pop	    bc
011B: E1       [179]        pop	    hl
011C: C9       [189]        ret
011D:                   pioA_cfg:
011D: CF                    .byte PIOC_MODE | PIOMODE_CONTROL
011E: F7                    .byte 0xF7	    ; A3 is an output (~SRCLR), everything else is an input
011F: 37                    .byte PIOC_ICTL | PIOICTL_INTDIS | PIOICTL_OR | PIOICTL_HIGH | PIOICTL_MASKNXT
0120: DF                    .byte 0xDF	    ; interrupt on A5 only (SRSTRT)
0121:                   pioB_cfg:
0121: CF                    .byte PIOC_MODE | PIOMODE_CONTROL
0122: FF                    .byte 0xFF	    ; everything is an input
0123: 27                    .byte PIOC_ICTL | PIOICTL_INTDIS | PIOICTL_OR | PIOICTL_HIGH
                        #endlocal
                        
                        ; void pio_srclr()
                        ; - clear shift register by toggling ~SRCLR line, leaving it HIGH
                        #local
0124:                   pio_srclr::
0124: AF       [ 4]         xor	    a
0125: D330     [15]         out	    (PORT_PIOADAT), a
0127: 3E08     [22]         ld	    a, 0x08	; bit 3
0129: D330     [33]         out	    (PORT_PIOADAT), a
012B: C9       [43]         ret
                        #endlocal
                        
                        ; void sio_test()
                        #local
012C:                   sio_test::
012C: E5       [11]         push    hl
012D: C5       [22]         push    bc
                            ; configure SIO port A
012E: 012207   [32]         ld	    bc, 0x0700 | PORT_SIOACTL
0131: 217101   [42]         ld	    hl, sioA_cfg
0134: EDB3     [58|21]      otir
                            ; configure SIO port B
0136: 012307   [68]         ld	    bc, 0x0700 | PORT_SIOBCTL
0139: 217101   [78]         ld	    hl, sioA_cfg
013C: EDB3     [94|21]      otir
013E:                   forever:
                            ; wait for an input character
013E:                   waitRX:
013E: DB22     [11]         in	    a, (PORT_SIOACTL)
0140: CB47     [19]         bit	    SIORR0_IDX_RCA, a
0142: 2014     [26|31]      jr	    nz, doRXA
0144: DB23     [37]         in	    a, (PORT_SIOBCTL)
0146: CB47     [45]         bit	    SIORR0_IDX_RCA, a
0148: 28F4     [52|57]      jr	    z, waitRX
014A:                   doRXB:
                            ; read input character
014A: DB21     [11]         in	    a, (PORT_SIOBDAT)
014C: 6F       [15]         ld	    l, a
014D:                   waitTXB:
                            ; wait until transmitter is idle
014D: DB23     [11]         in	    a, (PORT_SIOBCTL)
014F: CB57     [19]         bit	    SIORR0_IDX_TBE, a
0151: 28FA     [26|31]      jr	    z, waitTXB
                            ; write output character
0153: 7D       [30]         ld	    a, l
0154: D321     [41]         out	    (PORT_SIOBDAT), a	; send byte out serial port
0156: 180C     [53]         jr	    writeSeg
0158:                   doRXA:
                            ; read input character
0158: DB20     [11]         in	    a, (PORT_SIOADAT)
015A: 6F       [15]         ld	    l, a
015B:                   waitTXA:
                            ; wait until transmitter is idle
015B: DB22     [11]         in	    a, (PORT_SIOACTL)
015D: CB57     [19]         bit	    SIORR0_IDX_TBE, a
015F: 28FA     [26|31]      jr	    z, waitTXA
                            ; write output character
0161: 7D       [30]         ld	    a, l
0162: D320     [41]         out	    (PORT_SIOADAT), a	; send byte out serial port
0164:                   writeSeg:
                            ; write it to the 7-segment display
0164: CD9002   [17]         call    seg_writehex
0167: 2E80     [24]         ld	    l, SEG_DP		; toggle DP on segment 0
0169: CDFE02   [41]         call    seg0_toggle
                            ; repeat
016C: 18D0     [53]         jr	    forever
016E: C1       [63]         pop	    bc
016F: E1       [73]         pop	    hl
0170: C9       [83]         ret
0171:                   sioA_cfg:
0171: 18                    .byte SIOWR0_CMD_RST_CHAN
0172: 04                    .byte SIOWR0_PTR_R4
0173: 44                    .byte SIOWR4_TXSTOP_1 | SIOWR4_CLK_x16	; x16=38400bps, x64=9600bps
                            ; No need to set up WR1/WR2, as they are only used for interrupts
0174: 03                    .byte SIOWR0_PTR_R3
0175: C1                    .byte SIOWR3_RXENA | SIOWR3_RX_8_BITS
0176: 05                    .byte SIOWR0_PTR_R5
0177: EA                    .byte SIOWR5_RTS | SIOWR5_TXENA | SIOWR5_TX_8_BITS | SIOWR5_DTR
                            ; No need to set up WR6/WR7, as they are only used for synchronous modes
                        #endlocal
                        
                        ; void ctc_test()
                        #local
0178:                   ctc_test::
                            ; load CTC Interrupt Vector Register
0178: 3E80     [ 7]         ld	    a, lo(IVT)	    ; CTC interrupt vectors are the first 4 in the IVT
017A: D340     [18]         out	    (PORT_CTCIVEC), a
                            ; channel 0 is the baud rate generator for serial 0
017C: 3E57     [25]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
017E: D340     [36]         out	    (PORT_CTC0), a
0180: 3E03     [43]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x64 gives 9600 baud)
0182: D340     [54]         out	    (PORT_CTC0), a
                            ; channel 1 is the baud rate generator for serial 1
0184: 3E57     [61]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
0186: D341     [72]         out	    (PORT_CTC1), a
0188: 3E03     [79]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x64 gives 9600 baud)
018A: D341     [90]         out	    (PORT_CTC1), a
                            ; channel 2 is used as a timer to divide down the system clock for channel 3
018C: 3E17     [97]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_AUTO | CTC_RISING | CTC_SCALE16 | CTC_MODETMR
018E: D342     [108]        out	    (PORT_CTC2), a
0190: 3EFA     [115]        ld	    a, 250	    ; 10MHz prescale by 16, divide by 250 is 2.5kHz
0192: D342     [126]        out	    (PORT_CTC2), a
                            ; channel 3 is used as a counter on the 2.5kHz signal from channel 2
0194: 3ED7     [133]        ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR | CTC_INTENA
0196: D343     [144]        out	    (PORT_CTC3), a
0198: 3EFA     [151]        ld	    a, 250	    ; 2.5kHz divided by 250 is 10Hz
019A: D343     [162]        out	    (PORT_CTC3), a
019C: C9       [172]        ret
                        #endlocal
                        
                        ; CTC channel 3 ISR
019D:                   ISR_ctc3::
019D: 08       [ 4]         ex	    af, af'
019E: D9       [ 8]         exx
019F: 2E80     [15]         ld	    l, SEG_DP
01A1: CD0903   [32]         call    seg1_toggle
01A4: D9       [36]         exx
01A5: 08       [40]         ex	    af, af'
01A6: FB       [44]         ei
01A7: ED4D     [58]         reti
                        
                        ; void snd_test()
                        ; Bart's Alice 3 boot sound:
                        ; E2, B2, G#3, all 3 channels tone/no noise, all 3 channels on envelope, ~1.3s envelope, rampdown
                        ;     $7B, $01, $FD, $00, $96, $00, $00, $38, $10,$10,$10, $A1,$13, $09, $00,$00
                        ; With IO ports set to output mode, and a test pattern on the outputs:
                        ;     $7B, $01, $FD, $00, $96, $00, $00, $F8, $10,$10,$10, $A1,$13, $09, $A5,$5A
                        #local
01A9:                   snd_test::
01A9: E5       [11]         push    hl
                        ;    ld	    hl, 0xFF00 | SNDREG_ENABLE
                        ;    call    snd_write		; set ports A and B to output mode, disable all channels
                        ;    ld	    hl, 0xA500 | SNDREG_PORTA
                        ;    call    snd_write
                        ;    ld	    hl, 0x5A00 | SNDREG_PORTB
                        ;    call    snd_write
01AA: 21B201   [21]         ld	    hl, boot_sound
01AD: CD0C02   [38]         call    snd_writeall
01B0: E1       [48]         pop	    hl
01B1: C9       [58]         ret
01B2:                   boot_sound:
01B2: 7B01FD00              .byte $7B, $01, $FD, $00, $96, $00, $00, $F8, $10,$10,$10, $A1,$13, $09, $A5,$5A
01B6: 960000F8          
01BA: 101010A1          
01BE: 1309A55A          
                        #endlocal
                        
                        ; void snd_setaddr(uint8_t address)
                        ; - set the audio chip's internal register address to 'address'
                        ; - assumes audio chip's bus control lines are set IDLE at entry
                        ; TODO: This can probably be carefully open-coded to be more efficient
                        #local
01C2:                   snd_setaddr::
01C2: E5       [11]         push    hl
                            M_pio_set_portB_mode PIOMODE_OUTPUT
01C3: 3E0F     [18]         ld	    a, PIOC_MODE | PIOMODE_OUTPUT
01C5: D333     [29]         out	    (PORT_PIOBCTL), a
01C7: 7D       [33]         ld	    a, l
01C8: D331     [44]         out	    (PORT_PIOBDAT), a	; write address to PIO port B
01CA: 2E60     [51]         ld	    l, SNDBUS_ADDR
01CC: CD8402   [68]         call    sysreg_sndbus	; set SYSREG bus control lines to write address (1,1)
01CF: 2E00     [75]         ld	    l, SNDBUS_IDLE
01D1: CD8402   [92]         call    sysreg_sndbus	; set SYSREG bus control lines to idle (0,0)
01D4: E1       [102]        pop	    hl
01D5: C9       [112]        ret
                        #endlocal
                        
                        ; void snd_put(uint8_t data)
                        ; - set the audio chip's currently-addressed register to 'data'
                        ; - assumes audio chip's bus control lines are set IDLE at entry
                        ; TODO: This can probably be carefully open-coded to be more efficient
                        #local
01D6:                   snd_put::
01D6: E5       [11]         push    hl
                            M_pio_set_portB_mode PIOMODE_OUTPUT
01D7: 3E0F     [18]         ld	    a, PIOC_MODE | PIOMODE_OUTPUT
01D9: D333     [29]         out	    (PORT_PIOBCTL), a
01DB: 7D       [33]         ld	    a, l
01DC: D331     [44]         out	    (PORT_PIOBDAT), a	; write data to PIO port B
01DE: 2E20     [51]         ld	    l, SNDBUS_WRITE
01E0: CD8402   [68]         call    sysreg_sndbus	; set SYSREG bus control lines to write data (1,0)
01E3: 2E00     [75]         ld	    l, SNDBUS_IDLE
01E5: CD8402   [92]         call    sysreg_sndbus	; set SYSREG bus control lines to idle (0,0)
01E8: E1       [102]        pop	    hl
01E9: C9       [112]        ret
                        #endlocal
                        
                        ; uint8_t snd_read(uint8_t addr)
                        ; - read value from 'addr' on the sound chip
01EA:                   snd_read::
01EA: CDC201   [17]         call    snd_setaddr
                            ; FALLING THROUGH!!!
                        ; uint8_t snd_get()
                        ; - return the contents of the audio chip's currently-addressed register
                        ; - assumes audio chip's bus control lines are set IDLE at entry
                        ; TODO: This can probably be carefully open-coded to be more efficient
                        #local
01ED:                   snd_get::
01ED: C5       [11]         push    bc
                            M_pio_set_portB_mode PIOMODE_INPUT
01EE: 3E4F     [18]         ld	    a, PIOC_MODE | PIOMODE_INPUT
01F0: D333     [29]         out	    (PORT_PIOBCTL), a
01F2: 2E40     [36]         ld	    l, SNDBUS_READ
01F4: CD8402   [53]         call    sysreg_sndbus	; set SYSREG bus control lines to read data (0,1)
01F7: DB31     [64]         in	    a, (PORT_PIOBDAT)	; read from PIO port B
01F9: 47       [68]         ld	    b, a		; save audio register value in B
01FA: 2E00     [75]         ld	    l, SNDBUS_IDLE
01FC: CD8402   [92]         call    sysreg_sndbus	; set SYSREG bus control lines to idle (0,0)
01FF: 68       [96]         ld	    l, b		; return B
0200: C1       [106]        pop	    bc
0201: C9       [116]        ret
                        #endlocal
                        
                        ; void snd_write(uint8_t addr, uint8_t data)
                        ; - write 'data' to 'addr' on the sound chip
                        ; - 'addr' in L, 'data' in H
                        #local
0202:                   snd_write::
0202: E5       [11]         push    hl
0203: CDC201   [28]         call    snd_setaddr
0206: 6C       [32]         ld	    l, h
0207: CDD601   [49]         call    snd_put
020A: E1       [59]         pop	    hl
020B: C9       [69]         ret
                        #endlocal
                        
                        ; void snd_writeall(uint8_t *data)
                        ; - write 16 byte values from 'data' to the 16 registers of the sound chip
                        #local
020C:                   snd_writeall::
020C: C5       [11]         push    bc
020D: D5       [22]         push    de
020E: E5       [33]         push    hl
020F: EB       [37]         ex	    de, hl		; DE = data
0210: 2E00     [44]         ld	    l, 0		; L = regnum
0212: 0608     [51]         ld	    b, 8		; B = loop count
0214:                   write8:
0214: 1A       [ 7]         ld	    a, (de)		; A = *data
0215: 67       [11]         ld	    h, a
0216: CD0202   [28]         call    snd_write		; snd_write(regnum, *data)
0219: 2C       [32]         inc	    l			; ++regnum
021A: 13       [38]         inc	    de			; ++data
021B: 10F7     [46|51]      djnz    write8
021D: 3E12     [53]         ld	    a, 18
021F: BD       [57]         cp	    l
0220: 2806     [64|69]      jr	    z, done
0222: 2E0A     [71]         ld	    l, 10		; next bank of registers starts at 10
0224: 0608     [78]         ld	    b, 8		; set up loop for second time
0226: 18EC     [90]         jr	    write8
0228:                   done:
0228: E1       [10]         pop	    hl
0229: D1       [20]         pop	    de
022A: C1       [30]         pop	    bc
022B: C9       [40]         ret
                        #endlocal
                        
                        ; void joy_test()
                        #local
022C:                   joy_test::
022C: E5       [11]         push    hl
022D:                   forever:
022D: DB00     [11]         in	    a, (PORT_JOY0)	; read joystick 0
022F: 6F       [15]         ld	    l, a
0230: CD4302   [32]         call    joy_map2seg
0233: CD1403   [49]         call    seg0_write
0236: DB10     [60]         in	    a, (PORT_JOY1)	; read joystick 1
0238: 6F       [64]         ld	    l, a
0239: CD4302   [81]         call    joy_map2seg
023C: CD1B03   [98]         call    seg1_write
023F: 18EC     [110]        jr	    forever
0241: E1       [120]        pop	    hl
0242: C9       [130]        ret
                        #endlocal
                        
                        ; uint8_t joy_map2seg(uint8_t joy)
                        ; - map the joystick status bits in "joy" to a value suitable for writing to the 7-segment display
                        #local
0243:                   joy_map2seg::
0243: AF       [ 4]         xor	    a			; start with no bits on 7-segment display
0244: CB45     [12]         bit	    JOY_IDX_UP, l	; test for UP
0246: 2002     [19|24]      jr	    nz, done_up
0248: CBC7     [27]         set	    SEG_IDX_A, a	; turn on top segment
024A:                   done_up:
024A: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; test for DOWN
024C: 2002     [15|20]      jr	    nz, done_down
024E: CBDF     [23]         set	    SEG_IDX_D, a	; turn on bottom segment
0250:                   done_down:
                            ; if neither UP nor DOWN are active, activate (clear) both to get both top & bottom side segments
0250: CB45     [ 8]         bit	    JOY_IDX_UP, l
0252: 2808     [15|20]      jr	    z, sides
0254: CB4D     [23]         bit	    JOY_IDX_DOWN, l
0256: 2804     [30|35]      jr	    z, sides
0258: CB85     [38]         res	    JOY_IDX_UP, l
025A: CB8D     [46]         res	    JOY_IDX_DOWN, l
025C:                   sides:
025C: CB55     [ 8]         bit	    JOY_IDX_LEFT, l	; test for LEFT
025E: 200C     [15|20]      jr	    nz, done_left
0260: CB45     [23]         bit	    JOY_IDX_UP, l	; if UP, set top-left segment
0262: 2002     [30|35]      jr	    nz, no_top_left
0264: CBEF     [38]         set	    SEG_IDX_F, a
0266:                   no_top_left:
0266: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; if DOWN, set bottom-left segment
0268: 2002     [15|20]      jr	    nz, done_left
026A: CBE7     [23]         set	    SEG_IDX_E, a
026C:                   done_left:
026C: CB5D     [ 8]         bit	    JOY_IDX_RIGHT, l	; test for RIGHT
026E: 200C     [15|20]      jr	    nz, done_right
0270: CB45     [23]         bit	    JOY_IDX_UP, l	; if UP, set top-right segment
0272: 2002     [30|35]      jr	    nz, no_top_right
0274: CBCF     [38]         set	    SEG_IDX_B, a
0276:                   no_top_right:
0276: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; if DOWN, set bottom-right segment
0278: 2002     [15|20]      jr	    nz, done_right
027A: CBD7     [23]         set	    SEG_IDX_C, a
027C:                   done_right:
027C: CB65     [ 8]         bit	    JOY_IDX_FIRE, l	; test for FIRE
027E: 2002     [15|20]      jr	    nz, done_fire
0280: CBFF     [23]         set	    SEG_IDX_DP, a
0282:                   done_fire:
0282: 6F       [ 4]         ld	    l, a		; return segment mask
0283: C9       [14]         ret
                        #endlocal
                        
                        ; Library routines
                        ; ----------------
                        
                        ; void sysreg_sndbus(uint8_t bits)
                        ; - set only bits SYS_BDIR and SYS_BC1 to specified values (from 'bits') in SYSREG
0284:                   sysreg_sndbus::
0284: 3A0040   [13]         ld	    a, (Sysreg)		    ; read current value of SYSREG
0287: E69F     [20]         and	    ~(SYS_BDIR | SYS_BC1)   ; turn off bus control bits
0289: B5       [24]         or	    l			    ; set any specified bits
                            ; FALLING THROUGH!!!
                        
                        ; void sysreg_write(uint8_t bits)
                        ; - 'bits' passed in A register
                        ; - write raw bits to SYSREG
028A:                   sysreg_write::
028A: D370     [11]         out	    (PORT_SYSREG), a
028C: 320040   [24]         ld	    (Sysreg), a
028F: C9       [34]         ret
                        
                        ; void seg_writehex(uint8_t val)
                        ; - write the two hex digits of "val" to the 7-segment displays
0290:                   seg_writehex::
0290: E5       [11]         push    hl
0291: CDB802   [28]         call    seg1_writehex
0294: 7D       [32]         ld	    a, l
0295: 07       [36]         rlca
0296: 07       [40]         rlca
0297: 07       [44]         rlca
0298: 07       [48]         rlca
0299: 6F       [52]         ld	    l, a
029A: CD9F02   [69]         call    seg0_writehex
029D: E1       [79]         pop	    hl
029E: C9       [89]         ret
                        
                        ; void seg0_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
029F:                   seg0_writehex::
029F: E5       [11]         push    hl
02A0: C5       [22]         push    bc
02A1: 01D102   [32]         ld	    bc, HEX_table
02A4: 7D       [36]         ld	    a, l
02A5: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
02A7: 6F       [47]         ld	    l, a
02A8: 2600     [54]         ld	    h, 0
02AA: 09       [65]         add	    hl, bc  ; hl = HEX_table + (val & 0xF)
02AB: 3A0140   [78]         ld	    a, (Seg0_data)
02AE: E680     [85]         and	    SEG_DP
02B0: B6       [92]         or	    (hl)
02B1: 6F       [96]         ld	    l, a    ; l = (*Seg0_data & SEG_DP) | HEX_table[val & 0xF]
02B2: CD1403   [113]        call    seg0_write
02B5: C1       [123]        pop	    bc
02B6: E1       [133]        pop	    hl
02B7: C9       [143]        ret
                        
                        ; void seg1_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
02B8:                   seg1_writehex::
02B8: E5       [11]         push    hl
02B9: C5       [22]         push    bc
02BA: 01D102   [32]         ld	    bc, HEX_table
02BD: 7D       [36]         ld	    a, l
02BE: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
02C0: 6F       [47]         ld	    l, a
02C1: 2600     [54]         ld	    h, 0
02C3: 09       [65]         add	    hl, bc  ; hl = HEX_table + (val & 0xF)
02C4: 3A0240   [78]         ld	    a, (Seg1_data)
02C7: E680     [85]         and	    SEG_DP
02C9: B6       [92]         or	    (hl)
02CA: 6F       [96]         ld	    l, a    ; l = (*Seg1_data & SEG_DP) | HEX_table[val & 0xF]
02CB: CD1B03   [113]        call    seg1_write
02CE: C1       [123]        pop	    bc
02CF: E1       [133]        pop	    hl
02D0: C9       [143]        ret
                        
02D1:                   HEX_table::
                            ; 0
02D1: 3F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F
                            ; 1
02D2: 06                    .byte SEG_B | SEG_C
                            ; 2
02D3: 5B                    .byte SEG_A | SEG_B | SEG_G | SEG_E | SEG_D
                            ; 3
02D4: 4F                    .byte SEG_A | SEG_B | SEG_G | SEG_C | SEG_D
                            ; 4
02D5: 66                    .byte SEG_F | SEG_G | SEG_B | SEG_C
                            ; 5
02D6: 6D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D
                            ; 6
02D7: 7D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; 7
02D8: 07                    .byte SEG_A | SEG_B | SEG_C
                            ; 8
02D9: 7F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G
                            ; 9
02DA: 6F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_F | SEG_G
                            ; A
02DB: 77                    .byte SEG_A | SEG_B | SEG_C | SEG_E | SEG_F | SEG_G
                            ; b
02DC: 7C                    .byte SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; C
02DD: 39                    .byte SEG_A | SEG_D | SEG_E | SEG_F
                            ; d
02DE: 5E                    .byte SEG_B | SEG_C | SEG_D | SEG_E | SEG_G
                            ; E
02DF: 79                    .byte SEG_A | SEG_D | SEG_E | SEG_F | SEG_G
                            ; F
02E0: 71                    .byte SEG_A | SEG_E | SEG_F | SEG_G
                        
                        ; void seg0_fig8(uint8_t step)
                        ; - advance first 7-segment display to specified figure-8 step (0-7)
02E1:                   seg0_fig8::
02E1: E5       [11]         push    hl
02E2: C5       [22]         push    bc
02E3: 01F602   [32]         ld	    bc, FIG8_table
02E6: 2600     [39]         ld	    h, 0
02E8: 09       [50]         add	    hl, bc	; hl = FIG8_table + step
02E9: 3A0140   [63]         ld	    a, (Seg0_data)
02EC: E680     [70]         and	    SEG_DP
02EE: B6       [77]         or	    (hl)
02EF: 6F       [81]         ld	    l, a	; l = (*Seg0_data & SEG_DP) | FIG8_table[step]
02F0: CD1403   [98]         call    seg0_write
02F3: C1       [108]        pop	    bc
02F4: E1       [118]        pop	    hl
02F5: C9       [128]        ret
                        
02F6:                   FIG8_table::
02F6: 01024010              .byte SEG_A, SEG_B, SEG_G, SEG_E, SEG_D, SEG_C, SEG_G, SEG_F
02FA: 08044020          
                        
                        ; void seg0_toggle(uint8_t bits)
                        ; - toggle specified bits of first 7-segment display register
02FE:                   seg0_toggle::
02FE: E5       [11]         push    hl
02FF: 3A0140   [24]         ld	    a, (Seg0_data)
0302: AD       [28]         xor	    l
0303: 6F       [32]         ld	    l, a
0304: CD1403   [49]         call    seg0_write
0307: E1       [59]         pop	    hl
0308: C9       [69]         ret
                        
                        ; void seg1_toggle(uint8_t bits)
                        ; - toggle specified bits of second 7-segment display register
0309:                   seg1_toggle::
0309: E5       [11]         push    hl
030A: 3A0240   [24]         ld	    a, (Seg1_data)
030D: AD       [28]         xor	    l
030E: 6F       [32]         ld	    l, a
030F: CD1B03   [49]         call    seg1_write
0312: E1       [59]         pop	    hl
0313: C9       [69]         ret
                        
                        ; void seg0_write(uint8_t bits)
                        ; - write raw bits to first 7-segment display register
0314:                   seg0_write::
0314: 7D       [ 4]         ld	    a, l
0315: 320140   [17]         ld	    (Seg0_data), a
0318: D300     [28]         out	    (PORT_SEG0), a
031A: C9       [38]         ret
                        
                        ; void seg1_write(uint8_t bits)
                        ; - write raw bits to second 7-segment display register
031B:                   seg1_write::
031B: 7D       [ 4]         ld	    a, l
031C: 320240   [17]         ld	    (Seg1_data), a
031F: D310     [28]         out	    (PORT_SEG1), a
0321: C9       [38]         ret
                        
                        ; void delay_ms(uint8_t ms)
                        ; - delay for at least the specified number of milliseconds
                        #local
0322:                   delay_ms::
0322: 2C       [ 4]         inc	    l
0323: 2D       [ 8]         dec	    l
0324: C8       [13|19]      ret	    z		; delay of 0 returns immediately
0325: C5       [24]         push    bc
0326: 45       [28]         ld	    b, l
0327:                   loop:
0327: CD2E03   [17]         call    delay_1ms
032A: 10FB     [25|30]      djnz    loop
032C: C1       [35]         pop	    bc
032D: C9       [45]         ret
                        #endlocal
                        
                        ; void delay_1ms()
                        ; - delay for 1ms (technically, 0.9999ms)
                        #local
032E:                   delay_1ms::
032E: C5       [11]         push    bc		; 11 T-states
                        ; To delay 1ms, we want to wait 10,000 T-states (@10MHz)
                        ; The loop is (38*b + 13*(b-1) + 8) T-states long
                        ; Rearranging: 51*b - 5
                        ; Solve for b: b = (10000 + 5 / 51) = 196.17
032F: 06C3     [18]         ld	    b, 195	; 7 T-states
0331:                   loop:
0331: DD7E01   [19]         ld	    a, (ix+1)	; 19 T-states
0334: DD7E01   [38]         ld	    a, (ix+1)	; 19 T-states
0337: 10F8     [46|51]      djnz    loop	; (b-1)*13+8 T-states
0339: C1       [56]         pop	    bc		; 10 T-states
033A: 00       [60]         nop			; 4 T-states
033B: C9       [70]         ret			; 10 T-states
                        ; We also assume the routine is CALLed, for 17 T-states.
                        ; Total delay is therefore:
                        ;   17 + 11 + 7 + 51*195 - 5 + 10 + 4 + 10 = 9,999
                        #endlocal
                        
                        ; Remaining 48KB and 64KB segments to fill up ROM image
0000:                   #code FILLER1, 0, 0xC000
0000:                   #code FILLER2, 0, 0x10000


total time: 0.0134 sec.
no errors
