                        ; --------------------------------------
                        ; zasm: assemble "rom_ram_test.asm"
                        ; date: 2018-06-12 22:30:51
                        ; --------------------------------------


                        ; Calling convention used in this file
                        ; ------------------------------------
                        ;
                        ; Unless otherwise noted, the first parameter, and the return value are stored as follows:
                        ; 8 bits: L
                        ; 16 bits: HL
                        ; 32 bits: DEHL
                        ;
                        ; Additional parameters are passed on the stack, left-to-right.
                        ; Parameters and return values larger than 32 bits are passed on the stack (return value
                        ; space set up by caller as a hidden first argument).
                        ; Callee saves/restores any modified registers.
                        ; Caller pops arguments after call returns.
                        ; AF registers are scratch (caller preserves, if needed).
                        
                        ; same as 'bin', except that the default fill byte for 'defs' etc. is 0xff
                        #target rom
                        
                        #include "7segdisp.inc"
0000:                   PORT_SEG0	equ 0x00	    ; port address for first 7-segment display element
0010:                   PORT_SEG1	equ 0x10	    ; port address for second 7-segment display element
                        
                        ; 7-segment display map
                        ;      A
                        ;  +-------+
                        ;  |       |
                        ; F|       |B
                        ;  |   G   |
                        ;  +-------+
                        ;  |       |
                        ; E|       |C
                        ;  |   D   |
                        ;  +-------+  .DP
                        
                        ; These values are the bit masks.
0001:                   SEG_A		equ 0x01	; segment A
0002:                   SEG_B		equ 0x02	; segment B
0004:                   SEG_C		equ 0x04	; segment C
0008:                   SEG_D		equ 0x08	; segment D
0010:                   SEG_E		equ 0x10	; segment E
0020:                   SEG_F		equ 0x20	; segment F
0040:                   SEG_G		equ 0x40	; segment G
0080:                   SEG_DP		equ 0x80	; decimal point
                        
                        ; These are the bit numbers (useful for bit, set, and res instructions).
0000:                   SEG_IDX_A	equ 0
0001:                   SEG_IDX_B	equ 1
0002:                   SEG_IDX_C	equ 2
0003:                   SEG_IDX_D	equ 3
0004:                   SEG_IDX_E	equ 4
0005:                   SEG_IDX_F	equ 5
0006:                   SEG_IDX_G	equ 6
0007:                   SEG_IDX_DP	equ 7
                        #include "joystick.inc"
0000:                   PORT_JOY0	equ 0x00	    ; port address for first joystick (read-only)
0010:                   PORT_JOY1	equ 0x10	    ; port address for second joystick (read-only)
                        
                        ; Bit masks for the values in the joystick status register.
                        ; These bits are active-low (normally high).
0001:                   JOY_UP		equ 0x01
0002:                   JOY_DOWN	equ 0x02
0004:                   JOY_LEFT	equ 0x04
0008:                   JOY_RIGHT	equ 0x08
0010:                   JOY_FIRE	equ 0x10
0020:                   JOY_RESERVED1	equ 0x20
0040:                   JOY_RESERVED2	equ 0x40
0080:                   JOY_RESERVED3	equ 0x80
                        
                        ; The bit numbers (useful for bit, set, and res instructions).
0000:                   JOY_IDX_UP	equ 0
0001:                   JOY_IDX_DOWN	equ 1
0002:                   JOY_IDX_LEFT	equ 2
0003:                   JOY_IDX_RIGHT	equ 3
0004:                   JOY_IDX_FIRE	equ 4
                        #include "z84c20.inc"
                        ; The Z84C20 is the Z80's PIO peripheral. See um0081.pdf for documentation.
                        
0030:                   PORT_PIOBASE	equ 0x30		; base port address for PIO chip
0030:                   PORT_PIOADAT	equ PORT_PIOBASE	; port address for PIO port A, data register
0031:                   PORT_PIOBDAT	equ PORT_PIOBASE + 1    ; port address for PIO port B, data register
0032:                   PORT_PIOACTL	equ PORT_PIOBASE + 2    ; port address for PIO port A, control register
0033:                   PORT_PIOBCTL	equ PORT_PIOBASE + 3    ; port address for PIO port B, control register
                        
                        ; PIO Control Register commands
0000:                   PIOC_IVEC	equ 0x00	; OR in the high 7 bits of the interrupt vector
000F:                   PIOC_MODE	equ 0x0F	; OR in the desired PIOMODE_xxx setting
0007:                   PIOC_ICTL	equ 0x07	; OR in the desired PIOICTL_xxx settings
                        
                        ; PIOC_MODE values
0000:                   PIOMODE_OUTPUT	equ 0x00
0040:                   PIOMODE_INPUT	equ 0x40
0080:                   PIOMODE_BIDIREC	equ 0x80
00C0:                   PIOMODE_CONTROL	equ 0xC0	; next control byte written must be the IO direction byte
                        				; 1 = input, 0 = output
                        
                        ; PIOC_ICTL values
0080:                   PIOICTL_INTENA	equ 0x80	; enable interrupts
0000:                   PIOICTL_INTDIS	equ 0x00	; disable interrupts
0040:                   PIOICTL_AND	equ 0x40	; AND inputs together for port monitoring interrupt
0000:                   PIOICTL_OR	equ 0x00	; OR inputs together for port monitoring interrupt
0020:                   PIOICTL_HIGH	equ 0x20	; interrupt on high (1) inputs
0000:                   PIOICTL_LOW	equ 0x00	; interrupt on low (0) inputs
0010:                   PIOICTL_MASKNXT equ 0x10	; next control byte written must be the input interrupt mask
                        				; 1 = input masked, 0 = input enabled
                        
                        ; 128KB Static RAM - AS6C1008-55PCN
                        ; The first 8KB is shadowed by the EPROM.
                        ; The next 56KB is mapped from 0x2000-0xFFFF.
                        ; The top 64KB is not addressable (A16 tied low).
2000:                   #data RAM, 0x2000, 0xE000
                        ; define static variables here
2000: 00                Seg0_data:: defs 1	; current value of first 7-segment display byte
2001: 00                Seg1_data:: defs 1	; current value of second 7-segment display byte
                        
                        ; 128KB Flash ROM - SST39SF010A
                        ; The first 8KB is mapped from 0-0x1FFF.
0000:                   #code ROM, 0, 0x2000
                        
                        ; reset vector
0000:                   RST0::
0000: F3       [ 4]         di
0001: 31FFFF   [14]         ld	    sp, RAM_end-1
0004: C36800   [24]         jp	    init
0007: FF                    defs    0x08-$
                        
0008:                   RST1::
0008: ED4D     [14]         reti
000A: FFFFFFFF              defs    0x10-$
000E: FFFF              
                        
0010:                   RST2::
0010: ED4D     [14]         reti
0012: FFFFFFFF              defs    0x18-$
0016: FFFF              
                        
0018:                   RST3::
0018: ED4D     [14]         reti
001A: FFFFFFFF              defs    0x20-$
001E: FFFF              
                        
0020:                   RST4::
0020: ED4D     [14]         reti
0022: FFFFFFFF              defs    0x28-$
0026: FFFF              
                        
0028:                   RST5::
0028: ED4D     [14]         reti
002A: FFFFFFFF              defs    0x30-$
002E: FFFF              
                        
0030:                   RST6::
0030: ED4D     [14]         reti
0032: FFFFFFFF              defs    0x38-$
0036: FFFF              
                        
                        ; maskable interrupt handler in interrupt mode 1:
0038:                   RST7::
0038: ED4D     [14]         reti
                        
                        ; non maskable interrupt:
                        ; e.g. call debugger and on exit resume.
003A: FFFFFFFF              defs    0x66-$
003E: FF...             
0066:                   NMI::
0066: ED45     [14]         retn
                        
                        ; void init()
0068:                   init::
0068: 2E00     [ 7]         ld	    l, 0
006A: CDCA01   [24]         call    seg0_write
006D: CDD101   [41]         call    seg1_write
                        ;    call    figure8
                        ;    call    countup
                        ;    call    pio_test
0070: CDEE00   [58]         call    joy_test
0073: 18FE     [70]         jr	    $		; loop forever
                        
                        ; void countup()
                        #local
0075:                   countup::
0075: E5       [11]         push    hl
0076: 2600     [18]         ld	    h, 0	; counter in h
                        ; increment count every 500ms and toggle DP
0078:                   forever:
0078: 6C       [ 4]         ld	    l, h
0079: CD4601   [21]         call    seg_writehex    ; display counter
007C: 2E80     [28]         ld	    l, SEG_DP
007E: CDB401   [45]         call    seg0_toggle	    ; toggle DP
0081: 2EFA     [52]         ld	    l, 250
0083: CDD801   [69]         call    delay_ms	    ; delay 250ms
0086: CDD801   [86]         call    delay_ms	    ; delay 250ms
0089: 24       [90]         inc	    h
008A: 18EC     [102]        jr	    forever
008C: E1       [112]        pop	    hl
008D: C9       [122]        ret
                        #endlocal
                        
                        ; void figure8()
                        #local
008E:                   figure8::
008E: E5       [11]         push    hl
008F: C5       [22]         push    bc
                        ; step fig8 every 125ms; toggle DP every 1s
0090:                   forever:
0090: 0607     [ 7]         ld	    b, 7
0092:                   fig8_loop:
0092: 68       [ 4]         ld	    l, b
0093: CD9701   [21]         call    seg0_fig8
0096: 2E7D     [28]         ld	    l, 125
0098: CDD801   [45]         call    delay_ms
009B: 05       [49]         dec	    b
009C: F29200   [59|59]      jp	    p, fig8_loop
009F: 2E80     [66]         ld	    l, SEG_DP
00A1: CDB401   [83]         call    seg0_toggle
00A4: 18EA     [95]         jr	    forever
00A6: C1       [105]        pop	    bc
00A7: E1       [115]        pop	    hl
00A8: C9       [125]        ret
                        #endlocal
                        
                        ; void pio_test()
                        #local
00A9:                   pio_test::
00A9: E5       [11]         push    hl
00AA: C5       [22]         push    bc
                            ; configure PIO ports A and B
00AB: 013204   [32]         ld	    bc, 0x0400 | PORT_PIOACTL
00AE: 21DF00   [42]         ld	    hl, portA_cfg
00B1: EDB3     [58|21]      otir
00B3: 013303   [68]         ld	    bc, 0x0300 | PORT_PIOBCTL
                            ; HL already points to portB_cfg
00B6: EDB3     [84|21]      otir
00B8: CDE600   [101]        call    pio_srclr		; clear shift register at startup
00BB:                   forever:
00BB: 2E80     [ 7]         ld	    l, SEG_DP
00BD: CDBF01   [24]         call    seg1_toggle
00C0: DB30     [35]         in	    a, (PORT_PIOADAT)	; read PIO port A
00C2: 2F       [39]         cpl				; invert SRPRTY and SRSTRT signals
00C3: CB6F     [47]         bit	    5, a		; if SRSTRT is high, keep polling
00C5: 20F4     [54|59]      jr	    nz, forever
                            ; put SRPRTY onto segment 0's DP
00C7: E610     [61]         and	    0x10		; mask off other bits
00C9: 87       [65]         add	    a, a
00CA: 87       [69]         add	    a, a
00CB: 87       [73]         add	    a, a		; shift SRPRTY left 3 bits to bit 7 (SEG_DP)
00CC: 6F       [77]         ld	    l, a
00CD: CDCA01   [94]         call    seg0_write
                            ; read port B, displaying hex value after inverting
00D0: DB31     [105]        in	    a, (PORT_PIOBDAT)
00D2: 2F       [109]        cpl
00D3: 6F       [113]        ld	    l, a
00D4: CDE600   [130]        call    pio_srclr		; clear shift register to prepare for next byte
00D7: CD4601   [147]        call    seg_writehex
00DA: 18DF     [159]        jr	    forever
00DC: C1       [169]        pop	    bc
00DD: E1       [179]        pop	    hl
00DE: C9       [189]        ret
00DF:                   portA_cfg:
00DF: CF                    .byte PIOC_MODE | PIOMODE_CONTROL
00E0: F7                    .byte 0xF7	    ; A3 is an output (~SRCLR), everything else is an input
00E1: 37                    .byte PIOC_ICTL | PIOICTL_INTDIS | PIOICTL_OR | PIOICTL_HIGH | PIOICTL_MASKNXT
00E2: DF                    .byte 0xDF	    ; interrupt on A5 only (SRSTRT)
00E3:                   portB_cfg:
00E3: CF                    .byte PIOC_MODE | PIOMODE_CONTROL
00E4: FF                    .byte 0xFF	    ; everything is an input
00E5: 27                    .byte PIOC_ICTL | PIOICTL_INTDIS | PIOICTL_OR | PIOICTL_HIGH
                        #endlocal
                        
                        ; void pio_srclr()
                        ; - clear shift register by toggling ~SRCLR line, leaving it HIGH
                        #local
00E6:                   pio_srclr::
00E6: AF       [ 4]         xor	    a
00E7: D330     [15]         out	    (PORT_PIOADAT), a
00E9: 3E08     [22]         ld	    a, 0x08	; bit 3
00EB: D330     [33]         out	    (PORT_PIOADAT), a
00ED: C9       [43]         ret
                        #endlocal
                        
                        ; void joy_test()
                        #local
00EE:                   joy_test::
00EE: E5       [11]         push    hl
00EF:                   forever:
00EF: DB00     [11]         in	    a, (PORT_JOY0)	; read joystick 0
00F1: 6F       [15]         ld	    l, a
00F2: CD0501   [32]         call    joy_map2seg
00F5: CDCA01   [49]         call    seg0_write
00F8: DB10     [60]         in	    a, (PORT_JOY1)	; read joystick 1
00FA: 6F       [64]         ld	    l, a
00FB: CD0501   [81]         call    joy_map2seg
00FE: CDD101   [98]         call    seg1_write
0101: 18EC     [110]        jr	    forever
0103: E1       [120]        pop	    hl
0104: C9       [130]        ret
                        #endlocal
                        
                        ; uint8_t joy_map2seg(uint8_t joy)
                        ; - map the joystick status bits in "joy" to a value suitable for writing to the 7-segment display
                        #local
0105:                   joy_map2seg::
0105: AF       [ 4]         xor	    a			; start with no bits on 7-segment display
0106: CB45     [12]         bit	    JOY_IDX_UP, l	; test for UP
0108: 2002     [19|24]      jr	    nz, done_up
010A: CBC7     [27]         set	    SEG_IDX_A, a	; turn on top segment
010C:                   done_up:
010C: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; test for DOWN
010E: 2002     [15|20]      jr	    nz, done_down
0110: CBDF     [23]         set	    SEG_IDX_D, a	; turn on bottom segment
0112:                   done_down:
                            ; if neither UP nor DOWN are active, activate (clear) both to get both top & bottom side segments
0112: CB45     [ 8]         bit	    JOY_IDX_UP, l
0114: 2808     [15|20]      jr	    z, sides
0116: CB4D     [23]         bit	    JOY_IDX_DOWN, l
0118: 2804     [30|35]      jr	    z, sides
011A: CB85     [38]         res	    JOY_IDX_UP, l
011C: CB8D     [46]         res	    JOY_IDX_DOWN, l
011E:                   sides:
011E: CB55     [ 8]         bit	    JOY_IDX_LEFT, l	; test for LEFT
0120: 200C     [15|20]      jr	    nz, done_left
0122: CB45     [23]         bit	    JOY_IDX_UP, l	; if UP, set top-left segment
0124: 2002     [30|35]      jr	    nz, no_top_left
0126: CBEF     [38]         set	    SEG_IDX_F, a
0128:                   no_top_left:
0128: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; if DOWN, set bottom-left segment
012A: 2002     [15|20]      jr	    nz, done_left
012C: CBE7     [23]         set	    SEG_IDX_E, a
012E:                   done_left:
012E: CB5D     [ 8]         bit	    JOY_IDX_RIGHT, l	; test for RIGHT
0130: 200C     [15|20]      jr	    nz, done_right
0132: CB45     [23]         bit	    JOY_IDX_UP, l	; if UP, set top-right segment
0134: 2002     [30|35]      jr	    nz, no_top_right
0136: CBCF     [38]         set	    SEG_IDX_B, a
0138:                   no_top_right:
0138: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; if DOWN, set bottom-right segment
013A: 2002     [15|20]      jr	    nz, done_right
013C: CBD7     [23]         set	    SEG_IDX_C, a
013E:                   done_right:
013E: CB65     [ 8]         bit	    JOY_IDX_FIRE, l	; test for FIRE
0140: 2002     [15|20]      jr	    nz, done_fire
0142: CBFF     [23]         set	    SEG_IDX_DP, a
0144:                   done_fire:
0144: 6F       [ 4]         ld	    l, a		; return segment mask
0145: C9       [14]         ret
                        #endlocal
                        
                        ; Library routines
                        ; ----------------
                        
                        ; void seg_writehex(uint8_t val)
                        ; - write the two hex digits of "val" to the 7-segment displays
0146:                   seg_writehex::
0146: E5       [11]         push    hl
0147: CD6E01   [28]         call    seg1_writehex
014A: 7D       [32]         ld	    a, l
014B: 07       [36]         rlca
014C: 07       [40]         rlca
014D: 07       [44]         rlca
014E: 07       [48]         rlca
014F: 6F       [52]         ld	    l, a
0150: CD5501   [69]         call    seg0_writehex
0153: E1       [79]         pop	    hl
0154: C9       [89]         ret
                        
                        ; void seg0_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
0155:                   seg0_writehex::
0155: E5       [11]         push    hl
0156: C5       [22]         push    bc
0157: 018701   [32]         ld	    bc, HEX_table
015A: 7D       [36]         ld	    a, l
015B: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
015D: 6F       [47]         ld	    l, a
015E: 2600     [54]         ld	    h, 0
0160: 09       [65]         add	    hl, bc  ; hl = HEX_table + (val & 0xF)
0161: 3A0020   [78]         ld	    a, (Seg0_data)
0164: E680     [85]         and	    SEG_DP
0166: B6       [92]         or	    (hl)
0167: 6F       [96]         ld	    l, a    ; l = (*Seg0_data & SEG_DP) | HEX_table[val & 0xF]
0168: CDCA01   [113]        call    seg0_write
016B: C1       [123]        pop	    bc
016C: E1       [133]        pop	    hl
016D: C9       [143]        ret
                        
                        ; void seg1_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
016E:                   seg1_writehex::
016E: E5       [11]         push    hl
016F: C5       [22]         push    bc
0170: 018701   [32]         ld	    bc, HEX_table
0173: 7D       [36]         ld	    a, l
0174: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
0176: 6F       [47]         ld	    l, a
0177: 2600     [54]         ld	    h, 0
0179: 09       [65]         add	    hl, bc  ; hl = HEX_table + (val & 0xF)
017A: 3A0120   [78]         ld	    a, (Seg1_data)
017D: E680     [85]         and	    SEG_DP
017F: B6       [92]         or	    (hl)
0180: 6F       [96]         ld	    l, a    ; l = (*Seg1_data & SEG_DP) | HEX_table[val & 0xF]
0181: CDD101   [113]        call    seg1_write
0184: C1       [123]        pop	    bc
0185: E1       [133]        pop	    hl
0186: C9       [143]        ret
                        
0187:                   HEX_table::
                            ; 0
0187: 3F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F
                            ; 1
0188: 06                    .byte SEG_B | SEG_C
                            ; 2
0189: 5B                    .byte SEG_A | SEG_B | SEG_G | SEG_E | SEG_D
                            ; 3
018A: 4F                    .byte SEG_A | SEG_B | SEG_G | SEG_C | SEG_D
                            ; 4
018B: 66                    .byte SEG_F | SEG_G | SEG_B | SEG_C
                            ; 5
018C: 6D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D
                            ; 6
018D: 7D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; 7
018E: 07                    .byte SEG_A | SEG_B | SEG_C
                            ; 8
018F: 7F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G
                            ; 9
0190: 6F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_F | SEG_G
                            ; A
0191: 77                    .byte SEG_A | SEG_B | SEG_C | SEG_E | SEG_F | SEG_G
                            ; b
0192: 7C                    .byte SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; C
0193: 39                    .byte SEG_A | SEG_D | SEG_E | SEG_F
                            ; d
0194: 5E                    .byte SEG_B | SEG_C | SEG_D | SEG_E | SEG_G
                            ; E
0195: 79                    .byte SEG_A | SEG_D | SEG_E | SEG_F | SEG_G
                            ; F
0196: 71                    .byte SEG_A | SEG_E | SEG_F | SEG_G
                        
                        ; void seg0_fig8(uint8_t step)
                        ; - advance first 7-segment display to specified figure-8 step (0-7)
0197:                   seg0_fig8::
0197: E5       [11]         push    hl
0198: C5       [22]         push    bc
0199: 01AC01   [32]         ld	    bc, FIG8_table
019C: 2600     [39]         ld	    h, 0
019E: 09       [50]         add	    hl, bc	; hl = FIG8_table + step
019F: 3A0020   [63]         ld	    a, (Seg0_data)
01A2: E680     [70]         and	    SEG_DP
01A4: B6       [77]         or	    (hl)
01A5: 6F       [81]         ld	    l, a	; l = (*Seg0_data & SEG_DP) | FIG8_table[step]
01A6: CDCA01   [98]         call    seg0_write
01A9: C1       [108]        pop	    bc
01AA: E1       [118]        pop	    hl
01AB: C9       [128]        ret
                        
01AC:                   FIG8_table::
01AC: 01024010              .byte SEG_A, SEG_B, SEG_G, SEG_E, SEG_D, SEG_C, SEG_G, SEG_F
01B0: 08044020          
                        
                        ; void seg0_toggle(uint8_t bits)
                        ; - toggle specified bits of first 7-segment display register
01B4:                   seg0_toggle::
01B4: E5       [11]         push    hl
01B5: 3A0020   [24]         ld	    a, (Seg0_data)
01B8: AD       [28]         xor	    l
01B9: 6F       [32]         ld	    l, a
01BA: CDCA01   [49]         call    seg0_write
01BD: E1       [59]         pop	    hl
01BE: C9       [69]         ret
                        
                        ; void seg1_toggle(uint8_t bits)
                        ; - toggle specified bits of second 7-segment display register
01BF:                   seg1_toggle::
01BF: E5       [11]         push    hl
01C0: 3A0120   [24]         ld	    a, (Seg1_data)
01C3: AD       [28]         xor	    l
01C4: 6F       [32]         ld	    l, a
01C5: CDD101   [49]         call    seg1_write
01C8: E1       [59]         pop	    hl
01C9: C9       [69]         ret
                        
                        ; void seg0_write(uint8_t bits)
                        ; - write raw bits to first 7-segment display register
01CA:                   seg0_write::
01CA: 7D       [ 4]         ld	    a, l
01CB: 320020   [17]         ld	    (Seg0_data), a
01CE: D300     [28]         out	    (PORT_SEG0), a
01D0: C9       [38]         ret
                        
                        ; void seg1_write(uint8_t bits)
                        ; - write raw bits to second 7-segment display register
01D1:                   seg1_write::
01D1: 7D       [ 4]         ld	    a, l
01D2: 320120   [17]         ld	    (Seg1_data), a
01D5: D310     [28]         out	    (PORT_SEG1), a
01D7: C9       [38]         ret
                        
                        ; void delay_ms(uint8_t ms)
                        ; - delay for at least the specified number of milliseconds
                        #local
01D8:                   delay_ms::
01D8: 2C       [ 4]         inc	    l
01D9: 2D       [ 8]         dec	    l
01DA: C8       [13|19]      ret	    z		; delay of 0 returns immediately
01DB: C5       [24]         push    bc
01DC: 45       [28]         ld	    b, l
01DD:                   loop:
01DD: CDE401   [17]         call    delay_1ms
01E0: 10FB     [25|30]      djnz    loop
01E2: C1       [35]         pop	    bc
01E3: C9       [45]         ret
                        #endlocal
                        
                        ; void delay_1ms()
                        ; - delay for 1ms (technically, 0.9999ms)
                        #local
01E4:                   delay_1ms::
01E4: C5       [11]         push    bc		; 11 T-states
                        ; To delay 1ms, we want to wait 10,000 T-states (@10MHz)
                        ; The loop is (38*b + 13*(b-1) + 8) T-states long
                        ; Rearranging: 51*b - 5
                        ; Solve for b: b = (10000 + 5 / 51) = 196.17
01E5: 06C3     [18]         ld	    b, 195	; 7 T-states
01E7:                   loop:
01E7: E3       [19]         ex	    (sp), hl	; 19 T-states
01E8: E3       [38]         ex	    (sp), hl	; 19 T-states
01E9: 10FC     [46|51]      djnz    loop	; (b-1)*13+8 T-states
01EB: C1       [56]         pop	    bc		; 10 T-states
01EC: 00       [60]         nop			; 4 T-states
01ED: C9       [70]         ret			; 10 T-states
                        ; We also assume the routine is CALLed, for 17 T-states.
                        ; Total delay is therefore:
                        ;   17 + 11 + 7 + 51*195 - 5 + 10 + 4 + 10 = 9,999
                        #endlocal
                        
                        ; Remaining 56KB and 64KB segments to fill up ROM image
0000:                   #code FILLER1, 0, 0xE000
0000:                   #code FILLER2, 0, 0x10000


total time: 0.0107 sec.
no errors
