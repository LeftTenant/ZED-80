                        ; --------------------------------------
                        ; zasm: assemble "rom_ram_test.asm"
                        ; date: 2018-06-13 21:46:08
                        ; --------------------------------------


                        ; Calling convention used in this file
                        ; ------------------------------------
                        ;
                        ; Unless otherwise noted, the first parameter, and the return value are stored as follows:
                        ; 8 bits: L
                        ; 16 bits: HL
                        ; 32 bits: DEHL
                        ;
                        ; Additional parameters are passed on the stack, left-to-right.
                        ; Parameters and return values larger than 32 bits are passed on the stack (return value
                        ; space set up by caller as a hidden first argument).
                        ; Callee saves/restores any modified registers.
                        ; Caller pops arguments after call returns.
                        ; AF registers are scratch (caller preserves, if needed).
                        
                        ; same as 'bin', except that the default fill byte for 'defs' etc. is 0xff
                        #target rom
                        
                        #include "7segdisp.inc"
0000:                   PORT_SEG0	equ 0x00	    ; port address for first 7-segment display element
0010:                   PORT_SEG1	equ 0x10	    ; port address for second 7-segment display element
                        
                        ; 7-segment display map
                        ;      A
                        ;  +-------+
                        ;  |       |
                        ; F|       |B
                        ;  |   G   |
                        ;  +-------+
                        ;  |       |
                        ; E|       |C
                        ;  |   D   |
                        ;  +-------+  .DP
                        
                        ; These values are the bit masks.
0001:                   SEG_A		equ 0x01	; segment A
0002:                   SEG_B		equ 0x02	; segment B
0004:                   SEG_C		equ 0x04	; segment C
0008:                   SEG_D		equ 0x08	; segment D
0010:                   SEG_E		equ 0x10	; segment E
0020:                   SEG_F		equ 0x20	; segment F
0040:                   SEG_G		equ 0x40	; segment G
0080:                   SEG_DP		equ 0x80	; decimal point
                        
                        ; These are the bit numbers (useful for bit, set, and res instructions).
0000:                   SEG_IDX_A	equ 0
0001:                   SEG_IDX_B	equ 1
0002:                   SEG_IDX_C	equ 2
0003:                   SEG_IDX_D	equ 3
0004:                   SEG_IDX_E	equ 4
0005:                   SEG_IDX_F	equ 5
0006:                   SEG_IDX_G	equ 6
0007:                   SEG_IDX_DP	equ 7
                        #include "joystick.inc"
0000:                   PORT_JOY0	equ 0x00	    ; port address for first joystick (read-only)
0010:                   PORT_JOY1	equ 0x10	    ; port address for second joystick (read-only)
                        
                        ; Bit masks for the values in the joystick status register.
                        ; These bits are active-low (normally high).
0001:                   JOY_UP		equ 0x01
0002:                   JOY_DOWN	equ 0x02
0004:                   JOY_LEFT	equ 0x04
0008:                   JOY_RIGHT	equ 0x08
0010:                   JOY_FIRE	equ 0x10
0020:                   JOY_RESERVED1	equ 0x20
0040:                   JOY_RESERVED2	equ 0x40
0080:                   JOY_RESERVED3	equ 0x80
                        
                        ; The bit numbers (useful for bit, set, and res instructions).
0000:                   JOY_IDX_UP	equ 0
0001:                   JOY_IDX_DOWN	equ 1
0002:                   JOY_IDX_LEFT	equ 2
0003:                   JOY_IDX_RIGHT	equ 3
0004:                   JOY_IDX_FIRE	equ 4
                        #include "z84c20.inc"
                        ; The Z84C20 is the Z80's PIO peripheral. See um0081.pdf for documentation.
                        
0030:                   PORT_PIOBASE	equ 0x30		; base port address for PIO chip
0030:                   PORT_PIOADAT	equ PORT_PIOBASE	; port address for PIO port A, data register
0031:                   PORT_PIOBDAT	equ PORT_PIOBASE + 1    ; port address for PIO port B, data register
0032:                   PORT_PIOACTL	equ PORT_PIOBASE + 2    ; port address for PIO port A, control register
0033:                   PORT_PIOBCTL	equ PORT_PIOBASE + 3    ; port address for PIO port B, control register
                        
                        ; PIO Control Register commands
0000:                   PIOC_IVEC	equ 0x00	; OR in the high 7 bits of the interrupt vector
000F:                   PIOC_MODE	equ 0x0F	; OR in the desired PIOMODE_xxx setting
0007:                   PIOC_ICTL	equ 0x07	; OR in the desired PIOICTL_xxx settings
                        
                        ; PIOC_MODE values
0000:                   PIOMODE_OUTPUT	equ 0x00
0040:                   PIOMODE_INPUT	equ 0x40
0080:                   PIOMODE_BIDIREC	equ 0x80
00C0:                   PIOMODE_CONTROL	equ 0xC0	; next control byte written must be the IO direction byte
                        				; 1 = input, 0 = output
                        
                        ; PIOC_ICTL values
0080:                   PIOICTL_INTENA	equ 0x80	; enable interrupts
0000:                   PIOICTL_INTDIS	equ 0x00	; disable interrupts
0040:                   PIOICTL_AND	equ 0x40	; AND inputs together for port monitoring interrupt
0000:                   PIOICTL_OR	equ 0x00	; OR inputs together for port monitoring interrupt
0020:                   PIOICTL_HIGH	equ 0x20	; interrupt on high (1) inputs
0000:                   PIOICTL_LOW	equ 0x00	; interrupt on low (0) inputs
0010:                   PIOICTL_MASKNXT equ 0x10	; next control byte written must be the input interrupt mask
                        				; 1 = input masked, 0 = input enabled
                        #include "z84c30.inc"
                        ; The Z84C30 is the Z80's CTC peripheral. See um0081.pdf for documentation.
                        
0040:                   PORT_CTCBASE	equ 0x40		; base port address for CTC chip
0040:                   PORT_CTCIVEC	equ PORT_CTCBASE	; port address for Interrupt Vector Register
0040:                   PORT_CTC0	equ PORT_CTCBASE	; port address for CTC channel 0
0041:                   PORT_CTC1	equ PORT_CTCBASE + 1	; port address for CTC channel 1
0042:                   PORT_CTC2	equ PORT_CTCBASE + 2	; port address for CTC channel 2
0043:                   PORT_CTC3	equ PORT_CTCBASE + 3	; port address for CTC channel 3
                        
                        ; CTC Channel Control Word bits
0080:                   CTC_INTENA	equ 0x80		; enable interrupts
0000:                   CTC_INTDIS	equ 0x00		; disable interrupts
0040:                   CTC_MODECTR	equ 0x40		; COUNTER mode
0000:                   CTC_MODETMR	equ 0x00		; TIMER mode
0020:                   CTC_SCALE256	equ 0x20		; prescale by 256
0000:                   CTC_SCALE16	equ 0x00		; prescale by 16
0010:                   CTC_RISING	equ 0x10		; CLK/TRG on rising edges
0000:                   CTC_FALLING	equ 0x00		; CLK/TRG on falling edges
0008:                   CTC_CLKTRG	equ 0x08		; CLK/TRG pulse starts timer
0000:                   CTC_AUTO	equ 0x00		; automatic timer start after loading time constant
0004:                   CTC_TIMENXT	equ 0x04		; next control byte written is the time constant
0002:                   CTC_RESET	equ 0x02		; software reset
0001:                   CTC_CONTROL	equ 0x01		; always set to indicate this is a control word, not IVEC 
                        
                        ; 128KB Static RAM - AS6C1008-55PCN
                        ; The first 8KB is shadowed by the EPROM.
                        ; The next 56KB is mapped from 0x2000-0xFFFF.
                        ; The top 64KB is not addressable (A16 tied low).
2000:                   #data RAM, 0x2000, 0xE000
                        ; define static variables here
2000: 00                Seg0_data:: defs 1	; current value of first 7-segment display byte
2001: 00                Seg1_data:: defs 1	; current value of second 7-segment display byte
                        
                        ; 128KB Flash ROM - SST39SF010A
                        ; The first 8KB is mapped from 0-0x1FFF.
0000:                   #code ROM, 0, 0x2000
                        
                        ; reset vector
0000:                   RST0::
0000: F3       [ 4]         di
0001: 31FFFF   [14]         ld	    sp, RAM_end-1
0004: C38800   [24]         jp	    init
0007: FF                    defs    0x08-$
                        
0008:                   RST1::
0008: ED4D     [14]         reti
000A: FFFFFFFF              defs    0x10-$
000E: FFFF              
                        
0010:                   RST2::
0010: ED4D     [14]         reti
0012: FFFFFFFF              defs    0x18-$
0016: FFFF              
                        
0018:                   RST3::
0018: ED4D     [14]         reti
001A: FFFFFFFF              defs    0x20-$
001E: FFFF              
                        
0020:                   RST4::
0020: ED4D     [14]         reti
0022: FFFFFFFF              defs    0x28-$
0026: FFFF              
                        
0028:                   RST5::
0028: ED4D     [14]         reti
002A: FFFFFFFF              defs    0x30-$
002E: FFFF              
                        
0030:                   RST6::
0030: ED4D     [14]         reti
0032: FFFFFFFF              defs    0x38-$
0036: FFFF              
                        
                        ; maskable interrupt handler in interrupt mode 1:
0038:                   RST7::
0038: ED4D     [14]         reti
                        
                        ; non maskable interrupt:
                        ; e.g. call debugger and on exit resume.
003A: FFFFFFFF              defs    0x66-$
003E: FF...             
0066:                   NMI::
0066: ED45     [14]         retn
                        
                        ; Empty ISR for interrupts we want to ignore
0068:                   ISR_nop::
0068: FB       [ 4]         ei
0069: ED4D     [18]         reti
                        
006B: FFFFFFFF              defs    0x80-$
006F: FF...             
                        ; Interrupt Vector Table
0080:                   IVT::
                        ; Table starts at 0x0080
                        ; CTC has first 4 slots, so CTC Interrupt Vector register should be 0x80
0080: 6800                  .word   ISR_nop	    ; CTC channel 0
0082: 6800                  .word   ISR_nop	    ; CTC channel 1
0084: 6800                  .word   ISR_nop	    ; CTC channel 2
0086: 3D01                  .word   ISR_ctc3	    ; CTC channel 3
                        ; TODO: ISRs for PIO & SIO
                        
                        ; void init()
0088:                   init::
                            ; set up interrupts
0088: 3E00     [ 7]         ld	    a, hi(IVT)
008A: ED47     [16]         ld	    i, a	    ; I gets high byte of IVT address
008C: ED5E     [24]         im	    2		    ; select interrupt mode 2
008E: FB       [28]         ei
                            ; clear 7-segment display
008F: 2E00     [35]         ld	    l, 0
0091: CD1C02   [52]         call    seg0_write
0094: CD2302   [69]         call    seg1_write
0097: CD1801   [86]         call    ctc_test
                        ;    call    figure8
                        ;    call    countup
                        ;    call    pio_test
009A: CD4901   [103]        call    joy_test
009D: 18FE     [115]        jr	    $		; loop forever
                        
                        ; void countup()
                        #local
009F:                   countup::
009F: E5       [11]         push    hl
00A0: 2600     [18]         ld	    h, 0	; counter in h
                        ; increment count every 500ms and toggle DP
00A2:                   forever:
00A2: 6C       [ 4]         ld	    l, h
00A3: CD9801   [21]         call    seg_writehex    ; display counter
00A6: 2E80     [28]         ld	    l, SEG_DP
00A8: CD0602   [45]         call    seg0_toggle	    ; toggle DP
00AB: 2EFA     [52]         ld	    l, 250
00AD: CD2A02   [69]         call    delay_ms	    ; delay 250ms
00B0: CD2A02   [86]         call    delay_ms	    ; delay 250ms
00B3: 24       [90]         inc	    h
00B4: 18EC     [102]        jr	    forever
00B6: E1       [112]        pop	    hl
00B7: C9       [122]        ret
                        #endlocal
                        
                        ; void figure8()
                        #local
00B8:                   figure8::
00B8: E5       [11]         push    hl
00B9: C5       [22]         push    bc
                        ; step fig8 every 125ms; toggle DP every 1s
00BA:                   forever:
00BA: 0607     [ 7]         ld	    b, 7
00BC:                   fig8_loop:
00BC: 68       [ 4]         ld	    l, b
00BD: CDE901   [21]         call    seg0_fig8
00C0: 2E7D     [28]         ld	    l, 125
00C2: CD2A02   [45]         call    delay_ms
00C5: 05       [49]         dec	    b
00C6: F2BC00   [59|59]      jp	    p, fig8_loop
00C9: 2E80     [66]         ld	    l, SEG_DP
00CB: CD0602   [83]         call    seg0_toggle
00CE: 18EA     [95]         jr	    forever
00D0: C1       [105]        pop	    bc
00D1: E1       [115]        pop	    hl
00D2: C9       [125]        ret
                        #endlocal
                        
                        ; void pio_test()
                        #local
00D3:                   pio_test::
00D3: E5       [11]         push    hl
00D4: C5       [22]         push    bc
                            ; configure PIO ports A and B
00D5: 013204   [32]         ld	    bc, 0x0400 | PORT_PIOACTL
00D8: 210901   [42]         ld	    hl, portA_cfg
00DB: EDB3     [58|21]      otir
00DD: 013303   [68]         ld	    bc, 0x0300 | PORT_PIOBCTL
                            ; HL already points to portB_cfg
00E0: EDB3     [84|21]      otir
00E2: CD1001   [101]        call    pio_srclr		; clear shift register at startup
00E5:                   forever:
00E5: 2E80     [ 7]         ld	    l, SEG_DP
00E7: CD1102   [24]         call    seg1_toggle
00EA: DB30     [35]         in	    a, (PORT_PIOADAT)	; read PIO port A
00EC: 2F       [39]         cpl				; invert SRPRTY and SRSTRT signals
00ED: CB6F     [47]         bit	    5, a		; if SRSTRT is high, keep polling
00EF: 20F4     [54|59]      jr	    nz, forever
                            ; put SRPRTY onto segment 0's DP
00F1: E610     [61]         and	    0x10		; mask off other bits
00F3: 87       [65]         add	    a, a
00F4: 87       [69]         add	    a, a
00F5: 87       [73]         add	    a, a		; shift SRPRTY left 3 bits to bit 7 (SEG_DP)
00F6: 6F       [77]         ld	    l, a
00F7: CD1C02   [94]         call    seg0_write
                            ; read port B, displaying hex value after inverting
00FA: DB31     [105]        in	    a, (PORT_PIOBDAT)
00FC: 2F       [109]        cpl
00FD: 6F       [113]        ld	    l, a
00FE: CD1001   [130]        call    pio_srclr		; clear shift register to prepare for next byte
0101: CD9801   [147]        call    seg_writehex
0104: 18DF     [159]        jr	    forever
0106: C1       [169]        pop	    bc
0107: E1       [179]        pop	    hl
0108: C9       [189]        ret
0109:                   portA_cfg:
0109: CF                    .byte PIOC_MODE | PIOMODE_CONTROL
010A: F7                    .byte 0xF7	    ; A3 is an output (~SRCLR), everything else is an input
010B: 37                    .byte PIOC_ICTL | PIOICTL_INTDIS | PIOICTL_OR | PIOICTL_HIGH | PIOICTL_MASKNXT
010C: DF                    .byte 0xDF	    ; interrupt on A5 only (SRSTRT)
010D:                   portB_cfg:
010D: CF                    .byte PIOC_MODE | PIOMODE_CONTROL
010E: FF                    .byte 0xFF	    ; everything is an input
010F: 27                    .byte PIOC_ICTL | PIOICTL_INTDIS | PIOICTL_OR | PIOICTL_HIGH
                        #endlocal
                        
                        ; void pio_srclr()
                        ; - clear shift register by toggling ~SRCLR line, leaving it HIGH
                        #local
0110:                   pio_srclr::
0110: AF       [ 4]         xor	    a
0111: D330     [15]         out	    (PORT_PIOADAT), a
0113: 3E08     [22]         ld	    a, 0x08	; bit 3
0115: D330     [33]         out	    (PORT_PIOADAT), a
0117: C9       [43]         ret
                        #endlocal
                        
                        ; void ctc_test()
                        #local
0118:                   ctc_test::
                            ; load CTC Interrupt Vector Register
0118: 3E80     [ 7]         ld	    a, lo(IVT)	    ; CTC interrupt vectors are the first 4 in the IVT
011A: D340     [18]         out	    (PORT_CTCIVEC), a
                            ; channel 0 is the baud rate generator for serial 0
011C: 3E57     [25]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
011E: D340     [36]         out	    (PORT_CTC0), a
0120: 3E03     [43]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x64 gives 9600 baud)
0122: D340     [54]         out	    (PORT_CTC0), a
                            ; channel 1 is the baud rate generator for serial 1
0124: 3E57     [61]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
0126: D341     [72]         out	    (PORT_CTC1), a
0128: 3E03     [79]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x64 gives 9600 baud)
012A: D341     [90]         out	    (PORT_CTC1), a
                            ; channel 2 is used as a timer to divide down the system clock for channel 3
012C: 3E17     [97]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_AUTO | CTC_RISING | CTC_SCALE16 | CTC_MODETMR
012E: D342     [108]        out	    (PORT_CTC2), a
0130: 3EFA     [115]        ld	    a, 250	    ; 10MHz prescale by 16, divide by 250 is 2.5kHz
0132: D342     [126]        out	    (PORT_CTC2), a
                            ; channel 3 is used as a counter on the 2.5kHz signal from channel 2
0134: 3ED7     [133]        ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR | CTC_INTENA
0136: D343     [144]        out	    (PORT_CTC3), a
0138: 3EFA     [151]        ld	    a, 250	    ; 2.5kHz divided by 250 is 10Hz
013A: D343     [162]        out	    (PORT_CTC3), a
013C: C9       [172]        ret
                        #endlocal
                        
                        ; CTC channel 3 ISR
013D:                   ISR_ctc3::
013D: 08       [ 4]         ex	    af, af'
013E: D9       [ 8]         exx
013F: 2E80     [15]         ld	    l, SEG_DP
0141: CD1102   [32]         call    seg1_toggle
0144: D9       [36]         exx
0145: 08       [40]         ex	    af, af'
0146: FB       [44]         ei
0147: ED4D     [58]         reti
                        
                        ; void joy_test()
                        #local
0149:                   joy_test::
0149: E5       [11]         push    hl
014A:                   forever:
014A: DB00     [11]         in	    a, (PORT_JOY0)	; read joystick 0
014C: 6F       [15]         ld	    l, a
014D: CD5701   [32]         call    joy_map2seg
0150: CD1C02   [49]         call    seg0_write
                        ;    in	    a, (PORT_JOY1)	; read joystick 1
                        ;    ld	    l, a
                        ;    call    joy_map2seg
                        ;    call    seg1_write
0153: 18F5     [61]         jr	    forever
0155: E1       [71]         pop	    hl
0156: C9       [81]         ret
                        #endlocal
                        
                        ; uint8_t joy_map2seg(uint8_t joy)
                        ; - map the joystick status bits in "joy" to a value suitable for writing to the 7-segment display
                        #local
0157:                   joy_map2seg::
0157: AF       [ 4]         xor	    a			; start with no bits on 7-segment display
0158: CB45     [12]         bit	    JOY_IDX_UP, l	; test for UP
015A: 2002     [19|24]      jr	    nz, done_up
015C: CBC7     [27]         set	    SEG_IDX_A, a	; turn on top segment
015E:                   done_up:
015E: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; test for DOWN
0160: 2002     [15|20]      jr	    nz, done_down
0162: CBDF     [23]         set	    SEG_IDX_D, a	; turn on bottom segment
0164:                   done_down:
                            ; if neither UP nor DOWN are active, activate (clear) both to get both top & bottom side segments
0164: CB45     [ 8]         bit	    JOY_IDX_UP, l
0166: 2808     [15|20]      jr	    z, sides
0168: CB4D     [23]         bit	    JOY_IDX_DOWN, l
016A: 2804     [30|35]      jr	    z, sides
016C: CB85     [38]         res	    JOY_IDX_UP, l
016E: CB8D     [46]         res	    JOY_IDX_DOWN, l
0170:                   sides:
0170: CB55     [ 8]         bit	    JOY_IDX_LEFT, l	; test for LEFT
0172: 200C     [15|20]      jr	    nz, done_left
0174: CB45     [23]         bit	    JOY_IDX_UP, l	; if UP, set top-left segment
0176: 2002     [30|35]      jr	    nz, no_top_left
0178: CBEF     [38]         set	    SEG_IDX_F, a
017A:                   no_top_left:
017A: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; if DOWN, set bottom-left segment
017C: 2002     [15|20]      jr	    nz, done_left
017E: CBE7     [23]         set	    SEG_IDX_E, a
0180:                   done_left:
0180: CB5D     [ 8]         bit	    JOY_IDX_RIGHT, l	; test for RIGHT
0182: 200C     [15|20]      jr	    nz, done_right
0184: CB45     [23]         bit	    JOY_IDX_UP, l	; if UP, set top-right segment
0186: 2002     [30|35]      jr	    nz, no_top_right
0188: CBCF     [38]         set	    SEG_IDX_B, a
018A:                   no_top_right:
018A: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; if DOWN, set bottom-right segment
018C: 2002     [15|20]      jr	    nz, done_right
018E: CBD7     [23]         set	    SEG_IDX_C, a
0190:                   done_right:
0190: CB65     [ 8]         bit	    JOY_IDX_FIRE, l	; test for FIRE
0192: 2002     [15|20]      jr	    nz, done_fire
0194: CBFF     [23]         set	    SEG_IDX_DP, a
0196:                   done_fire:
0196: 6F       [ 4]         ld	    l, a		; return segment mask
0197: C9       [14]         ret
                        #endlocal
                        
                        ; Library routines
                        ; ----------------
                        
                        ; void seg_writehex(uint8_t val)
                        ; - write the two hex digits of "val" to the 7-segment displays
0198:                   seg_writehex::
0198: E5       [11]         push    hl
0199: CDC001   [28]         call    seg1_writehex
019C: 7D       [32]         ld	    a, l
019D: 07       [36]         rlca
019E: 07       [40]         rlca
019F: 07       [44]         rlca
01A0: 07       [48]         rlca
01A1: 6F       [52]         ld	    l, a
01A2: CDA701   [69]         call    seg0_writehex
01A5: E1       [79]         pop	    hl
01A6: C9       [89]         ret
                        
                        ; void seg0_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
01A7:                   seg0_writehex::
01A7: E5       [11]         push    hl
01A8: C5       [22]         push    bc
01A9: 01D901   [32]         ld	    bc, HEX_table
01AC: 7D       [36]         ld	    a, l
01AD: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
01AF: 6F       [47]         ld	    l, a
01B0: 2600     [54]         ld	    h, 0
01B2: 09       [65]         add	    hl, bc  ; hl = HEX_table + (val & 0xF)
01B3: 3A0020   [78]         ld	    a, (Seg0_data)
01B6: E680     [85]         and	    SEG_DP
01B8: B6       [92]         or	    (hl)
01B9: 6F       [96]         ld	    l, a    ; l = (*Seg0_data & SEG_DP) | HEX_table[val & 0xF]
01BA: CD1C02   [113]        call    seg0_write
01BD: C1       [123]        pop	    bc
01BE: E1       [133]        pop	    hl
01BF: C9       [143]        ret
                        
                        ; void seg1_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
01C0:                   seg1_writehex::
01C0: E5       [11]         push    hl
01C1: C5       [22]         push    bc
01C2: 01D901   [32]         ld	    bc, HEX_table
01C5: 7D       [36]         ld	    a, l
01C6: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
01C8: 6F       [47]         ld	    l, a
01C9: 2600     [54]         ld	    h, 0
01CB: 09       [65]         add	    hl, bc  ; hl = HEX_table + (val & 0xF)
01CC: 3A0120   [78]         ld	    a, (Seg1_data)
01CF: E680     [85]         and	    SEG_DP
01D1: B6       [92]         or	    (hl)
01D2: 6F       [96]         ld	    l, a    ; l = (*Seg1_data & SEG_DP) | HEX_table[val & 0xF]
01D3: CD2302   [113]        call    seg1_write
01D6: C1       [123]        pop	    bc
01D7: E1       [133]        pop	    hl
01D8: C9       [143]        ret
                        
01D9:                   HEX_table::
                            ; 0
01D9: 3F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F
                            ; 1
01DA: 06                    .byte SEG_B | SEG_C
                            ; 2
01DB: 5B                    .byte SEG_A | SEG_B | SEG_G | SEG_E | SEG_D
                            ; 3
01DC: 4F                    .byte SEG_A | SEG_B | SEG_G | SEG_C | SEG_D
                            ; 4
01DD: 66                    .byte SEG_F | SEG_G | SEG_B | SEG_C
                            ; 5
01DE: 6D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D
                            ; 6
01DF: 7D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; 7
01E0: 07                    .byte SEG_A | SEG_B | SEG_C
                            ; 8
01E1: 7F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G
                            ; 9
01E2: 6F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_F | SEG_G
                            ; A
01E3: 77                    .byte SEG_A | SEG_B | SEG_C | SEG_E | SEG_F | SEG_G
                            ; b
01E4: 7C                    .byte SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; C
01E5: 39                    .byte SEG_A | SEG_D | SEG_E | SEG_F
                            ; d
01E6: 5E                    .byte SEG_B | SEG_C | SEG_D | SEG_E | SEG_G
                            ; E
01E7: 79                    .byte SEG_A | SEG_D | SEG_E | SEG_F | SEG_G
                            ; F
01E8: 71                    .byte SEG_A | SEG_E | SEG_F | SEG_G
                        
                        ; void seg0_fig8(uint8_t step)
                        ; - advance first 7-segment display to specified figure-8 step (0-7)
01E9:                   seg0_fig8::
01E9: E5       [11]         push    hl
01EA: C5       [22]         push    bc
01EB: 01FE01   [32]         ld	    bc, FIG8_table
01EE: 2600     [39]         ld	    h, 0
01F0: 09       [50]         add	    hl, bc	; hl = FIG8_table + step
01F1: 3A0020   [63]         ld	    a, (Seg0_data)
01F4: E680     [70]         and	    SEG_DP
01F6: B6       [77]         or	    (hl)
01F7: 6F       [81]         ld	    l, a	; l = (*Seg0_data & SEG_DP) | FIG8_table[step]
01F8: CD1C02   [98]         call    seg0_write
01FB: C1       [108]        pop	    bc
01FC: E1       [118]        pop	    hl
01FD: C9       [128]        ret
                        
01FE:                   FIG8_table::
01FE: 01024010              .byte SEG_A, SEG_B, SEG_G, SEG_E, SEG_D, SEG_C, SEG_G, SEG_F
0202: 08044020          
                        
                        ; void seg0_toggle(uint8_t bits)
                        ; - toggle specified bits of first 7-segment display register
0206:                   seg0_toggle::
0206: E5       [11]         push    hl
0207: 3A0020   [24]         ld	    a, (Seg0_data)
020A: AD       [28]         xor	    l
020B: 6F       [32]         ld	    l, a
020C: CD1C02   [49]         call    seg0_write
020F: E1       [59]         pop	    hl
0210: C9       [69]         ret
                        
                        ; void seg1_toggle(uint8_t bits)
                        ; - toggle specified bits of second 7-segment display register
0211:                   seg1_toggle::
0211: E5       [11]         push    hl
0212: 3A0120   [24]         ld	    a, (Seg1_data)
0215: AD       [28]         xor	    l
0216: 6F       [32]         ld	    l, a
0217: CD2302   [49]         call    seg1_write
021A: E1       [59]         pop	    hl
021B: C9       [69]         ret
                        
                        ; void seg0_write(uint8_t bits)
                        ; - write raw bits to first 7-segment display register
021C:                   seg0_write::
021C: 7D       [ 4]         ld	    a, l
021D: 320020   [17]         ld	    (Seg0_data), a
0220: D300     [28]         out	    (PORT_SEG0), a
0222: C9       [38]         ret
                        
                        ; void seg1_write(uint8_t bits)
                        ; - write raw bits to second 7-segment display register
0223:                   seg1_write::
0223: 7D       [ 4]         ld	    a, l
0224: 320120   [17]         ld	    (Seg1_data), a
0227: D310     [28]         out	    (PORT_SEG1), a
0229: C9       [38]         ret
                        
                        ; void delay_ms(uint8_t ms)
                        ; - delay for at least the specified number of milliseconds
                        #local
022A:                   delay_ms::
022A: 2C       [ 4]         inc	    l
022B: 2D       [ 8]         dec	    l
022C: C8       [13|19]      ret	    z		; delay of 0 returns immediately
022D: C5       [24]         push    bc
022E: 45       [28]         ld	    b, l
022F:                   loop:
022F: CD3602   [17]         call    delay_1ms
0232: 10FB     [25|30]      djnz    loop
0234: C1       [35]         pop	    bc
0235: C9       [45]         ret
                        #endlocal
                        
                        ; void delay_1ms()
                        ; - delay for 1ms (technically, 0.9999ms)
                        #local
0236:                   delay_1ms::
0236: C5       [11]         push    bc		; 11 T-states
                        ; To delay 1ms, we want to wait 10,000 T-states (@10MHz)
                        ; The loop is (38*b + 13*(b-1) + 8) T-states long
                        ; Rearranging: 51*b - 5
                        ; Solve for b: b = (10000 + 5 / 51) = 196.17
0237: 06C3     [18]         ld	    b, 195	; 7 T-states
0239:                   loop:
0239: E3       [19]         ex	    (sp), hl	; 19 T-states
023A: E3       [38]         ex	    (sp), hl	; 19 T-states
023B: 10FC     [46|51]      djnz    loop	; (b-1)*13+8 T-states
023D: C1       [56]         pop	    bc		; 10 T-states
023E: 00       [60]         nop			; 4 T-states
023F: C9       [70]         ret			; 10 T-states
                        ; We also assume the routine is CALLed, for 17 T-states.
                        ; Total delay is therefore:
                        ;   17 + 11 + 7 + 51*195 - 5 + 10 + 4 + 10 = 9,999
                        #endlocal
                        
                        ; Remaining 56KB and 64KB segments to fill up ROM image
0000:                   #code FILLER1, 0, 0xE000
0000:                   #code FILLER2, 0, 0x10000


total time: 0.0130 sec.
no errors
