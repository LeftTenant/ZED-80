                        ; --------------------------------------
                        ; zasm: assemble "rambasic.asm"
                        ; date: 2018-10-12 16:42:23
                        ; --------------------------------------


                        ;==================================================================================
                        ; The updates to the original BASIC within this file are copyright Grant Searle
                        ;
                        ; You have permission to use this for NON COMMERCIAL USE ONLY
                        ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        ;
                        ; http://searle.hostei.com/grant/index.html
                        ;
                        ; eMail: home.micros01@btinternet.com
                        ;
                        ; If the above don't work, please perform an Internet search to see if I have
                        ; updated the web page hosting service.
                        ;
                        ;==================================================================================
                        
                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        
                        ; default fill is 00
                        #target bin
                        
                        #include "z84c40.inc"
                        ; The Z84C40 is the Z80's SIO peripheral. See um0081.pdf for documentation.
                        
0020:                   PORT_SIOBASE	    equ 0x20		    ; base port address for SIO chip
0020:                   PORT_SIOADAT	    equ PORT_SIOBASE	    ; port address for SIO port A, data register
0021:                   PORT_SIOBDAT	    equ PORT_SIOBASE + 1    ; port address for SIO port B, data register
0022:                   PORT_SIOACTL	    equ PORT_SIOBASE + 2    ; port address for SIO port A, control register
0023:                   PORT_SIOBCTL	    equ PORT_SIOBASE + 3    ; port address for SIO port B, control register
                        
                        ; WR0 "CRC Reset Code" values (bits 7-6)
0000:                   SIOWR0_CRC_NOP		equ 0x00	    ; no CRC reset code
0040:                   SIOWR0_CRC_RST_RX_CHK	equ 1 << 6	    ; reset RX CRC checker
0080:                   SIOWR0_CRC_RST_TX_GEN	equ 2 << 6	    ; reset TX CRC generator
00C0:                   SIOWR0_CRC_RST_TX_UNDR  equ 3 << 6	    ; reset TX underrun/EOM latch
                        
                        ; WR0 "Command" values (bits 5-3)
0000:                   SIOWR0_CMD_NOP		equ 0x00	    ; no command
0008:                   SIOWR0_CMD_SND_ABRT	equ 1 << 3	    ; send abort (SDLC only)
0010:                   SIOWR0_CMD_RST_EXTINT	equ 2 << 3	    ; reset external/status interrupts
0018:                   SIOWR0_CMD_RST_CHAN	equ 3 << 3	    ; reset channel
0020:                   SIOWR0_CMD_INTENA_NXTRX	equ 4 << 3	    ; enable interrupt on next receive character
0028:                   SIOWR0_CMD_RST_TXINTPND equ 5 << 3	    ; reset TX interrupt pending
0030:                   SIOWR0_CMD_RST_ERR	equ 6 << 3	    ; reset error latches
0038:                   SIOWR0_CMD_INTRETN	equ 7 << 3	    ; return from interrupt (not needed with Z80)
                        
                        ; WR0 "Pointer" values (bits 2-0)
0000:                   SIOWR0_PTR_R0		equ 0x00	    ; set pointer to register 0
0001:                   SIOWR0_PTR_R1		equ 0x01	    ; set pointer to register 1
0002:                   SIOWR0_PTR_R2		equ 0x02	    ; set pointer to register 2
0003:                   SIOWR0_PTR_R3		equ 0x03	    ; set pointer to register 3
0004:                   SIOWR0_PTR_R4		equ 0x04	    ; set pointer to register 4
0005:                   SIOWR0_PTR_R5		equ 0x05	    ; set pointer to register 5
0006:                   SIOWR0_PTR_R6		equ 0x06	    ; set pointer to register 6
0007:                   SIOWR0_PTR_R7		equ 0x07	    ; set pointer to register 7
                        
                        ; WR1 interrupt & wait/ready control bits
0001:                   SIOWR1_EXTINTENA	equ 0x01	    ; external/status interrupt enable
0002:                   SIOWR1_TXINTENA		equ 0x02	    ; TX interrupt enable
0004:                   SIOWR1_STATIVEC		equ 0x04	    ; status affects interrupt vector (set in ch. B only)
0000:                   SIOWR1_RXINT_DISABLE	equ 0 << 3	    ; RX interrupts disabled
0008:                   SIOWR1_RXINT_FIRST	equ 1 << 3	    ; RX interrupt on first character
0010:                   SIOWR1_RXINT_ALLPRTY	equ 2 << 3	    ; RX interrupt on all characters, parity err is SR cond
0018:                   SIOWR1_RXINT_ALLNPRTY	equ 3 << 3	    ; RX interrupt on all characters, parity err no intr
                        ; bits 7-5 are for WAIT/READY functions, which we don't use (always write as 0)
                        
                        ; WR2 is the interrupt vector register (set in channel B only)
                        
                        ; WR3 receiver logic control bits
0001:                   SIOWR3_RXENA		equ 0x01	    ; receiver enable
0002:                   SIOWR3_SYNC_INHIBIT	equ 0x02	    ; sync character load inhibit
0004:                   SIOWR3_ADDR_SRCHMODE	equ 0x04	    ; address search mode
0008:                   SIOWR3_RXCRCENA		equ 0x08	    ; receiver CRC enable
0010:                   SIOWR3_ENTER_HUNT	equ 0x10	    ; enter hunt phase
0020:                   SIOWR3_AUTO_ENABLES	equ 0x20	    ; auto enables (DCD/CTS are RX/TX enables)
0000:                   SIOWR3_RX_5_BITS	equ 0 << 6	    ; receive 5 bits/character
0040:                   SIOWR3_RX_7_BITS	equ 1 << 6	    ; receive 7 bits/character
0080:                   SIOWR3_RX_6_BITS	equ 2 << 6	    ; receive 6 bits/character
00C0:                   SIOWR3_RX_8_BITS	equ 3 << 6	    ; receive 8 bits/character
                        
                        ; WR4 RX/TX configuration (set first before WR1, WR3, WR5, WR6, and WR7)
0001:                   SIOWR4_PARITY		equ 0x01	    ; parity on/off
0002:                   SIOWR4_PRTY_EVEN	equ 0x02	    ; even parity
0000:                   SIOWR4_PRTY_ODD		equ 0x00	    ; odd parity
0000:                   SIOWR4_TXSTOP_SYNC	equ 0 << 2	    ; synchronous mode (no TX stop bits)
0004:                   SIOWR4_TXSTOP_1		equ 1 << 2	    ; 1 TX stop bit
0008:                   SIOWR4_TXSTOP_1_5	equ 2 << 2	    ; 1.5 TX stop bits
000C:                   SIOWR4_TXSTOP_2		equ 3 << 2	    ; 2 TX stop bits
                        ; bits 5-4 set the sync modes, which we don't use (always write as 0)
0000:                   SIOWR4_CLK_x1		equ 0 << 6	    ; data rate x1 = clock rate
0040:                   SIOWR4_CLK_x16		equ 1 << 6	    ; data rate x16 = clock rate
0080:                   SIOWR4_CLK_x32		equ 2 << 6	    ; data rate x32 = clock rate
00C0:                   SIOWR4_CLK_x64		equ 3 << 6	    ; data rate x64 = clock rate
                        
                        ; WR5 transmitter logic control bits
0001:                   SIOWR5_TXCRCENA		equ 0x01	    ; transmitter CRC enable
0002:                   SIOWR5_RTS		equ 0x02	    ; request to send
0004:                   SIOWR5_CRC16_SDLC	equ 0x04	    ; CRC-16 vs. SDLC polynomial
0008:                   SIOWR5_TXENA		equ 0x08	    ; transmitter enable
0010:                   SIOWR5_SND_BRK		equ 0x10	    ; send break
0000:                   SIOWR5_TX_5_BITS	equ 0 << 5	    ; transmit 5 bits/character
0020:                   SIOWR5_TX_7_BITS	equ 1 << 5	    ; transmit 7 bits/character
0040:                   SIOWR5_TX_6_BITS	equ 2 << 5	    ; transmit 6 bits/character
0060:                   SIOWR5_TX_8_BITS	equ 3 << 5	    ; transmit 8 bits/character
0080:                   SIOWR5_DTR		equ 0x80	    ; data terminal ready
                        
                        ; WR6 transmitter sync register for use in synchronous modes, which we don't use
                        ; WR7 receiver sync register for use in synchronous modes, which we don't use
                        
                        ; RR0 status bits (mostly normal operation)
0001:                   SIORR0_RCA		equ 0x01	    ; RX character available
0002:                   SIORR0_INTPND		equ 0x02	    ; interrupt pending (channel A only)
0004:                   SIORR0_TBE		equ 0x04	    ; TX buffer empty
0008:                   SIORR0_DCD		equ 0x08	    ; latched DCD input bit
0010:                   SIORR0_SYNC		equ 0x10	    ; latched SYNC input bit (hunt in SDLC)
0020:                   SIORR0_CTS		equ 0x20	    ; latched CTS input bit
0040:                   SIORR0_TX_UNDR		equ 0x40	    ; TX underrun / end of message
0080:                   SIORR0_BRK_ABRT		equ 0x80	    ; break/abort detected
                        ; As bit numbers, useful for the "bit" instruction, to test individual bit flags
0000:                   SIORR0_IDX_RCA		equ 0
0001:                   SIORR0_IDX_INTPND	equ 1
0002:                   SIORR0_IDX_TBE		equ 2
0003:                   SIORR0_IDX_DCD		equ 3
0004:                   SIORR0_IDX_SYNC		equ 4
0005:                   SIORR0_IDX_CTS		equ 5
0006:                   SIORR0_IDX_TX_UNDR	equ 6
0007:                   SIORR0_IDX_BRK_ABRT	equ 7
                        
                        ; RR1 status bits (mostly errors)
0001:                   SIORR1_ALLSENT		equ 0x01	    ; all characters fully sent
                        ; bits 3-1 are SDLC-only
0010:                   SIORR1_PRTYERR		equ 0x10	    ; parity error
0020:                   SIORR1_ROE		equ 0x20	    ; RX overrun error
0040:                   SIORR1_CRCFRMERR	equ 0x40	    ; CRC/framing error
                        ; bit 7 is SDLC-only
                        
                        ; RR2 is the interrupt vector register (read from channel B only)
                        ; - if "Status Affects Vector" bit is set, this will be the current vector value,
                        ;   modified by whatever interrupt conditions are pending
                        
                        M_sio_reset	macro
                            ld	    a, SIOWR0_CMD_RST_CHAN
                            out	    (PORT_SIOACTL), a
                            out	    (PORT_SIOBCTL), a
                            endm
                        
                        ; GENERAL EQUATES
                        
0003:                   CTRLC   .EQU    03H             ; Control "C"
0007:                   CTRLG   .EQU    07H             ; Control "G"
0008:                   BKSP    .EQU    08H             ; Back space
000A:                   LF      .EQU    0AH             ; Line feed
000C:                   CS      .EQU    0CH             ; Clear screen
000D:                   CR      .EQU    0DH             ; Carriage return
000F:                   CTRLO   .EQU    0FH             ; Control "O"
0011:                   CTRLQ	.EQU	11H		        ; Control "Q"
0012:                   CTRLR   .EQU    12H             ; Control "R"
0013:                   CTRLS   .EQU    13H             ; Control "S"
0015:                   CTRLU   .EQU    15H             ; Control "U"
001B:                   ESC     .EQU    1BH             ; Escape
007F:                   DEL     .EQU    7FH             ; Delete
                        
                        ; BASIC WORK SPACE LOCATIONS
                        
                        ; Since the BASIC code itself needs to sit in ram starting at $2000, we
                        ; have to start after that point.
4000:                   AFTER_CODE .EQU 4000H
4045:                   WRKSPC  .EQU    AFTER_CODE+45H	    ; BASIC Work space
4048:                   USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
404B:                   OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
404C:                   OTPORT  .EQU    WRKSPC+7H           ; Port (p)
404E:                   DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
404F:                   DIV1    .EQU    WRKSPC+0AH           ; <- Values
4053:                   DIV2    .EQU    WRKSPC+0EH           ; <-   to
4057:                   DIV3    .EQU    WRKSPC+12H           ; <-   be
405A:                   DIV4    .EQU    WRKSPC+15H           ; <-inserted
405C:                   SEED    .EQU    WRKSPC+17H           ; Random number seed
407F:                   LSTRND  .EQU    WRKSPC+3AH           ; Last random number
4083:                   INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
4084:                   INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
4086:                   NULLS   .EQU    WRKSPC+41H           ; Number of nulls
4087:                   LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
4088:                   COMMAN  .EQU    WRKSPC+43H           ; Width for commas
4089:                   NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
408A:                   CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
408B:                   LINESC  .EQU    WRKSPC+46H           ; Lines counter
408D:                   LINESN  .EQU    WRKSPC+48H           ; Lines number
408F:                   CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
4091:                   NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
4092:                   BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
4093:                   RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
4096:                   POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
4099:                   PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
409C:                   RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
409F:                   STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
40A1:                   LINEAT  .EQU    WRKSPC+5CH           ; Current line number
40A3:                   BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
40A6:                   BUFFER  .EQU    WRKSPC+61H           ; Input buffer
40AB:                   STACK   .EQU    WRKSPC+66H           ; Initial stack
40F0:                   CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
40F1:                   LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
40F2:                   TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
40F3:                   DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
40F4:                   LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
40F6:                   TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
40F8:                   TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
4104:                   TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
4108:                   STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
410A:                   CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
410C:                   LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
410E:                   DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
4110:                   FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
4111:                   LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
4112:                   READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
4113:                   BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
4115:                   NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
4117:                   ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
4119:                   CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
411B:                   PROGND  .EQU    WRKSPC+0D6H          ; End of program
411D:                   VAREND  .EQU    WRKSPC+0D8H          ; End of variables
411F:                   ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
4121:                   NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
4123:                   FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
4125:                   FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
4129:                   FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
412C:                   FPEXP   .EQU    FPREG+3         ; Floating point exponent
412D:                   SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
412E:                   PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
413B:                   MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
413E:                   PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
41A2:                   STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
                        
                        ; BASIC ERROR CODE VALUES
                        
0000:                   NF      .EQU    00H             ; NEXT without FOR
0002:                   SN      .EQU    02H             ; Syntax error
0004:                   RG      .EQU    04H             ; RETURN without GOSUB
0006:                   OD      .EQU    06H             ; Out of DATA
0008:                   FC      .EQU    08H             ; Function call error
000A:                   OV      .EQU    0AH             ; Overflow
000C:                   OM      .EQU    0CH             ; Out of memory
000E:                   UL      .EQU    0EH             ; Undefined line number
0010:                   BS      .EQU    10H             ; Bad subscript
0012:                   DD      .EQU    12H             ; Re-DIMensioned array
0014:                   DZ      .EQU    14H             ; Division by zero (/0)
0016:                   ID      .EQU    16H             ; Illegal direct
0018:                   TM      .EQU    18H             ; Type miss-match
001A:                   OS      .EQU    1AH             ; Out of string space
001C:                   LS      .EQU    1CH             ; String too long
001E:                   ST      .EQU    1EH             ; String formula too complex
0020:                   CN      .EQU    20H             ; Can't CONTinue
0022:                   UF      .EQU    22H             ; UnDEFined FN function
0024:                   MO      .EQU    24H             ; Missing operand
0026:                   HX      .EQU    26H             ; HEX error
0028:                   BN      .EQU    28H             ; BIN error
                        
                        ; Our code loads immediately above the 8K ROM
2000:                   #code TEXT,0x2000
                        
2000:                   COLD:		                ; Jump for cold start
2000: 00       [ 4]     	NOP			; These two bytes get damaged to an "add a,b" by the timer tick
2001: 00       [ 8]     	NOP			; in my ROM monitor.
2002: F3       [12]     	DI			; disable interrupts so the timer tick doesn't mess with RAM
2003: DD210000 [26]             LD      IX,0            ; Flag cold start
2007: C30E20   [36]             JP      CSTART          ; Jump to initialise
                        
200A: BB28                      .WORD   DEINT           ; Get integer -32768 to 32767
200C: 3130                      .WORD   ABPASS          ; Return integer in AB
                        
                        
200E:                   CSTART:
200E: 214540   [10]     	LD      HL,WRKSPC       ; Start of workspace RAM
2011: F9       [16]             LD      SP,HL           ; Set up a temporary stack
2012: C35F3C   [26]             JP      INITST          ; Go to initialise
                        
2015: 11DB22   [10]     INIT:   LD      DE,INITAB       ; Initialise workspace
2018: 0663     [17]             LD      B,INITBE-INITAB+3; Bytes to copy
201A: 214540   [27]             LD      HL,WRKSPC       ; Into workspace RAM
201D: 1A       [ 7]     COPY:   LD      A,(DE)          ; Get source
201E: 77       [14]             LD      (HL),A          ; To destination
201F: 23       [20]             INC     HL              ; Next destination
2020: 13       [26]             INC     DE              ; Next source
2021: 05       [30]             DEC     B               ; Count bytes
2022: C21D20   [40|40]          JP      NZ,COPY         ; More to move
2025: F9       [46]             LD      SP,HL           ; Temporary stack
2026: CDDC24   [63]             CALL    CLREG           ; Clear registers and stack
2029: CDB12A   [80]             CALL    PRNTCRLF        ; Output CRLF
202C: 32EF40   [93]             LD      (BUFFER+72+1),A ; Mark end of buffer
202F: 323E41   [106]            LD      (PROGST),A      ; Initialise program area
2032: 21F020   [10]     MSIZE:  LD      HL,MEMMSG       ; Point to message
2035: CD4F31   [27]             CALL    PRS             ; Output "Memory size"
2038: CDF924   [44]             CALL    PROMPT          ; Get input with '?'
203B: CD0228   [61]             CALL    GETCHR          ; Get next character
203E: B7       [65]             OR      A               ; Set flags
203F: C25720   [75|75]          JP      NZ,TSTMEM       ; If number - Test if RAM there
2042: 21A241   [85]             LD      HL,STLOOK       ; Point to start of RAM
2045: 23       [ 6]     MLOOP:  INC     HL              ; Next byte
2046: 7C       [10]             LD      A,H             ; Above address FFFF ?
2047: B5       [14]             OR      L
2048: CA6920   [24|24]          JP      Z,SETTOP        ; Yes - 64K RAM
204B: 7E       [31]             LD      A,(HL)          ; Get contents
204C: 47       [35]             LD      B,A             ; Save it
204D: 2F       [39]             CPL                     ; Flip all bits
204E: 77       [46]             LD      (HL),A          ; Put it back
204F: BE       [53]             CP      (HL)            ; RAM there if same
2050: 70       [60]             LD      (HL),B          ; Restore old contents
2051: CA4520   [70|70]          JP      Z,MLOOP         ; If RAM - test next byte
2054: C36920   [80]             JP      SETTOP          ; Top of RAM found
                        
2057: CDD528   [17]     TSTMEM: CALL    ATOH            ; Get high memory into DE
205A: B7       [21]             OR      A               ; Set flags on last byte
205B: C2AA23   [31|31]          JP      NZ,SNERR        ; ?SN Error if bad character
205E: EB       [35]             EX      DE,HL           ; Address into HL
205F: 2B       [41]             DEC     HL              ; Back one byte
2060: 3ED9     [48]             LD      A,11011001B     ; Test byte
2062: 46       [55]             LD      B,(HL)          ; Get old contents
2063: 77       [62]             LD      (HL),A          ; Load test byte
2064: BE       [69]             CP      (HL)            ; RAM there if same
2065: 70       [76]             LD      (HL),B          ; Restore old contents
2066: C23220   [86|86]          JP      NZ,MSIZE        ; Ask again if no RAM
                        
2069: 2B       [ 6]     SETTOP: DEC     HL              ; Back one byte
206A: 11A141   [16]             LD      DE,STLOOK-1     ; See if enough RAM
206D: CD7226   [33]             CALL    CPDEHL          ; Compare DE with HL
2070: DA3220   [43|43]          JP      C,MSIZE         ; Ask again if not enough RAM
2073: 11CEFF   [53]             LD      DE,0-50         ; 50 Bytes string space
2076: 22F440   [69]             LD      (LSTRAM),HL     ; Save last available RAM
2079: 19       [80]             ADD     HL,DE           ; Allocate string space
207A: 229F40   [96]             LD      (STRSPC),HL     ; Save string space
207D: CDB724   [113]            CALL    CLRPTR          ; Clear program area
2080: 2A9F40   [129]            LD      HL,(STRSPC)     ; Get end of memory
2083: 11EFFF   [139]            LD      DE,0-17         ; Offset for free bytes
2086: 19       [150]            ADD     HL,DE           ; Adjust HL
2087: 113E41   [160]            LD      DE,PROGST       ; Start of program text
208A: 7D       [164]            LD      A,L             ; Get LSB
208B: 93       [168]            SUB     E               ; Adjust it
208C: 6F       [172]            LD      L,A             ; Re-save
208D: 7C       [176]            LD      A,H             ; Get MSB
208E: 9A       [180]            SBC     A,D             ; Adjust it
208F: 67       [184]            LD      H,A             ; Re-save
2090: E5       [195]            PUSH    HL              ; Save bytes free
2091: 21B920   [205]            LD      HL,SIGNON       ; Sign-on message
2094: CD4F31   [222]            CALL    PRS             ; Output string
2097: E1       [232]            POP     HL              ; Get bytes free back
2098: CDF237   [249]            CALL    PRNTHL          ; Output amount of free memory
209B: 21AA20   [259]            LD      HL,BFREE        ; " Bytes free" message
209E: CD4F31   [276]            CALL    PRS             ; Output string
                        
20A1: 31AB40   [10]     WARMST: LD      SP,STACK        ; Temporary stack
20A4: CDDC24   [17]     BRKRET: CALL    CLREG           ; Clear registers and stack
20A7: C3F523   [27]             JP      PRNTOK          ; Go to get command line
                        
20AA: 20427974          BFREE:  .BYTE   " Bytes free",CR,LF,0,0
20AE: 65732066          
20B2: 7265650D          
20B6: 0A0000            
                        
20B9: 5A383020          SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
20BD: 42415349          
20C1: 43205665          
20C5: 7220342E          
20C9: 37620D0A          
20CD: 436F7079                  .BYTE   "Copyright ",40,"C",41
20D1: 72696768          
20D5: 74202843          
20D9: 29                
20DA: 20313937                  .BYTE   " 1978 by Microsoft",CR,LF,0,0
20DE: 38206279          
20E2: 204D6963          
20E6: 726F736F          
20EA: 66740D0A          
20EE: 0000              
                        
20F0: 4D656D6F          MEMMSG: .BYTE   "Memory top",0
20F4: 72792074          
20F8: 6F7000            
                        
                        ; FUNCTION ADDRESS TABLE
                        
20FB: 6736              FNCTAB: .WORD   SGN
20FD: 2B37                      .WORD   INT
20FF: 7D36                      .WORD   ABS
2101: 4840                      .WORD   USR
2103: 0F30                      .WORD   FRE
2105: 9433                      .WORD   INP
2107: 3D30                      .WORD   POS
2109: F138                      .WORD   SQR
210B: D039                      .WORD   RND
210D: 0C35                      .WORD   LOG
210F: 3F39                      .WORD   EXP
2111: 453A                      .WORD   COS
2113: 4B3A                      .WORD   SIN
2115: AC3A                      .WORD   TAN
2117: C13A                      .WORD   ATN
2119: E833                      .WORD   PEEK
211B: 333B                      .WORD   DEEK
211D: 9640                      .WORD   POINT
211F: C132                      .WORD   LEN
2121: D930                      .WORD   STR
2123: 5B33                      .WORD   VAL
2125: D032                      .WORD   ASC
2127: E132                      .WORD   CHR
2129: 553B                      .WORD   HEX
212B: E83B                      .WORD   BIN
212D: F132                      .WORD   LEFT
212F: 2133                      .WORD   RIGHT
2131: 2B33                      .WORD   MID
                        
                        ; RESERVED WORD LIST
                        
2133: C54E44            WORDS:  .BYTE   'E'+80H,"ND"
2136: C64F52                    .BYTE   'F'+80H,"OR"
2139: CE455854                  .BYTE   'N'+80H,"EXT"
213D: C4415441                  .BYTE   'D'+80H,"ATA"
2141: C94E5055                  .BYTE   'I'+80H,"NPUT"
2145: 54                
2146: C4494D                    .BYTE   'D'+80H,"IM"
2149: D2454144                  .BYTE   'R'+80H,"EAD"
214D: CC4554                    .BYTE   'L'+80H,"ET"
2150: C74F544F                  .BYTE   'G'+80H,"OTO"
2154: D2554E                    .BYTE   'R'+80H,"UN"
2157: C946                      .BYTE   'I'+80H,"F"
2159: D2455354                  .BYTE   'R'+80H,"ESTORE"
215D: 4F5245            
2160: C74F5355                  .BYTE   'G'+80H,"OSUB"
2164: 42                
2165: D2455455                  .BYTE   'R'+80H,"ETURN"
2169: 524E              
216B: D2454D                    .BYTE   'R'+80H,"EM"
216E: D3544F50                  .BYTE   'S'+80H,"TOP"
2172: CF5554                    .BYTE   'O'+80H,"UT"
2175: CF4E                      .BYTE   'O'+80H,"N"
2177: CE554C4C                  .BYTE   'N'+80H,"ULL"
217B: D7414954                  .BYTE   'W'+80H,"AIT"
217F: C44546                    .BYTE   'D'+80H,"EF"
2182: D04F4B45                  .BYTE   'P'+80H,"OKE"
2186: C44F4B45                  .BYTE   'D'+80H,"OKE"
218A: D3435245                  .BYTE   'S'+80H,"CREEN"
218E: 454E              
2190: CC494E45                  .BYTE   'L'+80H,"INES"
2194: 53                
2195: C34C53                    .BYTE   'C'+80H,"LS"
2198: D7494454                  .BYTE   'W'+80H,"IDTH"
219C: 48                
219D: CD4F4E49                  .BYTE   'M'+80H,"ONITOR"
21A1: 544F52            
21A4: D34554                    .BYTE   'S'+80H,"ET"
21A7: D2455345                  .BYTE   'R'+80H,"ESET"
21AB: 54                
21AC: D052494E                  .BYTE   'P'+80H,"RINT"
21B0: 54                
21B1: C34F4E54                  .BYTE   'C'+80H,"ONT"
21B5: CC495354                  .BYTE   'L'+80H,"IST"
21B9: C34C4541                  .BYTE   'C'+80H,"LEAR"
21BD: 52                
21BE: C34C4F41                  .BYTE   'C'+80H,"LOAD"
21C2: 44                
21C3: C3534156                  .BYTE   'C'+80H,"SAVE"
21C7: 45                
21C8: CE4557                    .BYTE   'N'+80H,"EW"
                        
21CB: D4414228                  .BYTE   'T'+80H,"AB("
21CF: D44F                      .BYTE   'T'+80H,"O"
21D1: C64E                      .BYTE   'F'+80H,"N"
21D3: D3504328                  .BYTE   'S'+80H,"PC("
21D7: D448454E                  .BYTE   'T'+80H,"HEN"
21DB: CE4F54                    .BYTE   'N'+80H,"OT"
21DE: D3544550                  .BYTE   'S'+80H,"TEP"
                        
21E2: AB                        .BYTE   '+'+80H
21E3: AD                        .BYTE   '-'+80H
21E4: AA                        .BYTE   '*'+80H
21E5: AF                        .BYTE   '/'+80H
21E6: DE                        .BYTE   '^'+80H
21E7: C14E44                    .BYTE   'A'+80H,"ND"
21EA: CF52                      .BYTE   'O'+80H,"R"
21EC: BE                        .BYTE   '>'+80H
21ED: BD                        .BYTE   '='+80H
21EE: BC                        .BYTE   '<'+80H
                        
21EF: D3474E                    .BYTE   'S'+80H,"GN"
21F2: C94E54                    .BYTE   'I'+80H,"NT"
21F5: C14253                    .BYTE   'A'+80H,"BS"
21F8: D55352                    .BYTE   'U'+80H,"SR"
21FB: C65245                    .BYTE   'F'+80H,"RE"
21FE: C94E50                    .BYTE   'I'+80H,"NP"
2201: D04F53                    .BYTE   'P'+80H,"OS"
2204: D35152                    .BYTE   'S'+80H,"QR"
2207: D24E44                    .BYTE   'R'+80H,"ND"
220A: CC4F47                    .BYTE   'L'+80H,"OG"
220D: C55850                    .BYTE   'E'+80H,"XP"
2210: C34F53                    .BYTE   'C'+80H,"OS"
2213: D3494E                    .BYTE   'S'+80H,"IN"
2216: D4414E                    .BYTE   'T'+80H,"AN"
2219: C1544E                    .BYTE   'A'+80H,"TN"
221C: D045454B                  .BYTE   'P'+80H,"EEK"
2220: C445454B                  .BYTE   'D'+80H,"EEK"
2224: D04F494E                  .BYTE   'P'+80H,"OINT"
2228: 54                
2229: CC454E                    .BYTE   'L'+80H,"EN"
222C: D3545224                  .BYTE   'S'+80H,"TR$"
2230: D6414C                    .BYTE   'V'+80H,"AL"
2233: C15343                    .BYTE   'A'+80H,"SC"
2236: C3485224                  .BYTE   'C'+80H,"HR$"
223A: C8455824                  .BYTE   'H'+80H,"EX$"
223E: C2494E24                  .BYTE   'B'+80H,"IN$"
2242: CC454654                  .BYTE   'L'+80H,"EFT$"
2246: 24                
2247: D2494748                  .BYTE   'R'+80H,"IGHT$"
224B: 5424              
224D: CD494424                  .BYTE   'M'+80H,"ID$"
2251: 80                        .BYTE   80H             ; End of list marker
                        
                        ; KEYWORD ADDRESS TABLE
                        
2252: 5328              WORDTB: .WORD   PEND
2254: 4927                      .WORD   FOR
2256: 2B2C                      .WORD   NEXT
2258: A029                      .WORD   DATA
225A: 322B                      .WORD   INPUT
225C: 672E                      .WORD   DIM
225E: 612B                      .WORD   READ
2260: B729                      .WORD   LET
2262: 5D29                      .WORD   GOTO
2264: 4029                      .WORD   RUN
2266: 2F2A                      .WORD   IF
2268: 1228                      .WORD   RESTOR
226A: 4C29                      .WORD   GOSUB
226C: 7B29                      .WORD   RETURN
226E: A229                      .WORD   REM
2270: 5128                      .WORD   STOP
2272: A033                      .WORD   POUT
2274: 112A                      .WORD   ON
2276: 9228                      .WORD   NULL
2278: A633                      .WORD   WAIT
227A: 4530                      .WORD   DEF
227C: EF33                      .WORD   POKE
227E: 3E3B                      .WORD   DOKE
2280: A229                      .WORD   REM
2282: 243B                      .WORD   LINES
2284: 173B                      .WORD   CLS
2286: 1C3B                      .WORD   WIDTH
2288: 5C3C                      .WORD   MONITR
228A: 9940                      .WORD   PSET
228C: 9C40                      .WORD   RESET
228E: 532A                      .WORD   PRINT
2290: 7F28                      .WORD   CONT
2292: BE26                      .WORD   LIST
2294: FA28                      .WORD   CLEAR
2296: A229                      .WORD   REM
2298: A229                      .WORD   REM
229A: B624                      .WORD   NEW
                        
                        ; RESERVED WORD TOKEN VALUES
                        
0080:                   ZEND    .EQU    080H            ; END
0081:                   ZFOR    .EQU    081H            ; FOR
0083:                   ZDATA   .EQU    083H            ; DATA
0088:                   ZGOTO   .EQU    088H            ; GOTO
008C:                   ZGOSUB  .EQU    08CH            ; GOSUB
008E:                   ZREM    .EQU    08EH            ; REM
009E:                   ZPRINT  .EQU    09EH            ; PRINT
00A4:                   ZNEW    .EQU    0A4H            ; NEW
                        
00A5:                   ZTAB    .EQU    0A5H            ; TAB
00A6:                   ZTO     .EQU    0A6H            ; TO
00A7:                   ZFN     .EQU    0A7H            ; FN
00A8:                   ZSPC    .EQU    0A8H            ; SPC
00A9:                   ZTHEN   .EQU    0A9H            ; THEN
00AA:                   ZNOT    .EQU    0AAH            ; NOT
00AB:                   ZSTEP   .EQU    0ABH            ; STEP
                        
00AC:                   ZPLUS   .EQU    0ACH            ; +
00AD:                   ZMINUS  .EQU    0ADH            ; -
00AE:                   ZTIMES  .EQU    0AEH            ; *
00AF:                   ZDIV    .EQU    0AFH            ; /
00B2:                   ZOR     .EQU    0B2H            ; OR
00B3:                   ZGTR    .EQU    0B3H            ; >
00B4:                   ZEQUAL  .EQU    0B4H            ; M
00B5:                   ZLTH    .EQU    0B5H            ; <
00B6:                   ZSGN    .EQU    0B6H            ; SGN
00C7:                   ZPOINT  .EQU    0C7H            ; POINT
00CF:                   ZLEFT   .EQU    0CDH +2         ; LEFT$
                        
                        ; ARITHMETIC PRECEDENCE TABLE
                        
229C: 79                PRITAB: .BYTE   79H             ; Precedence value
229D: D937                      .WORD   PADD            ; FPREG = <last> + FPREG
                        
229F: 79                        .BYTE   79H             ; Precedence value
22A0: 0D34                      .WORD   PSUB            ; FPREG = <last> - FPREG
                        
22A2: 7C                        .BYTE   7CH             ; Precedence value
22A3: 4B35                      .WORD   MULT            ; PPREG = <last> * FPREG
                        
22A5: 7C                        .BYTE   7CH             ; Precedence value
22A6: AC35                      .WORD   DIV             ; FPREG = <last> / FPREG
                        
22A8: 7F                        .BYTE   7FH             ; Precedence value
22A9: FA38                      .WORD   POWER           ; FPREG = <last> ^ FPREG
                        
22AB: 50                        .BYTE   50H             ; Precedence value
22AC: C02D                      .WORD   PAND            ; FPREG = <last> AND FPREG
                        
22AE: 46                        .BYTE   46H             ; Precedence value
22AF: BF2D                      .WORD   POR             ; FPREG = <last> OR FPREG
                        
                        ; BASIC ERROR CODE LIST
                        
22B1: 4E46              ERRORS: .BYTE   "NF"            ; NEXT without FOR
22B3: 534E                      .BYTE   "SN"            ; Syntax error
22B5: 5247                      .BYTE   "RG"            ; RETURN without GOSUB
22B7: 4F44                      .BYTE   "OD"            ; Out of DATA
22B9: 4643                      .BYTE   "FC"            ; Illegal function call
22BB: 4F56                      .BYTE   "OV"            ; Overflow error
22BD: 4F4D                      .BYTE   "OM"            ; Out of memory
22BF: 554C                      .BYTE   "UL"            ; Undefined line
22C1: 4253                      .BYTE   "BS"            ; Bad subscript
22C3: 4444                      .BYTE   "DD"            ; Re-DIMensioned array
22C5: 2F30                      .BYTE   "/0"            ; Division by zero
22C7: 4944                      .BYTE   "ID"            ; Illegal direct
22C9: 544D                      .BYTE   "TM"            ; Type mis-match
22CB: 4F53                      .BYTE   "OS"            ; Out of string space
22CD: 4C53                      .BYTE   "LS"            ; String too long
22CF: 5354                      .BYTE   "ST"            ; String formula too complex
22D1: 434E                      .BYTE   "CN"            ; Can't CONTinue
22D3: 5546                      .BYTE   "UF"            ; Undefined FN function
22D5: 4D4F                      .BYTE   "MO"            ; Missing operand
22D7: 4858                      .BYTE   "HX"            ; HEX error
22D9: 424E                      .BYTE   "BN"            ; BIN error
                        
                        ; INITIALISATION TABLE -------------------------------------------------------
                        
22DB: C3A120   [10]     INITAB: JP      WARMST          ; Warm start jump
22DE: C3D028   [20]             JP      FCERR           ; "USR (X)" jump (Set to Error)
22E1: D300     [31]             OUT     (0),A           ; "OUT p,n" skeleton
22E3: C9       [41]             RET
22E4: D600     [48]             SUB     0               ; Division support routine
22E6: 6F       [52]             LD      L,A
22E7: 7C       [56]             LD      A,H
22E8: DE00     [63]             SBC     A,0
22EA: 67       [67]             LD      H,A
22EB: 78       [71]             LD      A,B
22EC: DE00     [78]             SBC     A,0
22EE: 47       [82]             LD      B,A
22EF: 3E00     [89]             LD      A,0
22F1: C9       [99]             RET
22F2: 000000                    .BYTE   0,0,0                   ; Random number seed table used by RND
22F5: 354ACA99                  .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
22F9: 391C7698                  .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
22FD: 2295B398                  .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
2301: 0ADD4798                  .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
2305: 53D19999                  .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
2309: 0A1A9F98                  .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
230D: 65BCCD98                  .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
2311: D6773E98                  .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
2315: 52C74F80                  .BYTE   052H,0C7H,04FH,080H     ; Last random number
2319: DB00     [110]            IN      A,(0)           ; INP (x) skeleton
231B: C9       [120]            RET
231C: 01                        .BYTE   1               ; POS (x) number (1)
231D: FF                        .BYTE   255             ; Terminal width (255 = no auto CRLF)
231E: 1C                        .BYTE   28              ; Width for commas (3 columns)
231F: 00                        .BYTE   0               ; No nulls after input bytes
2320: 00                        .BYTE   0               ; Output enabled (^O off)
2321: 1400                      .WORD   20              ; Initial lines counter
2323: 1400                      .WORD   20              ; Initial lines number
2325: 0000                      .WORD   0               ; Array load/save check sum
2327: 00                        .BYTE   0               ; Break not by NMI
2328: 00                        .BYTE   0               ; Break flag
2329: C3EF25   [130]            JP      TTYLIN          ; Input reflection (set to TTY)
232C: C30000   [140]            JP      $0000           ; POINT reflection unused
232F: C30000   [150]            JP      $0000           ; SET reflection
2332: C30000   [160]            JP      $0000          	; RESET reflection
2335: A241                      .WORD   STLOOK          ; Temp string space
2337: FEFF                      .WORD   -2              ; Current line number (cold)
2339: 3F41                      .WORD   PROGST+1        ; Start of program text
233B:                   INITBE:                         
                        
                        ; END OF INITIALISATION TABLE ---------------------------------------------------
                        
233B: 20457272          ERRMSG: .BYTE   " Error",0
233F: 6F7200            
2342: 20696E20          INMSG:  .BYTE   " in ",0
2346: 00                
2346:                   ZERBYT  .EQU    $-1             ; A zero byte
2347: 4F6B0D0A          OKMSG:  .BYTE   "Ok",CR,LF,0,0
234B: 0000              
234D: 42726561          BRKMSG: .BYTE   "Break",0
2351: 6B00              
                        
2353: 210400   [10]     BAKSTK: LD      HL,4            ; Look for "FOR" block with
2356: 39       [21]             ADD     HL,SP           ; same index as specified
2357: 7E       [ 7]     LOKFOR: LD      A,(HL)          ; Get block ID
2358: 23       [13]             INC     HL              ; Point to index address
2359: FE81     [20]             CP      ZFOR            ; Is it a "FOR" token
235B: C0       [25|31]          RET     NZ              ; No - exit
235C: 4E       [32]             LD      C,(HL)          ; BC = Address of "FOR" index
235D: 23       [38]             INC     HL
235E: 46       [45]             LD      B,(HL)
235F: 23       [51]             INC     HL              ; Point to sign of STEP
2360: E5       [62]             PUSH    HL              ; Save pointer to sign
2361: 69       [66]             LD      L,C             ; HL = address of "FOR" index
2362: 60       [70]             LD      H,B
2363: 7A       [74]             LD      A,D             ; See if an index was specified
2364: B3       [78]             OR      E               ; DE = 0 if no index specified
2365: EB       [82]             EX      DE,HL           ; Specified index into HL
2366: CA6D23   [92|92]          JP      Z,INDFND        ; Skip if no index given
2369: EB       [96]             EX      DE,HL           ; Index back into DE
236A: CD7226   [113]            CALL    CPDEHL          ; Compare index with one given
236D: 010D00   [10]     INDFND: LD      BC,16-3         ; Offset to next block
2370: E1       [20]             POP     HL              ; Restore pointer to sign
2371: C8       [25|31]          RET     Z               ; Return if block found
2372: 09       [36]             ADD     HL,BC           ; Point to next block
2373: C35723   [46]             JP      LOKFOR          ; Keep on looking
                        
2376: CD9023   [17]     MOVUP:  CALL    ENFMEM          ; See if enough memory
2379: C5       [11]     MOVSTR: PUSH    BC              ; Save end of source
237A: E3       [30]             EX      (SP),HL         ; Swap source and dest" end
237B: C1       [40]             POP     BC              ; Get end of destination
237C: CD7226   [17]     MOVLP:  CALL    CPDEHL          ; See if list moved
237F: 7E       [24]             LD      A,(HL)          ; Get byte
2380: 02       [31]             LD      (BC),A          ; Move it
2381: C8       [36|42]          RET     Z               ; Exit if all done
2382: 0B       [42]             DEC     BC              ; Next byte to move to
2383: 2B       [48]             DEC     HL              ; Next byte to move
2384: C37C23   [58]             JP      MOVLP           ; Loop until all bytes moved
                        
2387: E5       [11]     CHKSTK: PUSH    HL              ; Save code string address
2388: 2A1F41   [27]             LD      HL,(ARREND)     ; Lowest free memory
238B: 0600     [34]             LD      B,0             ; BC = Number of levels to test
238D: 09       [45]             ADD     HL,BC           ; 2 Bytes for each level
238E: 09       [56]             ADD     HL,BC
238F: 3E                        .BYTE   3EH             ; Skip "PUSH HL"
2390: E5       [11]     ENFMEM: PUSH    HL              ; Save code string address
2391: 3ED0     [18]             LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
2393: 95       [22]             SUB     L
2394: 6F       [26]             LD      L,A
2395: 3EFF     [33]             LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
2397: 9C       [37]             SBC     A,H
2398: DA9F23   [47|47]          JP      C,OMERR         ; Not enough - ?OM Error
239B: 67       [51]             LD      H,A
239C: 39       [62]             ADD     HL,SP           ; Test if stack is overflowed
239D: E1       [72]             POP     HL              ; Restore code string address
239E: D8       [77|83]          RET     C               ; Return if enough mmory
239F: 1E0C     [ 7]     OMERR:  LD      E,OM            ; ?OM Error
23A1: C3BE23   [17]             JP      ERROR
                        
23A4: 2A0E41   [16]     DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
23A7: 22A140   [32]             LD      (LINEAT),HL     ; Save as current line
23AA: 1E02     [ 7]     SNERR:  LD      E,SN            ; ?SN Error
23AC: 01                        .BYTE   01H             ; Skip "LD E,DZ"
23AD: 1E14     [ 7]     DZERR:  LD      E,DZ            ; ?/0 Error
23AF: 01                        .BYTE   01H             ; Skip "LD E,NF"
23B0: 1E00     [ 7]     NFERR:  LD      E,NF            ; ?NF Error
23B2: 01                        .BYTE   01H             ; Skip "LD E,DD"
23B3: 1E12     [ 7]     DDERR:  LD      E,DD            ; ?DD Error
23B5: 01                        .BYTE   01H             ; Skip "LD E,UF"
23B6: 1E22     [ 7]     UFERR:  LD      E,UF            ; ?UF Error
23B8: 01                        .BYTE   01H             ; Skip "LD E,OV
23B9: 1E0A     [ 7]     OVERR:  LD      E,OV            ; ?OV Error
23BB: 01                        .BYTE   01H             ; Skip "LD E,TM"
23BC: 1E18     [ 7]     TMERR:  LD      E,TM            ; ?TM Error
                        
23BE: CDDC24   [17]     ERROR:  CALL    CLREG           ; Clear registers and stack
23C1: 328A40   [30]             LD      (CTLOFG),A      ; Enable output (A is 0)
23C4: CDA42A   [47]             CALL    STTLIN          ; Start new line
23C7: 21B122   [57]             LD      HL,ERRORS       ; Point to error codes
23CA: 57       [61]             LD      D,A             ; D = 0 (A is 0)
23CB: 3E3F     [68]             LD      A,'?'
23CD: CD8326   [85]             CALL    OUTC            ; Output '?'
23D0: 19       [96]             ADD     HL,DE           ; Offset to correct error code
23D1: 7E       [103]            LD      A,(HL)          ; First character
23D2: CD8326   [120]            CALL    OUTC            ; Output it
23D5: CD0228   [137]            CALL    GETCHR          ; Get next character
23D8: CD8326   [154]            CALL    OUTC            ; Output it
23DB: 213B23   [164]            LD      HL,ERRMSG       ; "Error" message
23DE: CD4F31   [17]     ERRIN:  CALL    PRS             ; Output message
23E1: 2AA140   [33]             LD      HL,(LINEAT)     ; Get line of error
23E4: 11FEFF   [43]             LD      DE,-2           ; Cold start error if -2
23E7: CD7226   [60]             CALL    CPDEHL          ; See if cold start error
23EA: CA0E20   [70|70]          JP      Z,CSTART        ; Cold start error - Restart
23ED: 7C       [74]             LD      A,H             ; Was it a direct error?
23EE: A5       [78]             AND     L               ; Line = -1 if direct error
23EF: 3C       [82]             INC     A
23F0: C4EA37   [92|99]          CALL    NZ,LINEIN       ; No - output line of error
23F3: 3E                        .BYTE   3EH             ; Skip "POP BC"
23F4: C1       [10]     POPNOK: POP     BC              ; Drop address in input buffer
                        
23F5: AF       [ 4]     PRNTOK: XOR     A               ; Output "Ok" and get command
23F6: 328A40   [17]             LD      (CTLOFG),A      ; Enable output
23F9: CDA42A   [34]             CALL    STTLIN          ; Start new line
23FC: 214723   [44]             LD      HL,OKMSG        ; "Ok" message
23FF: CD4F31   [61]             CALL    PRS             ; Output "Ok"
2402: 21FFFF   [10]     GETCMD: LD      HL,-1           ; Flag direct mode
2405: 22A140   [26]             LD      (LINEAT),HL     ; Save as current line
2408: CDEF25   [43]             CALL    GETLIN          ; Get an input line
240B: DA0224   [53|53]          JP      C,GETCMD        ; Get line again if break
240E: CD0228   [70]             CALL    GETCHR          ; Get first character
2411: 3C       [74]             INC     A               ; Test if end of line
2412: 3D       [78]             DEC     A               ; Without affecting Carry
2413: CA0224   [88|88]          JP      Z,GETCMD        ; Nothing entered - Get another
2416: F5       [99]             PUSH    AF              ; Save Carry status
2417: CDD528   [116]            CALL    ATOH            ; Get line number into DE
241A: D5       [127]            PUSH    DE              ; Save line number
241B: CD0625   [144]            CALL    CRUNCH          ; Tokenise rest of line
241E: 47       [148]            LD      B,A             ; Length of tokenised line
241F: D1       [158]            POP     DE              ; Restore line number
2420: F1       [168]            POP     AF              ; Restore Carry
2421: D2E227   [178|178]        JP      NC,EXCUTE       ; No line number - Direct mode
2424: D5       [189]            PUSH    DE              ; Save line number
2425: C5       [200]            PUSH    BC              ; Save length of tokenised line
2426: AF       [204]            XOR     A
2427: 321141   [217]            LD      (LSTBIN),A      ; Clear last byte input
242A: CD0228   [234]            CALL    GETCHR          ; Get next character
242D: B7       [238]            OR      A               ; Set flags
242E: F5       [249]            PUSH    AF              ; And save them
242F: CD9624   [266]            CALL    SRCHLN          ; Search for line number in DE
2432: DA3B24   [276|276]        JP      C,LINFND        ; Jump if line found
2435: F1       [286]            POP     AF              ; Get status
2436: F5       [297]            PUSH    AF              ; And re-save
2437: CA7629   [307|307]        JP      Z,ULERR         ; Nothing after number - Error
243A: B7       [311]            OR      A               ; Clear Carry
243B: C5       [11]     LINFND: PUSH    BC              ; Save address of line in prog
243C: D25224   [21|21]          JP      NC,INEWLN       ; Line not found - Insert new
243F: EB       [25]             EX      DE,HL           ; Next line address in DE
2440: 2A1B41   [41]             LD      HL,(PROGND)     ; End of program
2443: 1A       [ 7]     SFTPRG: LD      A,(DE)          ; Shift rest of program down
2444: 02       [14]             LD      (BC),A
2445: 03       [20]             INC     BC              ; Next destination
2446: 13       [26]             INC     DE              ; Next source
2447: CD7226   [43]             CALL    CPDEHL          ; All done?
244A: C24324   [53|53]          JP      NZ,SFTPRG       ; More to do
244D: 60       [57]             LD      H,B             ; HL - New end of program
244E: 69       [61]             LD      L,C
244F: 221B41   [77]             LD      (PROGND),HL     ; Update end of program
                        
2452: D1       [10]     INEWLN: POP     DE              ; Get address of line,
2453: F1       [20]             POP     AF              ; Get status
2454: CA7924   [30|30]          JP      Z,SETPTR        ; No text - Set up pointers
2457: 2A1B41   [46]             LD      HL,(PROGND)     ; Get end of program
245A: E3       [65]             EX      (SP),HL         ; Get length of input line
245B: C1       [75]             POP     BC              ; End of program to BC
245C: 09       [86]             ADD     HL,BC           ; Find new end
245D: E5       [97]             PUSH    HL              ; Save new end
245E: CD7623   [114]            CALL    MOVUP           ; Make space for line
2461: E1       [124]            POP     HL              ; Restore new end
2462: 221B41   [140]            LD      (PROGND),HL     ; Update end of program pointer
2465: EB       [144]            EX      DE,HL           ; Get line to move up in HL
2466: 74       [151]            LD      (HL),H          ; Save MSB
2467: D1       [161]            POP     DE              ; Get new line number
2468: 23       [167]            INC     HL              ; Skip pointer
2469: 23       [173]            INC     HL
246A: 73       [180]            LD      (HL),E          ; Save LSB of line number
246B: 23       [186]            INC     HL
246C: 72       [193]            LD      (HL),D          ; Save MSB of line number
246D: 23       [199]            INC     HL              ; To first byte in line
246E: 11A640   [209]            LD      DE,BUFFER       ; Copy buffer to program
2471: 1A       [ 7]     MOVBUF: LD      A,(DE)          ; Get source
2472: 77       [14]             LD      (HL),A          ; Save destinations
2473: 23       [20]             INC     HL              ; Next source
2474: 13       [26]             INC     DE              ; Next destination
2475: B7       [30]             OR      A               ; Done?
2476: C27124   [40|40]          JP      NZ,MOVBUF       ; No - Repeat
2479: CDC224   [17]     SETPTR: CALL    RUNFST          ; Set line pointers
247C: 23       [23]             INC     HL              ; To LSB of pointer
247D: EB       [27]             EX      DE,HL           ; Address to DE
247E: 62       [ 4]     PTRLP:  LD      H,D             ; Address to HL
247F: 6B       [ 8]             LD      L,E
2480: 7E       [15]             LD      A,(HL)          ; Get LSB of pointer
2481: 23       [21]             INC     HL              ; To MSB of pointer
2482: B6       [28]             OR      (HL)            ; Compare with MSB pointer
2483: CA0224   [38|38]          JP      Z,GETCMD        ; Get command line if end
2486: 23       [44]             INC     HL              ; To LSB of line number
2487: 23       [50]             INC     HL              ; Skip line number
2488: 23       [56]             INC     HL              ; Point to first byte in line
2489: AF       [60]             XOR     A               ; Looking for 00 byte
248A: BE       [ 7]     FNDEND: CP      (HL)            ; Found end of line?
248B: 23       [13]             INC     HL              ; Move to next byte
248C: C28A24   [23|23]          JP      NZ,FNDEND       ; No - Keep looking
248F: EB       [27]             EX      DE,HL           ; Next line address to HL
2490: 73       [34]             LD      (HL),E          ; Save LSB of pointer
2491: 23       [40]             INC     HL
2492: 72       [47]             LD      (HL),D          ; Save MSB of pointer
2493: C37E24   [57]             JP      PTRLP           ; Do next line
                        
2496: 2AA340   [16]     SRCHLN: LD      HL,(BASTXT)     ; Start of program text
2499: 44       [ 4]     SRCHLP: LD      B,H             ; BC = Address to look at
249A: 4D       [ 8]             LD      C,L
249B: 7E       [15]             LD      A,(HL)          ; Get address of next line
249C: 23       [21]             INC     HL
249D: B6       [28]             OR      (HL)            ; End of program found?
249E: 2B       [34]             DEC     HL
249F: C8       [39|45]          RET     Z               ; Yes - Line not found
24A0: 23       [45]             INC     HL
24A1: 23       [51]             INC     HL
24A2: 7E       [58]             LD      A,(HL)          ; Get LSB of line number
24A3: 23       [64]             INC     HL
24A4: 66       [71]             LD      H,(HL)          ; Get MSB of line number
24A5: 6F       [75]             LD      L,A
24A6: CD7226   [92]             CALL    CPDEHL          ; Compare with line in DE
24A9: 60       [96]             LD      H,B             ; HL = Start of this line
24AA: 69       [100]            LD      L,C
24AB: 7E       [107]            LD      A,(HL)          ; Get LSB of next line address
24AC: 23       [113]            INC     HL
24AD: 66       [120]            LD      H,(HL)          ; Get MSB of next line address
24AE: 6F       [124]            LD      L,A             ; Next line to HL
24AF: 3F       [128]            CCF
24B0: C8       [133|139]        RET     Z               ; Lines found - Exit
24B1: 3F       [137]            CCF
24B2: D0       [142|148]        RET     NC              ; Line not found,at line after
24B3: C39924   [152]            JP      SRCHLP          ; Keep looking
                        
24B6: C0       [ 5|11]  NEW:    RET     NZ              ; Return if any more on line
24B7: 2AA340   [16]     CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
24BA: AF       [20]             XOR     A               ; Set program area to empty
24BB: 77       [27]             LD      (HL),A          ; Save LSB = 00
24BC: 23       [33]             INC     HL
24BD: 77       [40]             LD      (HL),A          ; Save MSB = 00
24BE: 23       [46]             INC     HL
24BF: 221B41   [62]             LD      (PROGND),HL     ; Set program end
                        
24C2: 2AA340   [16]     RUNFST: LD      HL,(BASTXT)     ; Clear all variables
24C5: 2B       [22]             DEC     HL
                        
24C6: 221341   [16]     INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
24C9: 2AF440   [32]             LD      HL,(LSTRAM)     ; Get end of RAM
24CC: 220841   [48]             LD      (STRBOT),HL     ; Clear string space
24CF: AF       [52]             XOR     A
24D0: CD1228   [69]             CALL    RESTOR          ; Reset DATA pointers
24D3: 2A1B41   [85]             LD      HL,(PROGND)     ; Get end of program
24D6: 221D41   [101]            LD      (VAREND),HL     ; Clear variables
24D9: 221F41   [117]            LD      (ARREND),HL     ; Clear arrays
                        
24DC: C1       [10]     CLREG:  POP     BC              ; Save return address
24DD: 2A9F40   [26]             LD      HL,(STRSPC)     ; Get end of working RAN
24E0: F9       [32]             LD      SP,HL           ; Set stack
24E1: 21F840   [42]             LD      HL,TMSTPL       ; Temporary string pool
24E4: 22F640   [58]             LD      (TMSTPT),HL     ; Reset temporary string ptr
24E7: AF       [62]             XOR     A               ; A = 00
24E8: 6F       [66]             LD      L,A             ; HL = 0000
24E9: 67       [70]             LD      H,A
24EA: 221941   [86]             LD      (CONTAD),HL     ; No CONTinue
24ED: 321041   [99]             LD      (FORFLG),A      ; Clear FOR flag
24F0: 222341   [115]            LD      (FNRGNM),HL     ; Clear FN argument
24F3: E5       [126]            PUSH    HL              ; HL = 0000
24F4: C5       [137]            PUSH    BC              ; Put back return
24F5: 2A1341   [16]     DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
24F8: C9       [26]             RET                     ; Return to execution driver
                        
24F9: 3E3F     [ 7]     PROMPT: LD      A,'?'           ; '?'
24FB: CD8326   [24]             CALL    OUTC            ; Output character
24FE: 3E20     [31]             LD      A,' '           ; Space
2500: CD8326   [48]             CALL    OUTC            ; Output character
2503: C39340   [58]             JP      RINPUT          ; Get input line
                        
2506: AF       [ 4]     CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
2507: 32F340   [17]             LD      (DATFLG),A      ; Reset literal flag
250A: 0E05     [24]             LD      C,2+3           ; 2 byte number and 3 nulls
250C: 11A640   [34]             LD      DE,BUFFER       ; Start of input buffer
250F: 7E       [ 7]     CRNCLP: LD      A,(HL)          ; Get byte
2510: FE20     [14]             CP      ' '             ; Is it a space?
2512: CA8E25   [24|24]          JP      Z,MOVDIR        ; Yes - Copy direct
2515: 47       [28]             LD      B,A             ; Save character
2516: FE22     [35]             CP      '"'             ; Is it a quote?
2518: CAAE25   [45|45]          JP      Z,CPYLIT        ; Yes - Copy literal string
251B: B7       [49]             OR      A               ; Is it end of buffer?
251C: CAB525   [59|59]          JP      Z,ENDBUF        ; Yes - End buffer
251F: 3AF340   [72]             LD      A,(DATFLG)      ; Get data type
2522: B7       [76]             OR      A               ; Literal?
2523: 7E       [83]             LD      A,(HL)          ; Get byte to copy
2524: C28E25   [93|93]          JP      NZ,MOVDIR       ; Literal - Copy direct
2527: FE3F     [100]            CP      '?'             ; Is it '?' short for PRINT
2529: 3E9E     [107]            LD      A,ZPRINT        ; "PRINT" token
252B: CA8E25   [117|117]        JP      Z,MOVDIR        ; Yes - replace it
252E: 7E       [124]            LD      A,(HL)          ; Get byte again
252F: FE30     [131]            CP      '0'             ; Is it less than '0'
2531: DA3925   [141|141]        JP      C,FNDWRD        ; Yes - Look for reserved words
2534: FE3C     [148]            CP      60; ";"+1           ; Is it "0123456789:;" ?
2536: DA8E25   [158|158]        JP      C,MOVDIR        ; Yes - copy it direct
2539: D5       [11]     FNDWRD: PUSH    DE              ; Look for reserved words
253A: 113221   [21]             LD      DE,WORDS-1      ; Point to table
253D: C5       [32]             PUSH    BC              ; Save count
253E: 018A25   [42]             LD      BC,RETNAD       ; Where to return to
2541: C5       [53]             PUSH    BC              ; Save return address
2542: 067F     [60]             LD      B,ZEND-1        ; First token value -1
2544: 7E       [67]             LD      A,(HL)          ; Get byte
2545: FE61     [74]             CP      'a'             ; Less than 'a' ?
2547: DA5225   [84|84]          JP      C,SEARCH        ; Yes - search for words
254A: FE7B     [91]             CP      'z'+1           ; Greater than 'z' ?
254C: D25225   [101|101]        JP      NC,SEARCH       ; Yes - search for words
254F: E65F     [108]            AND     01011111B       ; Force upper case
2551: 77       [115]            LD      (HL),A          ; Replace byte
2552: 4E       [ 7]     SEARCH: LD      C,(HL)          ; Search for a word
2553: EB       [11]             EX      DE,HL
2554: 23       [ 6]     GETNXT: INC     HL              ; Get next reserved word
2555: B6       [13]             OR      (HL)            ; Start of word?
2556: F25425   [23|23]          JP      P,GETNXT        ; No - move on
2559: 04       [27]             INC     B               ; Increment token value
255A: 7E       [34]             LD      A, (HL)         ; Get byte from table
255B: E67F     [41]             AND     01111111B       ; Strip bit 7
255D: C8       [46|52]          RET     Z               ; Return if end of list
255E: B9       [50]             CP      C               ; Same character as in buffer?
255F: C25425   [60|60]          JP      NZ,GETNXT       ; No - get next word
2562: EB       [64]             EX      DE,HL
2563: E5       [75]             PUSH    HL              ; Save start of word
                        
2564: 13       [ 6]     NXTBYT: INC     DE              ; Look through rest of word
2565: 1A       [13]             LD      A,(DE)          ; Get byte from table
2566: B7       [17]             OR      A               ; End of word ?
2567: FA8625   [27|27]          JP      M,MATCH         ; Yes - Match found
256A: 4F       [31]             LD      C,A             ; Save it
256B: 78       [35]             LD      A,B             ; Get token value
256C: FE88     [42]             CP      ZGOTO           ; Is it "GOTO" token ?
256E: C27525   [52|52]          JP      NZ,NOSPC        ; No - Don't allow spaces
2571: CD0228   [69]             CALL    GETCHR          ; Get next character
2574: 2B       [75]             DEC     HL              ; Cancel increment from GETCHR
2575: 23       [ 6]     NOSPC:  INC     HL              ; Next byte
2576: 7E       [13]             LD      A,(HL)          ; Get byte
2577: FE61     [20]             CP      'a'             ; Less than 'a' ?
2579: DA7E25   [30|30]          JP      C,NOCHNG        ; Yes - don't change
257C: E65F     [37]             AND     01011111B       ; Make upper case
257E: B9       [ 4]     NOCHNG: CP      C               ; Same as in buffer ?
257F: CA6425   [14|14]          JP      Z,NXTBYT        ; Yes - keep testing
2582: E1       [24]             POP     HL              ; Get back start of word
2583: C35225   [34]             JP      SEARCH          ; Look at next word
                        
2586: 48       [ 4]     MATCH:  LD      C,B             ; Word found - Save token value
2587: F1       [14]             POP     AF              ; Throw away return
2588: EB       [18]             EX      DE,HL
2589: C9       [28]             RET                     ; Return to "RETNAD"
258A: EB       [ 4]     RETNAD: EX      DE,HL           ; Get address in string
258B: 79       [ 8]             LD      A,C             ; Get token value
258C: C1       [18]             POP     BC              ; Restore buffer length
258D: D1       [28]             POP     DE              ; Get destination address
258E: 23       [ 6]     MOVDIR: INC     HL              ; Next source in buffer
258F: 12       [13]             LD      (DE),A          ; Put byte in buffer
2590: 13       [19]             INC     DE              ; Move up buffer
2591: 0C       [23]             INC     C               ; Increment length of buffer
2592: D63A     [30]             SUB     ':'             ; End of statement?
2594: CA9C25   [40|40]          JP      Z,SETLIT        ; Jump if multi-statement line
2597: FE49     [47]             CP      ZDATA-3AH       ; Is it DATA statement ?
2599: C29F25   [57|57]          JP      NZ,TSTREM       ; No - see if REM
259C: 32F340   [13]     SETLIT: LD      (DATFLG),A      ; Set literal flag
259F: D654     [ 7]     TSTREM: SUB     ZREM-3AH        ; Is it REM?
25A1: C20F25   [17|17]          JP      NZ,CRNCLP       ; No - Leave flag
25A4: 47       [21]             LD      B,A             ; Copy rest of buffer
25A5: 7E       [ 7]     NXTCHR: LD      A,(HL)          ; Get byte
25A6: B7       [11]             OR      A               ; End of line ?
25A7: CAB525   [21|21]          JP      Z,ENDBUF        ; Yes - Terminate buffer
25AA: B8       [25]             CP      B               ; End of statement ?
25AB: CA8E25   [35|35]          JP      Z,MOVDIR        ; Yes - Get next one
25AE: 23       [ 6]     CPYLIT: INC     HL              ; Move up source string
25AF: 12       [13]             LD      (DE),A          ; Save in destination
25B0: 0C       [17]             INC     C               ; Increment length
25B1: 13       [23]             INC     DE              ; Move up destination
25B2: C3A525   [33]             JP      NXTCHR          ; Repeat
                        
25B5: 21A540   [10]     ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
25B8: 12       [17]             LD      (DE),A          ; Mark end of buffer (A = 00)
25B9: 13       [23]             INC     DE
25BA: 12       [30]             LD      (DE),A          ; A = 00
25BB: 13       [36]             INC     DE
25BC: 12       [43]             LD      (DE),A          ; A = 00
25BD: C9       [53]             RET
                        
25BE: 3A8940   [13]     DODEL:  LD      A,(NULFLG)      ; Get null flag status
25C1: B7       [17]             OR      A               ; Is it zero?
25C2: 3E00     [24]             LD      A,0             ; Zero A - Leave flags
25C4: 328940   [37]             LD      (NULFLG),A      ; Zero null flag
25C7: C2D225   [47|47]          JP      NZ,ECHDEL       ; Set - Echo it
25CA: 05       [51]             DEC     B               ; Decrement length
25CB: CAEF25   [61|61]          JP      Z,GETLIN        ; Get line again if empty
25CE: CD8326   [78]             CALL    OUTC            ; Output null character
25D1: 3E                        .BYTE   3EH             ; Skip "DEC B"
25D2: 05       [ 4]     ECHDEL: DEC     B               ; Count bytes in buffer
25D3: 2B       [10]             DEC     HL              ; Back space buffer
25D4: CAE625   [20|20]          JP      Z,OTKLN         ; No buffer - Try again
25D7: 7E       [27]             LD      A,(HL)          ; Get deleted byte
25D8: CD8326   [44]             CALL    OUTC            ; Echo it
25DB: C3F825   [54]             JP      MORINP          ; Get more input
                        
25DE: 05       [ 4]     DELCHR: DEC     B               ; Count bytes in buffer
25DF: 2B       [10]             DEC     HL              ; Back space buffer
25E0: CD8326   [27]             CALL    OUTC            ; Output character in A
25E3: C2F825   [37|37]          JP      NZ,MORINP       ; Not end - Get more
25E6: CD8326   [17]     OTKLN:  CALL    OUTC            ; Output character in A
25E9: CDB12A   [17]     KILIN:  CALL    PRNTCRLF        ; Output CRLF
25EC: C3EF25   [27]             JP      TTYLIN          ; Get line again
                        
25EF:                   GETLIN:
25EF: 21A640   [10]     TTYLIN: LD      HL,BUFFER       ; Get a line by character
25F2: 0601     [17]             LD      B,1             ; Set buffer as empty
25F4: AF       [21]             XOR     A
25F5: 328940   [34]             LD      (NULFLG),A      ; Clear null flag
25F8: CDAD26   [17]     MORINP: CALL    CLOTST          ; Get character and test ^O
25FB: 4F       [21]             LD      C,A             ; Save character in C
25FC: FE7F     [28]             CP      DEL             ; Delete character?
25FE: CABE25   [38|38]          JP      Z,DODEL         ; Yes - Process it
2601: 3A8940   [51]             LD      A,(NULFLG)      ; Get null flag
2604: B7       [55]             OR      A               ; Test null flag status
2605: CA1126   [65|65]          JP      Z,PROCES        ; Reset - Process character
2608: 3E00     [72]             LD      A,0             ; Set a null
260A: CD8326   [89]             CALL    OUTC            ; Output null
260D: AF       [93]             XOR     A               ; Clear A
260E: 328940   [106]            LD      (NULFLG),A      ; Reset null flag
2611: 79       [ 4]     PROCES: LD      A,C             ; Get character
2612: FE07     [11]             CP      CTRLG           ; Bell?
2614: CA5526   [21|21]          JP      Z,PUTCTL        ; Yes - Save it
2617: FE03     [28]             CP      CTRLC           ; Is it control "C"?
2619: CCB12A   [38|45]          CALL    Z,PRNTCRLF      ; Yes - Output CRLF
261C: 37       [42]             SCF                     ; Flag break
261D: C8       [47|53]          RET     Z               ; Return if control "C"
261E: FE0D     [54]             CP      CR              ; Is it enter?
2620: CAAC2A   [64|64]          JP      Z,ENDINP        ; Yes - Terminate input
2623: FE15     [71]             CP      CTRLU           ; Is it control "U"?
2625: CAE925   [81|81]          JP      Z,KILIN         ; Yes - Get another line
2628: FE40     [88]             CP      '@'             ; Is it "kill line"?
262A: CAE625   [98|98]          JP      Z,OTKLN         ; Yes - Kill line
262D: FE5F     [105]            CP      '_'             ; Is it delete?
262F: CADE25   [115|115]        JP      Z,DELCHR        ; Yes - Delete character
2632: FE08     [122]            CP      BKSP            ; Is it backspace?
2634: CADE25   [132|132]        JP      Z,DELCHR        ; Yes - Delete character
2637: FE12     [139]            CP      CTRLR           ; Is it control "R"?
2639: C25026   [149|149]        JP      NZ,PUTBUF       ; No - Put in buffer
263C: C5       [160]            PUSH    BC              ; Save buffer length
263D: D5       [171]            PUSH    DE              ; Save DE
263E: E5       [182]            PUSH    HL              ; Save buffer address
263F: 3600     [192]            LD      (HL),0          ; Mark end of buffer
2641: CD703C   [209]            CALL    OUTNCR          ; Output and do CRLF
2644: 21A640   [219]            LD      HL,BUFFER       ; Point to buffer start
2647: CD4F31   [236]            CALL    PRS             ; Output buffer
264A: E1       [246]            POP     HL              ; Restore buffer address
264B: D1       [256]            POP     DE              ; Restore DE
264C: C1       [266]            POP     BC              ; Restore buffer length
264D: C3F825   [276]            JP      MORINP          ; Get another character
                        
2650: FE20     [ 7]     PUTBUF: CP      ' '             ; Is it a control code?
2652: DAF825   [17|17]          JP      C,MORINP        ; Yes - Ignore
2655: 78       [ 4]     PUTCTL: LD      A,B             ; Get number of bytes in buffer
2656: FE49     [11]             CP      72+1            ; Test for line overflow
2658: 3E07     [18]             LD      A,CTRLG         ; Set a bell
265A: D26A26   [28|28]          JP      NC,OUTNBS       ; Ring bell if buffer full
265D: 79       [32]             LD      A,C             ; Get character
265E: 71       [39]             LD      (HL),C          ; Save in buffer
265F: 321141   [52]             LD      (LSTBIN),A      ; Save last input byte
2662: 23       [58]             INC     HL              ; Move up buffer
2663: 04       [62]             INC     B               ; Increment length
2664: CD8326   [17]     OUTIT:  CALL    OUTC            ; Output the character entered
2667: C3F825   [27]             JP      MORINP          ; Get another character
                        
266A: CD8326   [17]     OUTNBS: CALL    OUTC            ; Output bell and back over it
266D: 3E08     [24]             LD      A,BKSP          ; Set back space
266F: C36426   [34]             JP      OUTIT           ; Output it and get more
                        
2672: 7C       [ 4]     CPDEHL: LD      A,H             ; Get H
2673: 92       [ 8]             SUB     D               ; Compare with D
2674: C0       [13|19]          RET     NZ              ; Different - Exit
2675: 7D       [17]             LD      A,L             ; Get L
2676: 93       [21]             SUB     E               ; Compare with E
2677: C9       [31]             RET                     ; Return status
                        
2678: 7E       [ 7]     CHKSYN: LD      A,(HL)          ; Check syntax of character
2679: E3       [26]             EX      (SP),HL         ; Address of test byte
267A: BE       [33]             CP      (HL)            ; Same as in code string?
267B: 23       [39]             INC     HL              ; Return address
267C: E3       [58]             EX      (SP),HL         ; Put it back
267D: CA0228   [68|68]          JP      Z,GETCHR        ; Yes - Get next character
2680: C3AA23   [78]             JP      SNERR           ; Different - ?SN Error
                        
2683: F5       [11]     OUTC:   PUSH    AF              ; Save character
2684: 3A8A40   [24]             LD      A,(CTLOFG)      ; Get control "O" flag
2687: B7       [28]             OR      A               ; Is it set?
2688: C28431   [38|38]          JP      NZ,POPAF        ; Yes - don't output
268B: F1       [48]             POP     AF              ; Restore character
268C: C5       [59]             PUSH    BC              ; Save buffer length
268D: F5       [70]             PUSH    AF              ; Save character
268E: FE20     [77]             CP      ' '             ; Is it a control code?
2690: DAA726   [87|87]          JP      C,DINPOS        ; Yes - Don't INC POS(X)
2693: 3A8740   [100]            LD      A,(LWIDTH)      ; Get line width
2696: 47       [104]            LD      B,A             ; To B
2697: 3AF040   [117]            LD      A,(CURPOS)      ; Get cursor position
269A: 04       [121]            INC     B               ; Width 255?
269B: CAA326   [131|131]        JP      Z,INCLEN        ; Yes - No width limit
269E: 05       [135]            DEC     B               ; Restore width
269F: B8       [139]            CP      B               ; At end of line?
26A0: CCB12A   [149|156]        CALL    Z,PRNTCRLF      ; Yes - output CRLF
26A3: 3C       [ 4]     INCLEN: INC     A               ; Move on one character
26A4: 32F040   [17]             LD      (CURPOS),A      ; Save new position
26A7: F1       [10]     DINPOS: POP     AF              ; Restore character
26A8: C1       [20]             POP     BC              ; Restore buffer length
26A9: CD513C   [37]             CALL    MONOUT          ; Send it
26AC: C9       [47]             RET
                        
26AD: CD0E3B   [17]     CLOTST: CALL    GETINP          ; Get input character
26B0: E67F     [24]             AND     01111111B       ; Strip bit 7
26B2: FE0F     [31]             CP      CTRLO           ; Is it control "O"?
26B4: C0       [36|42]          RET     NZ              ; No don't flip flag
26B5: 3A8A40   [49]             LD      A,(CTLOFG)      ; Get flag
26B8: 2F       [53]             CPL                     ; Flip it
26B9: 328A40   [66]             LD      (CTLOFG),A      ; Put it back
26BC: AF       [70]             XOR     A               ; Null character
26BD: C9       [80]             RET
                        
26BE: CDD528   [17]     LIST:   CALL    ATOH            ; ASCII number to DE
26C1: C0       [22|28]          RET     NZ              ; Return if anything extra
26C2: C1       [32]             POP     BC              ; Rubbish - Not needed
26C3: CD9624   [49]             CALL    SRCHLN          ; Search for line number in DE
26C6: C5       [60]             PUSH    BC              ; Save address of line
26C7: CD1427   [77]             CALL    SETLIN          ; Set up lines counter
26CA: E1       [10]     LISTLP: POP     HL              ; Restore address of line
26CB: 4E       [17]             LD      C,(HL)          ; Get LSB of next line
26CC: 23       [23]             INC     HL
26CD: 46       [30]             LD      B,(HL)          ; Get MSB of next line
26CE: 23       [36]             INC     HL
26CF: 78       [40]             LD      A,B             ; BC = 0 (End of program)?
26D0: B1       [44]             OR      C
26D1: CAF523   [54|54]          JP      Z,PRNTOK        ; Yes - Go to command mode
26D4: CD1D27   [71]             CALL    COUNT           ; Count lines
26D7: CD2D28   [88]             CALL    TSTBRK          ; Test for break key
26DA: C5       [99]             PUSH    BC              ; Save address of next line
26DB: CDB12A   [116]            CALL    PRNTCRLF        ; Output CRLF
26DE: 5E       [123]            LD      E,(HL)          ; Get LSB of line number
26DF: 23       [129]            INC     HL
26E0: 56       [136]            LD      D,(HL)          ; Get MSB of line number
26E1: 23       [142]            INC     HL
26E2: E5       [153]            PUSH    HL              ; Save address of line start
26E3: EB       [157]            EX      DE,HL           ; Line number to HL
26E4: CDF237   [174]            CALL    PRNTHL          ; Output line number in decimal
26E7: 3E20     [181]            LD      A,' '           ; Space after line number
26E9: E1       [191]            POP     HL              ; Restore start of line address
26EA: CD8326   [17]     LSTLP2: CALL    OUTC            ; Output character in A
26ED: 7E       [ 7]     LSTLP3: LD      A,(HL)          ; Get next byte in line
26EE: B7       [11]             OR      A               ; End of line?
26EF: 23       [17]             INC     HL              ; To next byte in line
26F0: CACA26   [27|27]          JP      Z,LISTLP        ; Yes - get next line
26F3: F2EA26   [37|37]          JP      P,LSTLP2        ; No token - output it
26F6: D67F     [44]             SUB     ZEND-1          ; Find and output word
26F8: 4F       [48]             LD      C,A             ; Token offset+1 to C
26F9: 113321   [58]             LD      DE,WORDS        ; Reserved word list
26FC: 1A       [ 7]     FNDTOK: LD      A,(DE)          ; Get character in list
26FD: 13       [13]             INC     DE              ; Move on to next
26FE: B7       [17]             OR      A               ; Is it start of word?
26FF: F2FC26   [27|27]          JP      P,FNDTOK        ; No - Keep looking for word
2702: 0D       [31]             DEC     C               ; Count words
2703: C2FC26   [41|41]          JP      NZ,FNDTOK       ; Not there - keep looking
2706: E67F     [ 7]     OUTWRD: AND     01111111B       ; Strip bit 7
2708: CD8326   [24]             CALL    OUTC            ; Output first character
270B: 1A       [31]             LD      A,(DE)          ; Get next character
270C: 13       [37]             INC     DE              ; Move on to next
270D: B7       [41]             OR      A               ; Is it end of word?
270E: F20627   [51|51]          JP      P,OUTWRD        ; No - output the rest
2711: C3ED26   [61]             JP      LSTLP3          ; Next byte in line
                        
2714: E5       [11]     SETLIN: PUSH    HL              ; Set up LINES counter
2715: 2A8D40   [27]             LD      HL,(LINESN)     ; Get LINES number
2718: 228B40   [43]             LD      (LINESC),HL     ; Save in LINES counter
271B: E1       [53]             POP     HL
271C: C9       [63]             RET
                        
271D: E5       [11]     COUNT:  PUSH    HL              ; Save code string address
271E: D5       [22]             PUSH    DE
271F: 2A8B40   [38]             LD      HL,(LINESC)     ; Get LINES counter
2722: 11FFFF   [48]             LD      DE,-1
2725: ED5A     [63]             ADC     HL,DE           ; Decrement
2727: 228B40   [79]             LD      (LINESC),HL     ; Put it back
272A: D1       [89]             POP     DE
272B: E1       [99]             POP     HL              ; Restore code string address
272C: F0       [104|110]        RET     P               ; Return if more lines to go
272D: E5       [115]            PUSH    HL              ; Save code string address
272E: 2A8D40   [131]            LD      HL,(LINESN)     ; Get LINES number
2731: 228B40   [147]            LD      (LINESC),HL     ; Reset LINES counter
2734: CD0E3B   [164]            CALL    GETINP          ; Get input character
2737: FE03     [171]            CP      CTRLC           ; Is it control "C"?
2739: CA4027   [181|181]        JP      Z,RSLNBK        ; Yes - Reset LINES and break
273C: E1       [191]            POP     HL              ; Restore code string address
273D: C31D27   [201]            JP      COUNT           ; Keep on counting
                        
2740: 2A8D40   [16]     RSLNBK: LD      HL,(LINESN)     ; Get LINES number
2743: 228B40   [32]             LD      (LINESC),HL     ; Reset LINES counter
2746: C3A420   [42]             JP      BRKRET          ; Go and output "Break"
                        
2749: 3E64     [ 7]     FOR:    LD      A,64H           ; Flag "FOR" assignment
274B: 321041   [20]             LD      (FORFLG),A      ; Save "FOR" flag
274E: CDB729   [37]             CALL    LET             ; Set up initial index
2751: C1       [47]             POP     BC              ; Drop RETurn address
2752: E5       [58]             PUSH    HL              ; Save code string address
2753: CDA029   [75]             CALL    DATA            ; Get next statement address
2756: 220C41   [91]             LD      (LOOPST),HL     ; Save it for start of loop
2759: 210200   [101]            LD      HL,2            ; Offset for "FOR" block
275C: 39       [112]            ADD     HL,SP           ; Point to it
275D: CD5723   [17]     FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
2760: D1       [27]             POP     DE              ; Get code string address
2761: C27927   [37|37]          JP      NZ,FORFND       ; No nesting found
2764: 09       [48]             ADD     HL,BC           ; Move into "FOR" block
2765: D5       [59]             PUSH    DE              ; Save code string address
2766: 2B       [65]             DEC     HL
2767: 56       [72]             LD      D,(HL)          ; Get MSB of loop statement
2768: 2B       [78]             DEC     HL
2769: 5E       [85]             LD      E,(HL)          ; Get LSB of loop statement
276A: 23       [91]             INC     HL
276B: 23       [97]             INC     HL
276C: E5       [108]            PUSH    HL              ; Save block address
276D: 2A0C41   [124]            LD      HL,(LOOPST)     ; Get address of loop statement
2770: CD7226   [141]            CALL    CPDEHL          ; Compare the FOR loops
2773: E1       [151]            POP     HL              ; Restore block address
2774: C25D27   [161|161]        JP      NZ,FORSLP       ; Different FORs - Find another
2777: D1       [171]            POP     DE              ; Restore code string address
2778: F9       [177]            LD      SP,HL           ; Remove all nested loops
                        
2779: EB       [ 4]     FORFND: EX      DE,HL           ; Code string address to HL
277A: 0E08     [11]             LD      C,8
277C: CD8723   [28]             CALL    CHKSTK          ; Check for 8 levels of stack
277F: E5       [39]             PUSH    HL              ; Save code string address
2780: 2A0C41   [55]             LD      HL,(LOOPST)     ; Get first statement of loop
2783: E3       [74]             EX      (SP),HL         ; Save and restore code string
2784: E5       [85]             PUSH    HL              ; Re-save code string address
2785: 2AA140   [101]            LD      HL,(LINEAT)     ; Get current line number
2788: E3       [120]            EX      (SP),HL         ; Save and restore code string
2789: CD792C   [137]            CALL    TSTNUM          ; Make sure it's a number
278C: CD7826   [154]            CALL    CHKSYN          ; Make sure "TO" is next
278F: A6                        .BYTE   ZTO          ; "TO" token
2790: CD762C   [171]            CALL    GETNUM          ; Get "TO" expression value
2793: E5       [182]            PUSH    HL              ; Save code string address
2794: CDA436   [199]            CALL    BCDEFP          ; Move "TO" value to BCDE
2797: E1       [209]            POP     HL              ; Restore code string address
2798: C5       [220]            PUSH    BC              ; Save "TO" value in block
2799: D5       [231]            PUSH    DE
279A: 010081   [241]            LD      BC,8100H        ; BCDE - 1 (default STEP)
279D: 51       [245]            LD      D,C             ; C=0
279E: 5A       [249]            LD      E,D             ; D=0
279F: 7E       [256]            LD      A,(HL)          ; Get next byte in code string
27A0: FEAB     [263]            CP      ZSTEP           ; See if "STEP" is stated
27A2: 3E01     [270]            LD      A,1             ; Sign of step = 1
27A4: C2B527   [280|280]        JP      NZ,SAVSTP       ; No STEP given - Default to 1
27A7: CD0228   [297]            CALL    GETCHR          ; Jump over "STEP" token
27AA: CD762C   [314]            CALL    GETNUM          ; Get step value
27AD: E5       [325]            PUSH    HL              ; Save code string address
27AE: CDA436   [342]            CALL    BCDEFP          ; Move STEP to BCDE
27B1: CD5836   [359]            CALL    TSTSGN          ; Test sign of FPREG
27B4: E1       [369]            POP     HL              ; Restore code string address
27B5: C5       [11]     SAVSTP: PUSH    BC              ; Save the STEP value in block
27B6: D5       [22]             PUSH    DE
27B7: F5       [33]             PUSH    AF              ; Save sign of STEP
27B8: 33       [39]             INC     SP              ; Don't save flags
27B9: E5       [50]             PUSH    HL              ; Save code string address
27BA: 2A1341   [66]             LD      HL,(BRKLIN)     ; Get address of index variable
27BD: E3       [85]             EX      (SP),HL         ; Save and restore code string
27BE: 0681     [ 7]     PUTFID: LD      B,ZFOR          ; "FOR" block marker
27C0: C5       [18]             PUSH    BC              ; Save it
27C1: 33       [24]             INC     SP              ; Don't save C
                        
27C2: CD2D28   [17]     RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
27C5: 221341   [33]             LD      (BRKLIN),HL     ; Save code address for break
27C8: 7E       [40]             LD      A,(HL)          ; Get next byte in code string
27C9: FE3A     [47]             CP      ':'             ; Multi statement line?
27CB: CAE227   [57|57]          JP      Z,EXCUTE        ; Yes - Execute it
27CE: B7       [61]             OR      A               ; End of line?
27CF: C2AA23   [71|71]          JP      NZ,SNERR        ; No - Syntax error
27D2: 23       [77]             INC     HL              ; Point to address of next line
27D3: 7E       [84]             LD      A,(HL)          ; Get LSB of line pointer
27D4: 23       [90]             INC     HL
27D5: B6       [97]             OR      (HL)            ; Is it zero (End of prog)?
27D6: CA5B28   [107|107]        JP      Z,ENDPRG        ; Yes - Terminate execution
27D9: 23       [113]            INC     HL              ; Point to line number
27DA: 5E       [120]            LD      E,(HL)          ; Get LSB of line number
27DB: 23       [126]            INC     HL
27DC: 56       [133]            LD      D,(HL)          ; Get MSB of line number
27DD: EB       [137]            EX      DE,HL           ; Line number to HL
27DE: 22A140   [153]            LD      (LINEAT),HL     ; Save as current line number
27E1: EB       [157]            EX      DE,HL           ; Line number back to DE
27E2: CD0228   [17]     EXCUTE: CALL    GETCHR          ; Get key word
27E5: 11C227   [27]             LD      DE,RUNCNT       ; Where to RETurn to
27E8: D5       [38]             PUSH    DE              ; Save for RETurn
27E9: C8       [ 5|11]  IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
27EA: D680     [ 7]     ONJMP:  SUB     ZEND            ; Is it a token?
27EC: DAB729   [17|17]          JP      C,LET           ; No - try to assign it
27EF: FE25     [24]             CP      ZNEW+1-ZEND     ; END to NEW ?
27F1: D2AA23   [34|34]          JP      NC,SNERR        ; Not a key word - ?SN Error
27F4: 07       [38]             RLCA                    ; Double it
27F5: 4F       [42]             LD      C,A             ; BC = Offset into table
27F6: 0600     [49]             LD      B,0
27F8: EB       [53]             EX      DE,HL           ; Save code string address
27F9: 215222   [63]             LD      HL,WORDTB       ; Keyword address table
27FC: 09       [74]             ADD     HL,BC           ; Point to routine address
27FD: 4E       [81]             LD      C,(HL)          ; Get LSB of routine address
27FE: 23       [87]             INC     HL
27FF: 46       [94]             LD      B,(HL)          ; Get MSB of routine address
2800: C5       [105]            PUSH    BC              ; Save routine address
2801: EB       [109]            EX      DE,HL           ; Restore code string address
                        
2802: 23       [ 6]     GETCHR: INC     HL              ; Point to next character
2803: 7E       [13]             LD      A,(HL)          ; Get next code string byte
2804: FE3A     [20]             CP      ':'             ; Z if ':'
2806: D0       [25|31]          RET     NC              ; NC if > "9"
2807: FE20     [32]             CP      ' '
2809: CA0228   [42|42]          JP      Z,GETCHR        ; Skip over spaces
280C: FE30     [49]             CP      '0'
280E: 3F       [53]             CCF                     ; NC if < '0'
280F: 3C       [57]             INC     A               ; Test for zero - Leave carry
2810: 3D       [61]             DEC     A               ; Z if Null
2811: C9       [71]             RET
                        
2812: EB       [ 4]     RESTOR: EX      DE,HL           ; Save code string address
2813: 2AA340   [20]             LD      HL,(BASTXT)     ; Point to start of program
2816: CA2728   [30|30]          JP      Z,RESTNL        ; Just RESTORE - reset pointer
2819: EB       [34]             EX      DE,HL           ; Restore code string address
281A: CDD528   [51]             CALL    ATOH            ; Get line number to DE
281D: E5       [62]             PUSH    HL              ; Save code string address
281E: CD9624   [79]             CALL    SRCHLN          ; Search for line number in DE
2821: 60       [83]             LD      H,B             ; HL = Address of line
2822: 69       [87]             LD      L,C
2823: D1       [97]             POP     DE              ; Restore code string address
2824: D27629   [107|107]        JP      NC,ULERR        ; ?UL Error if not found
2827: 2B       [ 6]     RESTNL: DEC     HL              ; Byte before DATA statement
2828: 222141   [16]     UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
282B: EB       [20]             EX      DE,HL           ; Restore code string address
282C: C9       [30]             RET
                        
                        
282D: DB22     [11]     TSTBRK: in	a, (PORT_SIOACTL) ; Check input status
282F: CB47     [19]     	bit	SIORR0_IDX_RCA, a
2831: C8       [24|30]          RET     Z               ; No key, go back
2832: CD0E3B   [41]             CALL	GETINP          ; Get the key into A
2835: FE1B     [48]             CP      ESC             ; Escape key?
2837: 2813     [55|60]          JR      Z,BRK           ; Yes, break
2839: FE03     [62]             CP      CTRLC           ; <Ctrl-C>
283B: 280F     [69|74]          JR      Z,BRK           ; Yes, break
283D: FE13     [76]             CP      CTRLS           ; Stop scrolling?
283F: C0       [81|87]          RET     NZ              ; Other key, ignore
                        
                        
2840: CD0E3B   [17]     STALL:  CALL	GETINP          ; Wait for key
2843: FE11     [24]             CP      CTRLQ           ; Resume scrolling?
2845: C8       [29|35]          RET      Z              ; Release the chokehold
2846: FE03     [36]             CP      CTRLC           ; Second break?
2848: 2807     [43|48]          JR      Z,STOP          ; Break during hold exits prog
284A: 18F4     [55]             JR      STALL           ; Loop until <Ctrl-Q> or <brk>
                        
284C: 3EFF     [ 7]     BRK     LD      A,$FF           ; Set BRKFLG
284E: 329240   [20]             LD      (BRKFLG),A      ; Store it
                        
                        
2851: C0       [ 5|11]  STOP:   RET     NZ              ; Exit if anything else
2852: F6                        .BYTE   0F6H            ; Flag "STOP"
2853: C0       [ 5|11]  PEND:   RET     NZ              ; Exit if anything else
2854: 221341   [21]             LD      (BRKLIN),HL     ; Save point of break
2857: 21                        .BYTE   21H             ; Skip "OR 11111111B"
2858: F6FF     [ 7]     INPBRK: OR      11111111B       ; Flag "Break" wanted
285A: C1       [17]             POP     BC              ; Return not needed and more
285B: 2AA140   [16]     ENDPRG: LD      HL,(LINEAT)     ; Get current line number
285E: F5       [27]             PUSH    AF              ; Save STOP / END status
285F: 7D       [31]             LD      A,L             ; Is it direct break?
2860: A4       [35]             AND     H
2861: 3C       [39]             INC     A               ; Line is -1 if direct break
2862: CA6E28   [49|49]          JP      Z,NOLIN         ; Yes - No line number
2865: 221741   [65]             LD      (ERRLIN),HL     ; Save line of break
2868: 2A1341   [81]             LD      HL,(BRKLIN)     ; Get point of break
286B: 221941   [97]             LD      (CONTAD),HL     ; Save point to CONTinue
286E: AF       [ 4]     NOLIN:  XOR     A
286F: 328A40   [17]             LD      (CTLOFG),A      ; Enable output
2872: CDA42A   [34]             CALL    STTLIN          ; Start a new line
2875: F1       [44]             POP     AF              ; Restore STOP / END status
2876: 214D23   [54]             LD      HL,BRKMSG       ; "Break" message
2879: C2DE23   [64|64]          JP      NZ,ERRIN        ; "in line" wanted?
287C: C3F523   [74]             JP      PRNTOK          ; Go to command mode
                        
287F: 2A1941   [16]     CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
2882: 7C       [20]             LD      A,H             ; Is it zero?
2883: B5       [24]             OR      L
2884: 1E20     [31]             LD      E,CN            ; ?CN Error
2886: CABE23   [41|41]          JP      Z,ERROR         ; Yes - output "?CN Error"
2889: EB       [45]             EX      DE,HL           ; Save code string address
288A: 2A1741   [61]             LD      HL,(ERRLIN)     ; Get line of last break
288D: 22A140   [77]             LD      (LINEAT),HL     ; Set up current line number
2890: EB       [81]             EX      DE,HL           ; Restore code string address
2891: C9       [91]             RET                     ; CONTinue where left off
                        
2892: CDD733   [17]     NULL:   CALL    GETINT          ; Get integer 0-255
2895: C0       [22|28]          RET     NZ              ; Return if bad value
2896: 328640   [35]             LD      (NULLS),A       ; Set nulls number
2899: C9       [45]             RET
                        
                        
289A: E5       [11]     ACCSUM: PUSH    HL              ; Save address in array
289B: 2A8F40   [27]             LD      HL,(CHKSUM)     ; Get check sum
289E: 0600     [34]             LD      B,0             ; BC - Value of byte
28A0: 4F       [38]             LD      C,A
28A1: 09       [49]             ADD     HL,BC           ; Add byte to check sum
28A2: 228F40   [65]             LD      (CHKSUM),HL     ; Re-save check sum
28A5: E1       [75]             POP     HL              ; Restore address in array
28A6: C9       [85]             RET
                        
28A7: 7E       [ 7]     CHKLTR: LD      A,(HL)          ; Get byte
28A8: FE41     [14]             CP      'A'             ; < 'a' ?
28AA: D8       [19|25]          RET     C               ; Carry set if not letter
28AB: FE5B     [26]             CP      'Z'+1           ; > 'z' ?
28AD: 3F       [30]             CCF
28AE: C9       [40]             RET                     ; Carry set if not letter
                        
28AF: CD0228   [17]     FPSINT: CALL    GETCHR          ; Get next character
28B2: CD762C   [17]     POSINT: CALL    GETNUM          ; Get integer 0 to 32767
28B5: CD5836   [17]     DEPINT: CALL    TSTSGN          ; Test sign of FPREG
28B8: FAD028   [27|27]          JP      M,FCERR         ; Negative - ?FC Error
28BB: 3A2C41   [13]     DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
28BE: FE90     [20]             CP      80H+16          ; Exponent in range (16 bits)?
28C0: DA0037   [30|30]          JP      C,FPINT         ; Yes - convert it
28C3: 018090   [40]             LD      BC,9080H        ; BCDE = -32768
28C6: 110000   [50]             LD      DE,0000
28C9: E5       [61]             PUSH    HL              ; Save code string address
28CA: CDD336   [78]             CALL    CMPNUM          ; Compare FPREG with BCDE
28CD: E1       [88]             POP     HL              ; Restore code string address
28CE: 51       [92]             LD      D,C             ; MSB to D
28CF: C8       [97|103]         RET     Z               ; Return if in range
28D0: 1E08     [ 7]     FCERR:  LD      E,FC            ; ?FC Error
28D2: C3BE23   [17]             JP      ERROR           ; Output error-
                        
28D5: 2B       [ 6]     ATOH:   DEC     HL              ; ASCII number to DE binary
28D6: 110000   [10]     GETLN:  LD      DE,0            ; Get number to DE
28D9: CD0228   [17]     GTLNLP: CALL    GETCHR          ; Get next character
28DC: D0       [22|28]          RET     NC              ; Exit if not a digit
28DD: E5       [33]             PUSH    HL              ; Save code string address
28DE: F5       [44]             PUSH    AF              ; Save digit
28DF: 219819   [54]             LD      HL,65529/10     ; Largest number 65529
28E2: CD7226   [71]             CALL    CPDEHL          ; Number in range?
28E5: DAAA23   [81|81]          JP      C,SNERR         ; No - ?SN Error
28E8: 62       [85]             LD      H,D             ; HL = Number
28E9: 6B       [89]             LD      L,E
28EA: 19       [100]            ADD     HL,DE           ; Times 2
28EB: 29       [111]            ADD     HL,HL           ; Times 4
28EC: 19       [122]            ADD     HL,DE           ; Times 5
28ED: 29       [133]            ADD     HL,HL           ; Times 10
28EE: F1       [143]            POP     AF              ; Restore digit
28EF: D630     [150]            SUB     '0'             ; Make it 0 to 9
28F1: 5F       [154]            LD      E,A             ; DE = Value of digit
28F2: 1600     [161]            LD      D,0
28F4: 19       [172]            ADD     HL,DE           ; Add to number
28F5: EB       [176]            EX      DE,HL           ; Number to DE
28F6: E1       [186]            POP     HL              ; Restore code string address
28F7: C3D928   [196]            JP      GTLNLP          ; Go to next character
                        
28FA: CAC624   [10|10]  CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
28FD: CDB228   [27]             CALL    POSINT          ; Get integer 0 to 32767 to DE
2900: 2B       [33]             DEC     HL              ; Cancel increment
2901: CD0228   [50]             CALL    GETCHR          ; Get next character
2904: E5       [61]             PUSH    HL              ; Save code string address
2905: 2AF440   [77]             LD      HL,(LSTRAM)     ; Get end of RAM
2908: CA1D29   [87|87]          JP      Z,STORED        ; No value given - Use stored
290B: E1       [97]             POP     HL              ; Restore code string address
290C: CD7826   [114]            CALL    CHKSYN          ; Check for comma
290F: 2C                        .BYTE      ','
2910: D5       [125]            PUSH    DE              ; Save number
2911: CDB228   [142]            CALL    POSINT          ; Get integer 0 to 32767
2914: 2B       [148]            DEC     HL              ; Cancel increment
2915: CD0228   [165]            CALL    GETCHR          ; Get next character
2918: C2AA23   [175|175]        JP      NZ,SNERR        ; ?SN Error if more on line
291B: E3       [194]            EX      (SP),HL         ; Save code string address
291C: EB       [198]            EX      DE,HL           ; Number to DE
291D: 7D       [ 4]     STORED: LD      A,L             ; Get LSB of new RAM top
291E: 93       [ 8]             SUB     E               ; Subtract LSB of string space
291F: 5F       [12]             LD      E,A             ; Save LSB
2920: 7C       [16]             LD      A,H             ; Get MSB of new RAM top
2921: 9A       [20]             SBC     A,D             ; Subtract MSB of string space
2922: 57       [24]             LD      D,A             ; Save MSB
2923: DA9F23   [34|34]          JP      C,OMERR         ; ?OM Error if not enough mem
2926: E5       [45]             PUSH    HL              ; Save RAM top
2927: 2A1B41   [61]             LD      HL,(PROGND)     ; Get program end
292A: 012800   [71]             LD      BC,40           ; 40 Bytes minimum working RAM
292D: 09       [82]             ADD     HL,BC           ; Get lowest address
292E: CD7226   [99]             CALL    CPDEHL          ; Enough memory?
2931: D29F23   [109|109]        JP      NC,OMERR        ; No - ?OM Error
2934: EB       [113]            EX      DE,HL           ; RAM top to HL
2935: 229F40   [129]            LD      (STRSPC),HL     ; Set new string space
2938: E1       [139]            POP     HL              ; End of memory to use
2939: 22F440   [155]            LD      (LSTRAM),HL     ; Set new top of RAM
293C: E1       [165]            POP     HL              ; Restore code string address
293D: C3C624   [175]            JP      INTVAR          ; Initialise variables
                        
2940: CAC224   [10|10]  RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
2943: CDC624   [27]             CALL    INTVAR          ; Initialise variables
2946: 01C227   [37]             LD      BC,RUNCNT       ; Execution driver loop
2949: C35C29   [47]             JP      RUNLIN          ; RUN from line number
                        
294C: 0E03     [ 7]     GOSUB:  LD      C,3             ; 3 Levels of stack needed
294E: CD8723   [24]             CALL    CHKSTK          ; Check for 3 levels of stack
2951: C1       [34]             POP     BC              ; Get return address
2952: E5       [45]             PUSH    HL              ; Save code string for RETURN
2953: E5       [56]             PUSH    HL              ; And for GOSUB routine
2954: 2AA140   [72]             LD      HL,(LINEAT)     ; Get current line
2957: E3       [91]             EX      (SP),HL         ; Into stack - Code string out
2958: 3E8C     [98]             LD      A,ZGOSUB        ; "GOSUB" token
295A: F5       [109]            PUSH    AF              ; Save token
295B: 33       [115]            INC     SP              ; Don't save flags
                        
295C: C5       [11]     RUNLIN: PUSH    BC              ; Save return address
295D: CDD528   [17]     GOTO:   CALL    ATOH            ; ASCII number to DE binary
2960: CDA229   [34]             CALL    REM             ; Get end of line
2963: E5       [45]             PUSH    HL              ; Save end of line
2964: 2AA140   [61]             LD      HL,(LINEAT)     ; Get current line
2967: CD7226   [78]             CALL    CPDEHL          ; Line after current?
296A: E1       [88]             POP     HL              ; Restore end of line
296B: 23       [94]             INC     HL              ; Start of next line
296C: DC9924   [104|111]        CALL    C,SRCHLP        ; Line is after current line
296F: D49624   [114|121]        CALL    NC,SRCHLN       ; Line is before current line
2972: 60       [118]            LD      H,B             ; Set up code string address
2973: 69       [122]            LD      L,C
2974: 2B       [128]            DEC     HL              ; Incremented after
2975: D8       [133|139]        RET     C               ; Line found
2976: 1E0E     [ 7]     ULERR:  LD      E,UL            ; ?UL Error
2978: C3BE23   [17]             JP      ERROR           ; Output error message
                        
297B: C0       [ 5|11]  RETURN: RET     NZ              ; Return if not just RETURN
297C: 16FF     [12]             LD      D,-1            ; Flag "GOSUB" search
297E: CD5323   [29]             CALL    BAKSTK          ; Look "GOSUB" block
2981: F9       [35]             LD      SP,HL           ; Kill all FORs in subroutine
2982: FE8C     [42]             CP      ZGOSUB          ; Test for "GOSUB" token
2984: 1E04     [49]             LD      E,RG            ; ?RG Error
2986: C2BE23   [59|59]          JP      NZ,ERROR        ; Error if no "GOSUB" found
2989: E1       [69]             POP     HL              ; Get RETURN line number
298A: 22A140   [85]             LD      (LINEAT),HL     ; Save as current
298D: 23       [91]             INC     HL              ; Was it from direct statement?
298E: 7C       [95]             LD      A,H
298F: B5       [99]             OR      L               ; Return to line
2990: C29A29   [109|109]        JP      NZ,RETLIN       ; No - Return to line
2993: 3A1141   [122]            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
2996: B7       [126]            OR      A               ; If so buffer is corrupted
2997: C2F423   [136|136]        JP      NZ,POPNOK       ; Yes - Go to command mode
299A: 21C227   [10]     RETLIN: LD      HL,RUNCNT       ; Execution driver loop
299D: E3       [29]             EX      (SP),HL         ; Into stack - Code string out
299E: 3E                        .BYTE      3EH             ; Skip "POP HL"
299F: E1       [10]     NXTDTA: POP     HL              ; Restore code string address
                        
29A0: 013A              DATA:   .BYTE      01H,3AH         ; ':' End of statement
29A2: 0E00     [ 7]     REM:    LD      C,0             ; 00  End of statement
29A4: 0600     [14]             LD      B,0
29A6: 79       [ 4]     NXTSTL: LD      A,C             ; Statement and byte
29A7: 48       [ 8]             LD      C,B
29A8: 47       [12]             LD      B,A             ; Statement end byte
29A9: 7E       [ 7]     NXTSTT: LD      A,(HL)          ; Get byte
29AA: B7       [11]             OR      A               ; End of line?
29AB: C8       [16|22]          RET     Z               ; Yes - Exit
29AC: B8       [20]             CP      B               ; End of statement?
29AD: C8       [25|31]          RET     Z               ; Yes - Exit
29AE: 23       [31]             INC     HL              ; Next byte
29AF: FE22     [38]             CP      '"'             ; Literal string?
29B1: CAA629   [48|48]          JP      Z,NXTSTL        ; Yes - Look for another '"'
29B4: C3A929   [58]             JP      NXTSTT          ; Keep looking
                        
29B7: CD6C2E   [17]     LET:    CALL    GETVAR          ; Get variable name
29BA: CD7826   [34]             CALL    CHKSYN          ; Make sure "=" follows
29BD: B4                        .BYTE      ZEQUAL          ; "=" token
29BE: D5       [45]             PUSH    DE              ; Save address of variable
29BF: 3AF240   [58]             LD      A,(TYPE)        ; Get data type
29C2: F5       [69]             PUSH    AF              ; Save type
29C3: CD882C   [86]             CALL    EVAL            ; Evaluate expression
29C6: F1       [96]             POP     AF              ; Restore type
29C7: E3       [115]            EX      (SP),HL         ; Save code - Get var addr
29C8: 221341   [131]            LD      (BRKLIN),HL     ; Save address of variable
29CB: 1F       [135]            RRA                     ; Adjust type
29CC: CD7B2C   [152]            CALL    CHKTYP          ; Check types are the same
29CF: CA0A2A   [162|162]        JP      Z,LETNUM        ; Numeric - Move value
29D2: E5       [11]     LETSTR: PUSH    HL              ; Save address of string var
29D3: 2A2941   [27]             LD      HL,(FPREG)      ; Pointer to string entry
29D6: E5       [38]             PUSH    HL              ; Save it on stack
29D7: 23       [44]             INC     HL              ; Skip over length
29D8: 23       [50]             INC     HL
29D9: 5E       [57]             LD      E,(HL)          ; LSB of string address
29DA: 23       [63]             INC     HL
29DB: 56       [70]             LD      D,(HL)          ; MSB of string address
29DC: 2AA340   [86]             LD      HL,(BASTXT)     ; Point to start of program
29DF: CD7226   [103]            CALL    CPDEHL          ; Is string before program?
29E2: D2F929   [113|113]        JP      NC,CRESTR       ; Yes - Create string entry
29E5: 2A9F40   [129]            LD      HL,(STRSPC)     ; Point to string space
29E8: CD7226   [146]            CALL    CPDEHL          ; Is string literal in program?
29EB: D1       [156]            POP     DE              ; Restore address of string
29EC: D2012A   [166|166]        JP      NC,MVSTPT       ; Yes - Set up pointer
29EF: 210441   [176]            LD      HL,TMPSTR       ; Temporary string pool
29F2: CD7226   [193]            CALL    CPDEHL          ; Is string in temporary pool?
29F5: D2012A   [203|203]        JP      NC,MVSTPT       ; No - Set up pointer
29F8: 3E                        .BYTE   3EH             ; Skip "POP DE"
29F9: D1       [10]     CRESTR: POP     DE              ; Restore address of string
29FA: CDB032   [27]             CALL    BAKTMP          ; Back to last tmp-str entry
29FD: EB       [31]             EX      DE,HL           ; Address of string entry
29FE: CDE930   [48]             CALL    SAVSTR          ; Save string in string area
2A01: CDB032   [17]     MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
2A04: E1       [27]             POP     HL              ; Get string pointer
2A05: CDB336   [44]             CALL    DETHL4          ; Move string pointer to var
2A08: E1       [54]             POP     HL              ; Restore code string address
2A09: C9       [64]             RET
                        
2A0A: E5       [11]     LETNUM: PUSH    HL              ; Save address of variable
2A0B: CDB036   [28]             CALL    FPTHL           ; Move value to variable
2A0E: D1       [38]             POP     DE              ; Restore address of variable
2A0F: E1       [48]             POP     HL              ; Restore code string address
2A10: C9       [58]             RET
                        
2A11: CDD733   [17]     ON:     CALL    GETINT          ; Get integer 0-255
2A14: 7E       [24]             LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
2A15: 47       [28]             LD      B,A             ; Save in B
2A16: FE8C     [35]             CP      ZGOSUB          ; "GOSUB" token?
2A18: CA202A   [45|45]          JP      Z,ONGO          ; Yes - Find line number
2A1B: CD7826   [62]             CALL    CHKSYN          ; Make sure it's "GOTO"
2A1E: 88                        .BYTE   ZGOTO           ; "GOTO" token
2A1F: 2B       [68]             DEC     HL              ; Cancel increment
2A20: 4B       [ 4]     ONGO:   LD      C,E             ; Integer of branch value
2A21: 0D       [ 4]     ONGOLP: DEC     C               ; Count branches
2A22: 78       [ 8]             LD      A,B             ; Get "GOTO" or "GOSUB" token
2A23: CAEA27   [18|18]          JP      Z,ONJMP         ; Go to that line if right one
2A26: CDD628   [35]             CALL    GETLN           ; Get line number to DE
2A29: FE2C     [42]             CP      ','             ; Another line number?
2A2B: C0       [47|53]          RET     NZ              ; No - Drop through
2A2C: C3212A   [57]             JP      ONGOLP          ; Yes - loop
                        
2A2F: CD882C   [17]     IF:     CALL    EVAL            ; Evaluate expression
2A32: 7E       [24]             LD      A,(HL)          ; Get token
2A33: FE88     [31]             CP      ZGOTO           ; "GOTO" token?
2A35: CA3D2A   [41|41]          JP      Z,IFGO          ; Yes - Get line
2A38: CD7826   [58]             CALL    CHKSYN          ; Make sure it's "THEN"
2A3B: A9                        .BYTE      ZTHEN           ; "THEN" token
2A3C: 2B       [64]             DEC     HL              ; Cancel increment
2A3D: CD792C   [17]     IFGO:   CALL    TSTNUM          ; Make sure it's numeric
2A40: CD5836   [34]             CALL    TSTSGN          ; Test state of expression
2A43: CAA229   [44|44]          JP      Z,REM           ; False - Drop through
2A46: CD0228   [61]             CALL    GETCHR          ; Get next character
2A49: DA5D29   [71|71]          JP      C,GOTO          ; Number - GOTO that line
2A4C: C3E927   [81]             JP      IFJMP           ; Otherwise do statement
                        
2A4F: 2B       [ 6]     MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
2A50: CD0228   [23]             CALL    GETCHR          ; Get next character
2A53: CAB12A   [10|10]  PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
2A56: C8       [ 5|11]  PRNTLP: RET     Z               ; End of list - Exit
2A57: FEA5     [12]             CP      ZTAB            ; "TAB(" token?
2A59: CAE42A   [22|22]          JP      Z,DOTAB         ; Yes - Do TAB routine
2A5C: FEA8     [29]             CP      ZSPC            ; "SPC(" token?
2A5E: CAE42A   [39|39]          JP      Z,DOTAB         ; Yes - Do SPC routine
2A61: E5       [50]             PUSH    HL              ; Save code string address
2A62: FE2C     [57]             CP      ','             ; Comma?
2A64: CACD2A   [67|67]          JP      Z,DOCOM         ; Yes - Move to next zone
2A67: FE3B     [74]             CP      59 ;";"         ; Semi-colon?
2A69: CA072B   [84|84]          JP      Z,NEXITM        ; Do semi-colon routine
2A6C: C1       [94]             POP     BC              ; Code string address to BC
2A6D: CD882C   [111]            CALL    EVAL            ; Evaluate expression
2A70: E5       [122]            PUSH    HL              ; Save code string address
2A71: 3AF240   [135]            LD      A,(TYPE)        ; Get variable type
2A74: B7       [139]            OR      A               ; Is it a string variable?
2A75: C29D2A   [149|149]        JP      NZ,PRNTST       ; Yes - Output string contents
2A78: CDFD37   [166]            CALL    NUMASC          ; Convert number to text
2A7B: CD0D31   [183]            CALL    CRTST           ; Create temporary string
2A7E: 3620     [193]            LD      (HL),' '        ; Followed by a space
2A80: 2A2941   [209]            LD      HL,(FPREG)      ; Get length of output
2A83: 34       [220]            INC     (HL)            ; Plus 1 for the space
2A84: 2A2941   [236]            LD      HL,(FPREG)      ; < Not needed >
2A87: 3A8740   [249]            LD      A,(LWIDTH)      ; Get width of line
2A8A: 47       [253]            LD      B,A             ; To B
2A8B: 04       [257]            INC     B               ; Width 255 (No limit)?
2A8C: CA992A   [267|267]        JP      Z,PRNTNB        ; Yes - Output number string
2A8F: 04       [271]            INC     B               ; Adjust it
2A90: 3AF040   [284]            LD      A,(CURPOS)      ; Get cursor position
2A93: 86       [291]            ADD     A,(HL)          ; Add length of string
2A94: 3D       [295]            DEC     A               ; Adjust it
2A95: B8       [299]            CP      B               ; Will output fit on this line?
2A96: D4B12A   [309|316]        CALL    NC,PRNTCRLF     ; No - CRLF first
2A99: CD5231   [17]     PRNTNB: CALL    PRS1            ; Output string at (HL)
2A9C: AF       [21]             XOR     A               ; Skip CALL by setting 'z' flag
2A9D: C45231   [10|17]  PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
2AA0: E1       [20]             POP     HL              ; Restore code string address
2AA1: C34F2A   [30]             JP      MRPRNT          ; See if more to PRINT
                        
2AA4: 3AF040   [13]     STTLIN: LD      A,(CURPOS)      ; Make sure on new line
2AA7: B7       [17]             OR      A               ; Already at start?
2AA8: C8       [22|28]          RET     Z               ; Yes - Do nothing
2AA9: C3B12A   [32]             JP      PRNTCRLF        ; Start a new line
                        
2AAC: 3600     [10]     ENDINP: LD      (HL),0          ; Mark end of buffer
2AAE: 21A540   [20]             LD      HL,BUFFER-1     ; Point to buffer
2AB1: 3E0D     [ 7]     PRNTCRLF: LD    A,CR            ; Load a CR
2AB3: CD8326   [24]             CALL    OUTC            ; Output character
2AB6: 3E0A     [31]             LD      A,LF            ; Load a LF
2AB8: CD8326   [48]             CALL    OUTC            ; Output character
2ABB: AF       [ 4]     DONULL: XOR     A               ; Set to position 0
2ABC: 32F040   [17]             LD      (CURPOS),A      ; Store it
2ABF: 3A8640   [30]             LD      A,(NULLS)       ; Get number of nulls
2AC2: 3D       [ 4]     NULLP:  DEC     A               ; Count them
2AC3: C8       [ 9|15]          RET     Z               ; Return if done
2AC4: F5       [20]             PUSH    AF              ; Save count
2AC5: AF       [24]             XOR     A               ; Load a null
2AC6: CD8326   [41]             CALL    OUTC            ; Output it
2AC9: F1       [51]             POP     AF              ; Restore count
2ACA: C3C22A   [61]             JP      NULLP           ; Keep counting
                        
2ACD: 3A8840   [13]     DOCOM:  LD      A,(COMMAN)      ; Get comma width
2AD0: 47       [17]             LD      B,A             ; Save in B
2AD1: 3AF040   [30]             LD      A,(CURPOS)      ; Get current position
2AD4: B8       [34]             CP      B               ; Within the limit?
2AD5: D4B12A   [44|51]          CALL    NC,PRNTCRLF     ; No - output CRLF
2AD8: D2072B   [54|54]          JP      NC,NEXITM       ; Get next item
2ADB: D60E     [ 7]     ZONELP: SUB     14              ; Next zone of 14 characters
2ADD: D2DB2A   [17|17]          JP      NC,ZONELP       ; Repeat if more zones
2AE0: 2F       [21]             CPL                     ; Number of spaces to output
2AE1: C3FC2A   [31]             JP      ASPCS           ; Output them
                        
2AE4: F5       [11]     DOTAB:  PUSH    AF              ; Save token
2AE5: CDD433   [28]             CALL    FNDNUM          ; Evaluate expression
2AE8: CD7826   [45]             CALL    CHKSYN          ; Make sure ")" follows
2AEB: 29                        .BYTE   ")"
2AEC: 2B       [51]             DEC     HL              ; Back space on to ")"
2AED: F1       [61]             POP     AF              ; Restore token
2AEE: D6A8     [68]             SUB     ZSPC            ; Was it "SPC(" ?
2AF0: E5       [79]             PUSH    HL              ; Save code string address
2AF1: CAF72A   [89|89]          JP      Z,DOSPC         ; Yes - Do 'E' spaces
2AF4: 3AF040   [102]            LD      A,(CURPOS)      ; Get current position
2AF7: 2F       [ 4]     DOSPC:  CPL                     ; Number of spaces to print to
2AF8: 83       [ 8]             ADD     A,E             ; Total number to print
2AF9: D2072B   [18|18]          JP      NC,NEXITM       ; TAB < Current POS(X)
2AFC: 3C       [ 4]     ASPCS:  INC     A               ; Output A spaces
2AFD: 47       [ 8]             LD      B,A             ; Save number to print
2AFE: 3E20     [15]             LD      A,' '           ; Space
2B00: CD8326   [17]     SPCLP:  CALL    OUTC            ; Output character in A
2B03: 05       [21]             DEC     B               ; Count them
2B04: C2002B   [31|31]          JP      NZ,SPCLP        ; Repeat if more
2B07: E1       [10]     NEXITM: POP     HL              ; Restore code string address
2B08: CD0228   [27]             CALL    GETCHR          ; Get next character
2B0B: C3562A   [37]             JP      PRNTLP          ; More to print
                        
2B0E: 3F526564          REDO:   .BYTE   "?Redo from start",CR,LF,0
2B12: 6F206672          
2B16: 6F6D2073          
2B1A: 74617274          
2B1E: 0D0A00            
                        
2B21: 3A1241   [13]     BADINP: LD      A,(READFG)      ; READ or INPUT?
2B24: B7       [17]             OR      A
2B25: C2A423   [27|27]          JP      NZ,DATSNR       ; READ - ?SN Error
2B28: C1       [37]             POP     BC              ; Throw away code string addr
2B29: 210E2B   [47]             LD      HL,REDO         ; "Redo from start" message
2B2C: CD4F31   [64]             CALL    PRS             ; Output string
2B2F: C3F524   [74]             JP      DOAGN           ; Do last INPUT again
                        
2B32: CDBA30   [17]     INPUT:  CALL    IDTEST          ; Test for illegal direct
2B35: 7E       [24]             LD      A,(HL)          ; Get character after "INPUT"
2B36: FE22     [31]             CP      '"'             ; Is there a prompt string?
2B38: 3E00     [38]             LD      A,0             ; Clear A and leave flags
2B3A: 328A40   [51]             LD      (CTLOFG),A      ; Enable output
2B3D: C24C2B   [61|61]          JP      NZ,NOPMPT       ; No prompt - get input
2B40: CD0E31   [78]             CALL    QTSTR           ; Get string terminated by '"'
2B43: CD7826   [95]             CALL    CHKSYN          ; Check for ';' after prompt
2B46: 3B                        .BYTE   ';'
2B47: E5       [106]            PUSH    HL              ; Save code string address
2B48: CD5231   [123]            CALL    PRS1            ; Output prompt string
2B4B: 3E                        .BYTE   3EH             ; Skip "PUSH HL"
2B4C: E5       [11]     NOPMPT: PUSH    HL              ; Save code string address
2B4D: CDF924   [28]             CALL    PROMPT          ; Get input with "? " prompt
2B50: C1       [38]             POP     BC              ; Restore code string address
2B51: DA5828   [48|48]          JP      C,INPBRK        ; Break pressed - Exit
2B54: 23       [54]             INC     HL              ; Next byte
2B55: 7E       [61]             LD      A,(HL)          ; Get it
2B56: B7       [65]             OR      A               ; End of line?
2B57: 2B       [71]             DEC     HL              ; Back again
2B58: C5       [82]             PUSH    BC              ; Re-save code string address
2B59: CA9F29   [92|92]          JP      Z,NXTDTA        ; Yes - Find next DATA stmt
2B5C: 362C     [102]            LD      (HL),','        ; Store comma as separator
2B5E: C3662B   [112]            JP      NXTITM          ; Get next item
                        
2B61: E5       [11]     READ:   PUSH    HL              ; Save code string address
2B62: 2A2141   [27]             LD      HL,(NXTDAT)     ; Next DATA statement
2B65: F6                        .BYTE   0F6H            ; Flag "READ"
2B66: AF       [ 4]     NXTITM: XOR     A               ; Flag "INPUT"
2B67: 321241   [17]             LD      (READFG),A      ; Save "READ"/"INPUT" flag
2B6A: E3       [36]             EX      (SP),HL         ; Get code str' , Save pointer
2B6B: C3722B   [46]             JP      GTVLUS          ; Get values
                        
2B6E: CD7826   [17]     NEDMOR: CALL    CHKSYN          ; Check for comma between items
2B71: 2C                        .BYTE      ','
2B72: CD6C2E   [17]     GTVLUS: CALL    GETVAR          ; Get variable name
2B75: E3       [36]             EX      (SP),HL         ; Save code str" , Get pointer
2B76: D5       [47]             PUSH    DE              ; Save variable address
2B77: 7E       [54]             LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
2B78: FE2C     [61]             CP      ','             ; Comma?
2B7A: CA9A2B   [71|71]          JP      Z,ANTVLU        ; Yes - Get another value
2B7D: 3A1241   [84]             LD      A,(READFG)      ; Is it READ?
2B80: B7       [88]             OR      A
2B81: C2072C   [98|98]          JP      NZ,FDTLP        ; Yes - Find next DATA stmt
2B84: 3E3F     [105]            LD      A,'?'           ; More INPUT needed
2B86: CD8326   [122]            CALL    OUTC            ; Output character
2B89: CDF924   [139]            CALL    PROMPT          ; Get INPUT with prompt
2B8C: D1       [149]            POP     DE              ; Variable address
2B8D: C1       [159]            POP     BC              ; Code string address
2B8E: DA5828   [169|169]        JP      C,INPBRK        ; Break pressed
2B91: 23       [175]            INC     HL              ; Point to next DATA byte
2B92: 7E       [182]            LD      A,(HL)          ; Get byte
2B93: B7       [186]            OR      A               ; Is it zero (No input) ?
2B94: 2B       [192]            DEC     HL              ; Back space INPUT pointer
2B95: C5       [203]            PUSH    BC              ; Save code string address
2B96: CA9F29   [213|213]        JP      Z,NXTDTA        ; Find end of buffer
2B99: D5       [224]            PUSH    DE              ; Save variable address
2B9A: 3AF240   [13]     ANTVLU: LD      A,(TYPE)        ; Check data type
2B9D: B7       [17]             OR      A               ; Is it numeric?
2B9E: CAC42B   [27|27]          JP      Z,INPBIN        ; Yes - Convert to binary
2BA1: CD0228   [44]             CALL    GETCHR          ; Get next character
2BA4: 57       [48]             LD      D,A             ; Save input character
2BA5: 47       [52]             LD      B,A             ; Again
2BA6: FE22     [59]             CP      '"'             ; Start of literal sting?
2BA8: CAB82B   [69|69]          JP      Z,STRENT        ; Yes - Create string entry
2BAB: 3A1241   [82]             LD      A,(READFG)      ; "READ" or "INPUT" ?
2BAE: B7       [86]             OR      A
2BAF: 57       [90]             LD      D,A             ; Save 00 if "INPUT"
2BB0: CAB52B   [100|100]        JP      Z,ITMSEP        ; "INPUT" - End with 00
2BB3: 163A     [107]            LD      D,':'           ; "DATA" - End with 00 or ':'
2BB5: 062C     [ 7]     ITMSEP: LD      B,','           ; Item separator
2BB7: 2B       [13]             DEC     HL              ; Back space for DTSTR
2BB8: CD1131   [17]     STRENT: CALL    DTSTR           ; Get string terminated by D
2BBB: EB       [21]             EX      DE,HL           ; String address to DE
2BBC: 21CF2B   [31]             LD      HL,LTSTND       ; Where to go after LETSTR
2BBF: E3       [50]             EX      (SP),HL         ; Save HL , get input pointer
2BC0: D5       [61]             PUSH    DE              ; Save address of string
2BC1: C3D229   [71]             JP      LETSTR          ; Assign string to variable
                        
2BC4: CD0228   [17]     INPBIN: CALL    GETCHR          ; Get next character
2BC7: CD5F37   [34]             CALL    ASCTFP          ; Convert ASCII to FP number
2BCA: E3       [53]             EX      (SP),HL         ; Save input ptr, Get var addr
2BCB: CDB036   [70]             CALL    FPTHL           ; Move FPREG to variable
2BCE: E1       [80]             POP     HL              ; Restore input pointer
2BCF: 2B       [ 6]     LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
2BD0: CD0228   [23]             CALL    GETCHR          ; Get next character
2BD3: CADB2B   [33|33]          JP      Z,MORDT         ; End of line - More needed?
2BD6: FE2C     [40]             CP      ','             ; Another value?
2BD8: C2212B   [50|50]          JP      NZ,BADINP       ; No - Bad input
2BDB: E3       [19]     MORDT:  EX      (SP),HL         ; Get code string address
2BDC: 2B       [25]             DEC     HL              ; DEC 'cos GETCHR INCs
2BDD: CD0228   [42]             CALL    GETCHR          ; Get next character
2BE0: C26E2B   [52|52]          JP      NZ,NEDMOR       ; More needed - Get it
2BE3: D1       [62]             POP     DE              ; Restore DATA pointer
2BE4: 3A1241   [75]             LD      A,(READFG)      ; "READ" or "INPUT" ?
2BE7: B7       [79]             OR      A
2BE8: EB       [83]             EX      DE,HL           ; DATA pointer to HL
2BE9: C22828   [93|93]          JP      NZ,UPDATA       ; Update DATA pointer if "READ"
2BEC: D5       [104]            PUSH    DE              ; Save code string address
2BED: B6       [111]            OR      (HL)            ; More input given?
2BEE: 21F62B   [121]            LD      HL,EXTIG        ; "?Extra ignored" message
2BF1: C44F31   [131|138]        CALL    NZ,PRS          ; Output string if extra given
2BF4: E1       [141]            POP     HL              ; Restore code string address
2BF5: C9       [151]            RET
                        
2BF6: 3F457874          EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
2BFA: 72612069          
2BFE: 676E6F72          
2C02: 65640D0A          
2C06: 00                
                        
2C07: CDA029   [17]     FDTLP:  CALL    DATA            ; Get next statement
2C0A: B7       [21]             OR      A               ; End of line?
2C0B: C2202C   [31|31]          JP      NZ,FANDT        ; No - See if DATA statement
2C0E: 23       [37]             INC     HL
2C0F: 7E       [44]             LD      A,(HL)          ; End of program?
2C10: 23       [50]             INC     HL
2C11: B6       [57]             OR      (HL)            ; 00 00 Ends program
2C12: 1E06     [64]             LD      E,OD            ; ?OD Error
2C14: CABE23   [74|74]          JP      Z,ERROR         ; Yes - Out of DATA
2C17: 23       [80]             INC     HL
2C18: 5E       [87]             LD      E,(HL)          ; LSB of line number
2C19: 23       [93]             INC     HL
2C1A: 56       [100]            LD      D,(HL)          ; MSB of line number
2C1B: EB       [104]            EX      DE,HL
2C1C: 220E41   [120]            LD      (DATLIN),HL     ; Set line of current DATA item
2C1F: EB       [124]            EX      DE,HL
2C20: CD0228   [17]     FANDT:  CALL    GETCHR          ; Get next character
2C23: FE83     [24]             CP      ZDATA           ; "DATA" token
2C25: C2072C   [34|34]          JP      NZ,FDTLP        ; No "DATA" - Keep looking
2C28: C39A2B   [44]             JP      ANTVLU          ; Found - Convert input
                        
2C2B: 110000   [10]     NEXT:   LD      DE,0            ; In case no index given
2C2E: C46C2E   [10|17]  NEXT1:  CALL    NZ,GETVAR       ; Get index address
2C31: 221341   [26]             LD      (BRKLIN),HL     ; Save code string address
2C34: CD5323   [43]             CALL    BAKSTK          ; Look for "FOR" block
2C37: C2B023   [53|53]          JP      NZ,NFERR        ; No "FOR" - ?NF Error
2C3A: F9       [59]             LD      SP,HL           ; Clear nested loops
2C3B: D5       [70]             PUSH    DE              ; Save index address
2C3C: 7E       [77]             LD      A,(HL)          ; Get sign of STEP
2C3D: 23       [83]             INC     HL
2C3E: F5       [94]             PUSH    AF              ; Save sign of STEP
2C3F: D5       [105]            PUSH    DE              ; Save index address
2C40: CD9636   [122]            CALL    PHLTFP          ; Move index value to FPREG
2C43: E3       [141]            EX      (SP),HL         ; Save address of TO value
2C44: E5       [152]            PUSH    HL              ; Save address of index
2C45: CD0334   [169]            CALL    ADDPHL          ; Add STEP to index value
2C48: E1       [179]            POP     HL              ; Restore address of index
2C49: CDB036   [196]            CALL    FPTHL           ; Move value to index variable
2C4C: E1       [206]            POP     HL              ; Restore address of TO value
2C4D: CDA736   [223]            CALL    LOADFP          ; Move TO value to BCDE
2C50: E5       [234]            PUSH    HL              ; Save address of line of FOR
2C51: CDD336   [251]            CALL    CMPNUM          ; Compare index with TO value
2C54: E1       [261]            POP     HL              ; Restore address of line num
2C55: C1       [271]            POP     BC              ; Address of sign of STEP
2C56: 90       [275]            SUB     B               ; Compare with expected sign
2C57: CDA736   [292]            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
2C5A: CA662C   [302|302]        JP      Z,KILFOR        ; Loop finished - Terminate it
2C5D: EB       [306]            EX      DE,HL           ; Loop statement line number
2C5E: 22A140   [322]            LD      (LINEAT),HL     ; Set loop line number
2C61: 69       [326]            LD      L,C             ; Set code string to loop
2C62: 60       [330]            LD      H,B
2C63: C3BE27   [340]            JP      PUTFID          ; Put back "FOR" and continue
                        
2C66: F9       [ 6]     KILFOR: LD      SP,HL           ; Remove "FOR" block
2C67: 2A1341   [22]             LD      HL,(BRKLIN)     ; Code string after "NEXT"
2C6A: 7E       [29]             LD      A,(HL)          ; Get next byte in code string
2C6B: FE2C     [36]             CP      ','             ; More NEXTs ?
2C6D: C2C227   [46|46]          JP      NZ,RUNCNT       ; No - Do next statement
2C70: CD0228   [63]             CALL    GETCHR          ; Position to index name
2C73: CD2E2C   [80]             CALL    NEXT1           ; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        
2C76: CD882C   [17]     GETNUM: CALL    EVAL            ; Get a numeric expression
2C79: F6                TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
2C7A: 37       [ 4]     TSTSTR: SCF                     ; Set carry (string)
2C7B: 3AF240   [13]     CHKTYP: LD      A,(TYPE)        ; Check types match
2C7E: 8F       [17]             ADC     A,A             ; Expected + actual
2C7F: B7       [21]             OR      A               ; Clear carry , set parity
2C80: E8       [26|32]          RET     PE              ; Even parity - Types match
2C81: C3BC23   [36]             JP      TMERR           ; Different types - Error
                        
2C84: CD7826   [17]     OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
2C87: 28                        .BYTE   "("
2C88: 2B       [ 6]     EVAL:   DEC     HL              ; Evaluate expression & save
2C89: 1600     [13]             LD      D,0             ; Precedence value
2C8B: D5       [11]     EVAL1:  PUSH    DE              ; Save precedence
2C8C: 0E01     [18]             LD      C,1
2C8E: CD8723   [35]             CALL    CHKSTK          ; Check for 1 level of stack
2C91: CDFF2C   [52]             CALL    OPRND           ; Get next expression value
2C94: 221541   [16]     EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
2C97: 2A1541   [16]     EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
2C9A: C1       [26]             POP     BC              ; Precedence value and operator
2C9B: 78       [30]             LD      A,B             ; Get precedence value
2C9C: FE78     [37]             CP      78H             ; "AND" or "OR" ?
2C9E: D4792C   [47|54]          CALL    NC,TSTNUM       ; No - Make sure it's a number
2CA1: 7E       [54]             LD      A,(HL)          ; Get next operator / function
2CA2: 1600     [61]             LD      D,0             ; Clear Last relation
2CA4: D6B3     [ 7]     RLTLP:  SUB     ZGTR            ; ">" Token
2CA6: DAC02C   [17|17]          JP      C,FOPRND        ; + - * / ^ AND OR - Test it
2CA9: FE03     [24]             CP      ZLTH+1-ZGTR     ; < = >
2CAB: D2C02C   [34|34]          JP      NC,FOPRND       ; Function - Call it
2CAE: FE01     [41]             CP      ZEQUAL-ZGTR     ; "="
2CB0: 17       [45]             RLA                     ; <- Test for legal
2CB1: AA       [49]             XOR     D               ; <- combinations of < = >
2CB2: BA       [53]             CP      D               ; <- by combining last token
2CB3: 57       [57]             LD      D,A             ; <- with current one
2CB4: DAAA23   [67|67]          JP      C,SNERR         ; Error if "<<' '==" or ">>"
2CB7: 220A41   [83]             LD      (CUROPR),HL     ; Save address of current token
2CBA: CD0228   [100]            CALL    GETCHR          ; Get next character
2CBD: C3A42C   [110]            JP      RLTLP           ; Treat the two as one
                        
2CC0: 7A       [ 4]     FOPRND: LD      A,D             ; < = > found ?
2CC1: B7       [ 8]             OR      A
2CC2: C2E72D   [18|18]          JP      NZ,TSTRED       ; Yes - Test for reduction
2CC5: 7E       [25]             LD      A,(HL)          ; Get operator token
2CC6: 220A41   [41]             LD      (CUROPR),HL     ; Save operator address
2CC9: D6AC     [48]             SUB     ZPLUS           ; Operator or function?
2CCB: D8       [53|59]          RET     C               ; Neither - Exit
2CCC: FE07     [60]             CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
2CCE: D0       [65|71]          RET     NC              ; No - Exit
2CCF: 5F       [69]             LD      E,A             ; Coded operator
2CD0: 3AF240   [82]             LD      A,(TYPE)        ; Get data type
2CD3: 3D       [86]             DEC     A               ; FF = numeric , 00 = string
2CD4: B3       [90]             OR      E               ; Combine with coded operator
2CD5: 7B       [94]             LD      A,E             ; Get coded operator
2CD6: CA4532   [104|104]        JP      Z,CONCAT        ; String concatenation
2CD9: 07       [108]            RLCA                    ; Times 2
2CDA: 83       [112]            ADD     A,E             ; Times 3
2CDB: 5F       [116]            LD      E,A             ; To DE (D is 0)
2CDC: 219C22   [126]            LD      HL,PRITAB       ; Precedence table
2CDF: 19       [137]            ADD     HL,DE           ; To the operator concerned
2CE0: 78       [141]            LD      A,B             ; Last operator precedence
2CE1: 56       [148]            LD      D,(HL)          ; Get evaluation precedence
2CE2: BA       [152]            CP      D               ; Compare with eval precedence
2CE3: D0       [157|163]        RET     NC              ; Exit if higher precedence
2CE4: 23       [163]            INC     HL              ; Point to routine address
2CE5: CD792C   [180]            CALL    TSTNUM          ; Make sure it's a number
                        
2CE8: C5       [11]     STKTHS: PUSH    BC              ; Save last precedence & token
2CE9: 01972C   [21]             LD      BC,EVAL3        ; Where to go on prec' break
2CEC: C5       [32]             PUSH    BC              ; Save on stack for return
2CED: 43       [36]             LD      B,E             ; Save operator
2CEE: 4A       [40]             LD      C,D             ; Save precedence
2CEF: CD8936   [57]             CALL    STAKFP          ; Move value to stack
2CF2: 58       [61]             LD      E,B             ; Restore operator
2CF3: 51       [65]             LD      D,C             ; Restore precedence
2CF4: 4E       [72]             LD      C,(HL)          ; Get LSB of routine address
2CF5: 23       [78]             INC     HL
2CF6: 46       [85]             LD      B,(HL)          ; Get MSB of routine address
2CF7: 23       [91]             INC     HL
2CF8: C5       [102]            PUSH    BC              ; Save routine address
2CF9: 2A0A41   [118]            LD      HL,(CUROPR)     ; Address of current operator
2CFC: C38B2C   [128]            JP      EVAL1           ; Loop until prec' break
                        
2CFF: AF       [ 4]     OPRND:  XOR     A               ; Get operand routine
2D00: 32F240   [17]             LD      (TYPE),A        ; Set numeric expected
2D03: CD0228   [34]             CALL    GETCHR          ; Get next character
2D06: 1E24     [41]             LD      E,MO            ; ?MO Error
2D08: CABE23   [51|51]          JP      Z,ERROR         ; No operand - Error
2D0B: DA5F37   [61|61]          JP      C,ASCTFP        ; Number - Get value
2D0E: CDA728   [78]             CALL    CHKLTR          ; See if a letter
2D11: D2662D   [88|88]          JP      NC,CONVAR       ; Letter - Find variable
2D14: FE26     [95]             CP		'&'				; &H = HEX, &B = BINARY
2D16: 2012     [102|107]        JR		NZ, NOTAMP
2D18: CD0228   [119]            CALL    GETCHR          ; Get next character
2D1B: FE48     [126]            CP      'H'             ; Hex number indicated? [function added]
2D1D: CAAA3B   [136|136]        JP      Z,HEXTFP        ; Convert Hex to FPREG
2D20: FE42     [143]            CP      'B'             ; Binary number indicated? [function added]
2D22: CA1A3C   [153|153]        JP      Z,BINTFP        ; Convert Bin to FPREG
2D25: 1E02     [160]            LD      E,SN            ; If neither then a ?SN Error
2D27: CABE23   [170|170]        JP      Z,ERROR         ; 
2D2A: FEAC     [ 7]     NOTAMP: CP      ZPLUS           ; '+' Token ?
2D2C: CAFF2C   [17|17]          JP      Z,OPRND         ; Yes - Look for operand
2D2F: FE2E     [24]             CP      '.'             ; '.' ?
2D31: CA5F37   [34|34]          JP      Z,ASCTFP        ; Yes - Create FP number
2D34: FEAD     [41]             CP      ZMINUS          ; '-' Token ?
2D36: CA552D   [51|51]          JP      Z,MINUS         ; Yes - Do minus
2D39: FE22     [58]             CP      '"'             ; Literal string ?
2D3B: CA0E31   [68|68]          JP      Z,QTSTR         ; Get string terminated by '"'
2D3E: FEAA     [75]             CP      ZNOT            ; "NOT" Token ?
2D40: CA472E   [85|85]          JP      Z,EVNOT         ; Yes - Eval NOT expression
2D43: FEA7     [92]             CP      ZFN             ; "FN" Token ?
2D45: CA7230   [102|102]        JP      Z,DOFN          ; Yes - Do FN routine
2D48: D6B6     [109]            SUB     ZSGN            ; Is it a function?
2D4A: D2772D   [119|119]        JP      NC,FNOFST       ; Yes - Evaluate function
2D4D: CD842C   [17]     EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
2D50: CD7826   [34]             CALL    CHKSYN          ; Make sure ")" follows
2D53: 29                        .BYTE   ")"
2D54: C9       [44]             RET
                        
2D55: 167D     [ 7]     MINUS:  LD      D,7DH           ; '-' precedence
2D57: CD8B2C   [24]             CALL    EVAL1           ; Evaluate until prec' break
2D5A: 2A1541   [40]             LD      HL,(NXTOPR)     ; Get next operator address
2D5D: E5       [51]             PUSH    HL              ; Save next operator address
2D5E: CD8136   [68]             CALL    INVSGN          ; Negate value
2D61: CD792C   [17]     RETNUM: CALL    TSTNUM          ; Make sure it's a number
2D64: E1       [27]             POP     HL              ; Restore next operator address
2D65: C9       [37]             RET
                        
2D66: CD6C2E   [17]     CONVAR: CALL    GETVAR          ; Get variable address to DE
2D69: E5       [11]     FRMEVL: PUSH    HL              ; Save code string address
2D6A: EB       [15]             EX      DE,HL           ; Variable address to HL
2D6B: 222941   [31]             LD      (FPREG),HL      ; Save address of variable
2D6E: 3AF240   [44]             LD      A,(TYPE)        ; Get type
2D71: B7       [48]             OR      A               ; Numeric?
2D72: CC9636   [58|65]          CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
2D75: E1       [68]             POP     HL              ; Restore code string address
2D76: C9       [78]             RET
                        
2D77: 0600     [ 7]     FNOFST: LD      B,0             ; Get address of function
2D79: 07       [11]             RLCA                    ; Double function offset
2D7A: 4F       [15]             LD      C,A             ; BC = Offset in function table
2D7B: C5       [26]             PUSH    BC              ; Save adjusted token value
2D7C: CD0228   [43]             CALL    GETCHR          ; Get next character
2D7F: 79       [47]             LD      A,C             ; Get adjusted token value
2D80: FE31     [54]             CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2D82: DA9E2D   [64|64]          JP      C,FNVAL         ; No - Do function
2D85: CD842C   [81]             CALL    OPNPAR          ; Evaluate expression  (X,...
2D88: CD7826   [98]             CALL    CHKSYN          ; Make sure ',' follows
2D8B: 2C                        .BYTE      ','
2D8C: CD7A2C   [115]            CALL    TSTSTR          ; Make sure it's a string
2D8F: EB       [119]            EX      DE,HL           ; Save code string address
2D90: 2A2941   [135]            LD      HL,(FPREG)      ; Get address of string
2D93: E3       [154]            EX      (SP),HL         ; Save address of string
2D94: E5       [165]            PUSH    HL              ; Save adjusted token value
2D95: EB       [169]            EX      DE,HL           ; Restore code string address
2D96: CDD733   [186]            CALL    GETINT          ; Get integer 0-255
2D99: EB       [190]            EX      DE,HL           ; Save code string address
2D9A: E3       [209]            EX      (SP),HL         ; Save integer,HL = adj' token
2D9B: C3A62D   [219]            JP      GOFUNC          ; Jump to string function
                        
2D9E: CD4D2D   [17]     FNVAL:  CALL    EVLPAR          ; Evaluate expression
2DA1: E3       [36]             EX      (SP),HL         ; HL = Adjusted token value
2DA2: 11612D   [46]             LD      DE,RETNUM       ; Return number from function
2DA5: D5       [57]             PUSH    DE              ; Save on stack
2DA6: 01FB20   [10]     GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2DA9: 09       [21]             ADD     HL,BC           ; Point to right address
2DAA: 4E       [28]             LD      C,(HL)          ; Get LSB of address
2DAB: 23       [34]             INC     HL              ;
2DAC: 66       [41]             LD      H,(HL)          ; Get MSB of address
2DAD: 69       [45]             LD      L,C             ; Address to HL
2DAE: E9       [49]             JP      (HL)            ; Jump to function
                        
2DAF: 15       [ 4]     SGNEXP: DEC     D               ; Dee to flag negative exponent
2DB0: FEAD     [11]             CP      ZMINUS          ; '-' token ?
2DB2: C8       [16|22]          RET     Z               ; Yes - Return
2DB3: FE2D     [23]             CP      '-'             ; '-' ASCII ?
2DB5: C8       [28|34]          RET     Z               ; Yes - Return
2DB6: 14       [32]             INC     D               ; Inc to flag positive exponent
2DB7: FE2B     [39]             CP      '+'             ; '+' ASCII ?
2DB9: C8       [44|50]          RET     Z               ; Yes - Return
2DBA: FEAC     [51]             CP      ZPLUS           ; '+' token ?
2DBC: C8       [56|62]          RET     Z               ; Yes - Return
2DBD: 2B       [62]             DEC     HL              ; DEC 'cos GETCHR INCs
2DBE: C9       [72]             RET                     ; Return "NZ"
                        
2DBF: F6                POR:    .BYTE      0F6H            ; Flag "OR"
2DC0: AF       [ 4]     PAND:   XOR     A               ; Flag "AND"
2DC1: F5       [15]             PUSH    AF              ; Save "AND" / "OR" flag
2DC2: CD792C   [32]             CALL    TSTNUM          ; Make sure it's a number
2DC5: CDBB28   [49]             CALL    DEINT           ; Get integer -32768 to 32767
2DC8: F1       [59]             POP     AF              ; Restore "AND" / "OR" flag
2DC9: EB       [63]             EX      DE,HL           ; <- Get last
2DCA: C1       [73]             POP     BC              ; <-  value
2DCB: E3       [92]             EX      (SP),HL         ; <-  from
2DCC: EB       [96]             EX      DE,HL           ; <-  stack
2DCD: CD9936   [113]            CALL    FPBCDE          ; Move last value to FPREG
2DD0: F5       [124]            PUSH    AF              ; Save "AND" / "OR" flag
2DD1: CDBB28   [141]            CALL    DEINT           ; Get integer -32768 to 32767
2DD4: F1       [151]            POP     AF              ; Restore "AND" / "OR" flag
2DD5: C1       [161]            POP     BC              ; Get value
2DD6: 79       [165]            LD      A,C             ; Get LSB
2DD7: 213030   [175]            LD      HL,ACPASS       ; Address of save AC as current
2DDA: C2E22D   [185|185]        JP      NZ,POR1         ; Jump if OR
2DDD: A3       [189]            AND     E               ; "AND" LSBs
2DDE: 4F       [193]            LD      C,A             ; Save LSB
2DDF: 78       [197]            LD      A,B             ; Get MBS
2DE0: A2       [201]            AND     D               ; "AND" MSBs
2DE1: E9       [205]            JP      (HL)            ; Save AC as current (ACPASS)
                        
2DE2: B3       [ 4]     POR1:   OR      E               ; "OR" LSBs
2DE3: 4F       [ 8]             LD      C,A             ; Save LSB
2DE4: 78       [12]             LD      A,B             ; Get MSB
2DE5: B2       [16]             OR      D               ; "OR" MSBs
2DE6: E9       [20]             JP      (HL)            ; Save AC as current (ACPASS)
                        
2DE7: 21F92D   [10]     TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2DEA: 3AF240   [23]             LD      A,(TYPE)        ; Get data type
2DED: 1F       [27]             RRA                     ; Carry set = string
2DEE: 7A       [31]             LD      A,D             ; Get last precedence value
2DEF: 17       [35]             RLA                     ; Times 2 plus carry
2DF0: 5F       [39]             LD      E,A             ; To E
2DF1: 1664     [46]             LD      D,64H           ; Relational precedence
2DF3: 78       [50]             LD      A,B             ; Get current precedence
2DF4: BA       [54]             CP      D               ; Compare with last
2DF5: D0       [59|65]          RET     NC              ; Eval if last was rel' or log'
2DF6: C3E82C   [69]             JP      STKTHS          ; Stack this one and get next
                        
2DF9: FB2D              CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2DFB: 79       [ 4]     CMPLG1: LD      A,C             ; Get data type
2DFC: B7       [ 8]             OR      A
2DFD: 1F       [12]             RRA
2DFE: C1       [22]             POP     BC              ; Get last expression to BCDE
2DFF: D1       [32]             POP     DE
2E00: F5       [43]             PUSH    AF              ; Save status
2E01: CD7B2C   [60]             CALL    CHKTYP          ; Check that types match
2E04: 213D2E   [70]             LD      HL,CMPRES       ; Result to comparison
2E07: E5       [81]             PUSH    HL              ; Save for RETurn
2E08: CAD336   [91|91]          JP      Z,CMPNUM        ; Compare values if numeric
2E0B: AF       [95]             XOR     A               ; Compare two strings
2E0C: 32F240   [108]            LD      (TYPE),A        ; Set type to numeric
2E0F: D5       [119]            PUSH    DE              ; Save string name
2E10: CD9232   [136]            CALL    GSTRCU          ; Get current string
2E13: 7E       [143]            LD      A,(HL)          ; Get length of string
2E14: 23       [149]            INC     HL
2E15: 23       [155]            INC     HL
2E16: 4E       [162]            LD      C,(HL)          ; Get LSB of address
2E17: 23       [168]            INC     HL
2E18: 46       [175]            LD      B,(HL)          ; Get MSB of address
2E19: D1       [185]            POP     DE              ; Restore string name
2E1A: C5       [196]            PUSH    BC              ; Save address of string
2E1B: F5       [207]            PUSH    AF              ; Save length of string
2E1C: CD9632   [224]            CALL    GSTRDE          ; Get second string
2E1F: CDA736   [241]            CALL    LOADFP          ; Get address of second string
2E22: F1       [251]            POP     AF              ; Restore length of string 1
2E23: 57       [255]            LD      D,A             ; Length to D
2E24: E1       [265]            POP     HL              ; Restore address of string 1
2E25: 7B       [ 4]     CMPSTR: LD      A,E             ; Bytes of string 2 to do
2E26: B2       [ 8]             OR      D               ; Bytes of string 1 to do
2E27: C8       [13|19]          RET     Z               ; Exit if all bytes compared
2E28: 7A       [17]             LD      A,D             ; Get bytes of string 1 to do
2E29: D601     [24]             SUB     1
2E2B: D8       [29|35]          RET     C               ; Exit if end of string 1
2E2C: AF       [33]             XOR     A
2E2D: BB       [37]             CP      E               ; Bytes of string 2 to do
2E2E: 3C       [41]             INC     A
2E2F: D0       [46|52]          RET     NC              ; Exit if end of string 2
2E30: 15       [50]             DEC     D               ; Count bytes in string 1
2E31: 1D       [54]             DEC     E               ; Count bytes in string 2
2E32: 0A       [61]             LD      A,(BC)          ; Byte in string 2
2E33: BE       [68]             CP      (HL)            ; Compare to byte in string 1
2E34: 23       [74]             INC     HL              ; Move up string 1
2E35: 03       [80]             INC     BC              ; Move up string 2
2E36: CA252E   [90|90]          JP      Z,CMPSTR        ; Same - Try next bytes
2E39: 3F       [94]             CCF                     ; Flag difference (">" or "<")
2E3A: C36336   [104]            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                        
2E3D: 3C       [ 4]     CMPRES: INC     A               ; Increment current value
2E3E: 8F       [ 8]             ADC     A,A             ; Double plus carry
2E3F: C1       [18]             POP     BC              ; Get other value
2E40: A0       [22]             AND     B               ; Combine them
2E41: C6FF     [29]             ADD     A,-1            ; Carry set if different
2E43: 9F       [33]             SBC     A,A             ; 00 - Equal , FF - Different
2E44: C36A36   [43]             JP      FLGREL          ; Set current value & continue
                        
2E47: 165A     [ 7]     EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2E49: CD8B2C   [24]             CALL    EVAL1           ; Eval until precedence break
2E4C: CD792C   [41]             CALL    TSTNUM          ; Make sure it's a number
2E4F: CDBB28   [58]             CALL    DEINT           ; Get integer -32768 - 32767
2E52: 7B       [62]             LD      A,E             ; Get LSB
2E53: 2F       [66]             CPL                     ; Invert LSB
2E54: 4F       [70]             LD      C,A             ; Save "NOT" of LSB
2E55: 7A       [74]             LD      A,D             ; Get MSB
2E56: 2F       [78]             CPL                     ; Invert MSB
2E57: CD3030   [95]             CALL    ACPASS          ; Save AC as current
2E5A: C1       [105]            POP     BC              ; Clean up stack
2E5B: C3972C   [115]            JP      EVAL3           ; Continue evaluation
                        
2E5E: 2B       [ 6]     DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2E5F: CD0228   [23]             CALL    GETCHR          ; Get next character
2E62: C8       [28|34]          RET     Z               ; End of DIM statement
2E63: CD7826   [45]             CALL    CHKSYN          ; Make sure ',' follows
2E66: 2C                        .BYTE      ','
2E67: 015E2E   [10]     DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2E6A: C5       [21]             PUSH    BC              ; Save on stack
2E6B: F6                        .BYTE      0F6H            ; Flag "Create" variable
2E6C: AF       [ 4]     GETVAR: XOR     A               ; Find variable address,to DE
2E6D: 32F140   [17]             LD      (LCRFLG),A      ; Set locate / create flag
2E70: 46       [24]             LD      B,(HL)          ; Get First byte of name
2E71: CDA728   [17]     GTFNAM: CALL    CHKLTR          ; See if a letter
2E74: DAAA23   [27|27]          JP      C,SNERR         ; ?SN Error if not a letter
2E77: AF       [31]             XOR     A
2E78: 4F       [35]             LD      C,A             ; Clear second byte of name
2E79: 32F240   [48]             LD      (TYPE),A        ; Set type to numeric
2E7C: CD0228   [65]             CALL    GETCHR          ; Get next character
2E7F: DA882E   [75|75]          JP      C,SVNAM2        ; Numeric - Save in name
2E82: CDA728   [92]             CALL    CHKLTR          ; See if a letter
2E85: DA952E   [102|102]        JP      C,CHARTY        ; Not a letter - Check type
2E88: 4F       [ 4]     SVNAM2: LD      C,A             ; Save second byte of name
2E89: CD0228   [17]     ENDNAM: CALL    GETCHR          ; Get next character
2E8C: DA892E   [27|27]          JP      C,ENDNAM        ; Numeric - Get another
2E8F: CDA728   [44]             CALL    CHKLTR          ; See if a letter
2E92: D2892E   [54|54]          JP      NC,ENDNAM       ; Letter - Get another
2E95: D624     [ 7]     CHARTY: SUB     '$'             ; String variable?
2E97: C2A42E   [17|17]          JP      NZ,NOTSTR       ; No - Numeric variable
2E9A: 3C       [21]             INC     A               ; A = 1 (string type)
2E9B: 32F240   [34]             LD      (TYPE),A        ; Set type to string
2E9E: 0F       [38]             RRCA                    ; A = 80H , Flag for string
2E9F: 81       [42]             ADD     A,C             ; 2nd byte of name has bit 7 on
2EA0: 4F       [46]             LD      C,A             ; Resave second byte on name
2EA1: CD0228   [63]             CALL    GETCHR          ; Get next character
2EA4: 3A1041   [13]     NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2EA7: 3D       [17]             DEC     A
2EA8: CA512F   [27|27]          JP      Z,ARLDSV        ; Yes - Get array name
2EAB: F2B42E   [37|37]          JP      P,NSCFOR        ; No array with "FOR" or "FN"
2EAE: 7E       [44]             LD      A,(HL)          ; Get byte again
2EAF: D628     [51]             SUB     '('             ; Subscripted variable?
2EB1: CA292F   [61|61]          JP      Z,SBSCPT        ; Yes - Sort out subscript
                        
2EB4: AF       [ 4]     NSCFOR: XOR     A               ; Simple variable
2EB5: 321041   [17]             LD      (FORFLG),A      ; Clear "FOR" flag
2EB8: E5       [28]             PUSH    HL              ; Save code string address
2EB9: 50       [32]             LD      D,B             ; DE = Variable name to find
2EBA: 59       [36]             LD      E,C
2EBB: 2A2341   [52]             LD      HL,(FNRGNM)     ; FN argument name
2EBE: CD7226   [69]             CALL    CPDEHL          ; Is it the FN argument?
2EC1: 112541   [79]             LD      DE,FNARG        ; Point to argument value
2EC4: CA9935   [89|89]          JP      Z,POPHRT        ; Yes - Return FN argument value
2EC7: 2A1D41   [105]            LD      HL,(VAREND)     ; End of variables
2ECA: EB       [109]            EX      DE,HL           ; Address of end of search
2ECB: 2A1B41   [125]            LD      HL,(PROGND)     ; Start of variables address
2ECE: CD7226   [17]     FNDVAR: CALL    CPDEHL          ; End of variable list table?
2ED1: CAE72E   [27|27]          JP      Z,CFEVAL        ; Yes - Called from EVAL?
2ED4: 79       [31]             LD      A,C             ; Get second byte of name
2ED5: 96       [38]             SUB     (HL)            ; Compare with name in list
2ED6: 23       [44]             INC     HL              ; Move on to first byte
2ED7: C2DC2E   [54|54]          JP      NZ,FNTHR        ; Different - Find another
2EDA: 78       [58]             LD      A,B             ; Get first byte of name
2EDB: 96       [65]             SUB     (HL)            ; Compare with name in list
2EDC: 23       [ 6]     FNTHR:  INC     HL              ; Move on to LSB of value
2EDD: CA1B2F   [16|16]          JP      Z,RETADR        ; Found - Return address
2EE0: 23       [22]             INC     HL              ; <- Skip
2EE1: 23       [28]             INC     HL              ; <- over
2EE2: 23       [34]             INC     HL              ; <- F.P.
2EE3: 23       [40]             INC     HL              ; <- value
2EE4: C3CE2E   [50]             JP      FNDVAR          ; Keep looking
                        
2EE7: E1       [10]     CFEVAL: POP     HL              ; Restore code string address
2EE8: E3       [29]             EX      (SP),HL         ; Get return address
2EE9: D5       [40]             PUSH    DE              ; Save address of variable
2EEA: 11692D   [50]             LD      DE,FRMEVL       ; Return address in EVAL
2EED: CD7226   [67]             CALL    CPDEHL          ; Called from EVAL ?
2EF0: D1       [77]             POP     DE              ; Restore address of variable
2EF1: CA1E2F   [87|87]          JP      Z,RETNUL        ; Yes - Return null variable
2EF4: E3       [106]            EX      (SP),HL         ; Put back return
2EF5: E5       [117]            PUSH    HL              ; Save code string address
2EF6: C5       [128]            PUSH    BC              ; Save variable name
2EF7: 010600   [138]            LD      BC,6            ; 2 byte name plus 4 byte data
2EFA: 2A1F41   [154]            LD      HL,(ARREND)     ; End of arrays
2EFD: E5       [165]            PUSH    HL              ; Save end of arrays
2EFE: 09       [176]            ADD     HL,BC           ; Move up 6 bytes
2EFF: C1       [186]            POP     BC              ; Source address in BC
2F00: E5       [197]            PUSH    HL              ; Save new end address
2F01: CD7623   [214]            CALL    MOVUP           ; Move arrays up
2F04: E1       [224]            POP     HL              ; Restore new end address
2F05: 221F41   [240]            LD      (ARREND),HL     ; Set new end address
2F08: 60       [244]            LD      H,B             ; End of variables to HL
2F09: 69       [248]            LD      L,C
2F0A: 221D41   [264]            LD      (VAREND),HL     ; Set new end address
                        
2F0D: 2B       [ 6]     ZEROLP: DEC     HL              ; Back through to zero variable
2F0E: 3600     [16]             LD      (HL),0          ; Zero byte in variable
2F10: CD7226   [33]             CALL    CPDEHL          ; Done them all?
2F13: C20D2F   [43|43]          JP      NZ,ZEROLP       ; No - Keep on going
2F16: D1       [53]             POP     DE              ; Get variable name
2F17: 73       [60]             LD      (HL),E          ; Store second character
2F18: 23       [66]             INC     HL
2F19: 72       [73]             LD      (HL),D          ; Store first character
2F1A: 23       [79]             INC     HL
2F1B: EB       [ 4]     RETADR: EX      DE,HL           ; Address of variable in DE
2F1C: E1       [14]             POP     HL              ; Restore code string address
2F1D: C9       [24]             RET
                        
2F1E: 322C41   [13]     RETNUL: LD      (FPEXP),A       ; Set result to zero
2F21: 214623   [23]             LD      HL,ZERBYT       ; Also set a null string
2F24: 222941   [39]             LD      (FPREG),HL      ; Save for EVAL
2F27: E1       [49]             POP     HL              ; Restore code string address
2F28: C9       [59]             RET
                        
2F29: E5       [11]     SBSCPT: PUSH    HL              ; Save code string address
2F2A: 2AF140   [27]             LD      HL,(LCRFLG)     ; Locate/Create and Type
2F2D: E3       [46]             EX      (SP),HL         ; Save and get code string
2F2E: 57       [50]             LD      D,A             ; Zero number of dimensions
2F2F: D5       [11]     SCPTLP: PUSH    DE              ; Save number of dimensions
2F30: C5       [22]             PUSH    BC              ; Save array name
2F31: CDAF28   [39]             CALL    FPSINT          ; Get subscript (0-32767)
2F34: C1       [49]             POP     BC              ; Restore array name
2F35: F1       [59]             POP     AF              ; Get number of dimensions
2F36: EB       [63]             EX      DE,HL
2F37: E3       [82]             EX      (SP),HL         ; Save subscript value
2F38: E5       [93]             PUSH    HL              ; Save LCRFLG and TYPE
2F39: EB       [97]             EX      DE,HL
2F3A: 3C       [101]            INC     A               ; Count dimensions
2F3B: 57       [105]            LD      D,A             ; Save in D
2F3C: 7E       [112]            LD      A,(HL)          ; Get next byte in code string
2F3D: FE2C     [119]            CP      ','             ; Comma (more to come)?
2F3F: CA2F2F   [129|129]        JP      Z,SCPTLP        ; Yes - More subscripts
2F42: CD7826   [146]            CALL    CHKSYN          ; Make sure ")" follows
2F45: 29                        .BYTE      ")"
2F46: 221541   [162]            LD      (NXTOPR),HL     ; Save code string address
2F49: E1       [172]            POP     HL              ; Get LCRFLG and TYPE
2F4A: 22F140   [188]            LD      (LCRFLG),HL     ; Restore Locate/create & type
2F4D: 1E00     [195]            LD      E,0             ; Flag not CSAVE* or CLOAD*
2F4F: D5       [206]            PUSH    DE              ; Save number of dimensions (D)
2F50: 11                        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
                        
2F51: E5       [11]     ARLDSV: PUSH    HL              ; Save code string address
2F52: F5       [22]             PUSH    AF              ; A = 00 , Flags set = Z,N
2F53: 2A1D41   [38]             LD      HL,(VAREND)     ; Start of arrays
2F56: 3E                        .BYTE      3EH             ; Skip "ADD HL,DE"
2F57: 19       [11]     FNDARY: ADD     HL,DE           ; Move to next array start
2F58: EB       [15]             EX      DE,HL
2F59: 2A1F41   [31]             LD      HL,(ARREND)     ; End of arrays
2F5C: EB       [35]             EX      DE,HL           ; Current array pointer
2F5D: CD7226   [52]             CALL    CPDEHL          ; End of arrays found?
2F60: CA892F   [62|62]          JP      Z,CREARY        ; Yes - Create array
2F63: 7E       [69]             LD      A,(HL)          ; Get second byte of name
2F64: B9       [73]             CP      C               ; Compare with name given
2F65: 23       [79]             INC     HL              ; Move on
2F66: C26B2F   [89|89]          JP      NZ,NXTARY       ; Different - Find next array
2F69: 7E       [96]             LD      A,(HL)          ; Get first byte of name
2F6A: B8       [100]            CP      B               ; Compare with name given
2F6B: 23       [ 6]     NXTARY: INC     HL              ; Move on
2F6C: 5E       [13]             LD      E,(HL)          ; Get LSB of next array address
2F6D: 23       [19]             INC     HL
2F6E: 56       [26]             LD      D,(HL)          ; Get MSB of next array address
2F6F: 23       [32]             INC     HL
2F70: C2572F   [42|42]          JP      NZ,FNDARY       ; Not found - Keep looking
2F73: 3AF140   [55]             LD      A,(LCRFLG)      ; Found Locate or Create it?
2F76: B7       [59]             OR      A
2F77: C2B323   [69|69]          JP      NZ,DDERR        ; Create - ?DD Error
2F7A: F1       [79]             POP     AF              ; Locate - Get number of dim'ns
2F7B: 44       [83]             LD      B,H             ; BC Points to array dim'ns
2F7C: 4D       [87]             LD      C,L
2F7D: CA9935   [97|97]          JP      Z,POPHRT        ; Jump if array load/save
2F80: 96       [104]            SUB     (HL)            ; Same number of dimensions?
2F81: CAE72F   [114|114]        JP      Z,FINDEL        ; Yes - Find element
2F84: 1E10     [ 7]     BSERR:  LD      E,BS            ; ?BS Error
2F86: C3BE23   [17]             JP      ERROR           ; Output error
                        
2F89: 110400   [10]     CREARY: LD      DE,4            ; 4 Bytes per entry
2F8C: F1       [20]             POP     AF              ; Array to save or 0 dim'ns?
2F8D: CAD028   [30|30]          JP      Z,FCERR         ; Yes - ?FC Error
2F90: 71       [37]             LD      (HL),C          ; Save second byte of name
2F91: 23       [43]             INC     HL
2F92: 70       [50]             LD      (HL),B          ; Save first byte of name
2F93: 23       [56]             INC     HL
2F94: 4F       [60]             LD      C,A             ; Number of dimensions to C
2F95: CD8723   [77]             CALL    CHKSTK          ; Check if enough memory
2F98: 23       [83]             INC     HL              ; Point to number of dimensions
2F99: 23       [89]             INC     HL
2F9A: 220A41   [105]            LD      (CUROPR),HL     ; Save address of pointer
2F9D: 71       [112]            LD      (HL),C          ; Set number of dimensions
2F9E: 23       [118]            INC     HL
2F9F: 3AF140   [131]            LD      A,(LCRFLG)      ; Locate of Create?
2FA2: 17       [135]            RLA                     ; Carry set = Create
2FA3: 79       [139]            LD      A,C             ; Get number of dimensions
2FA4: 010B00   [10]     CRARLP: LD      BC,10+1         ; Default dimension size 10
2FA7: D2AC2F   [20|20]          JP      NC,DEFSIZ       ; Locate - Set default size
2FAA: C1       [30]             POP     BC              ; Get specified dimension size
2FAB: 03       [36]             INC     BC              ; Include zero element
2FAC: 71       [ 7]     DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2FAD: 23       [13]             INC     HL
2FAE: 70       [20]             LD      (HL),B          ; Save MSB of dimension size
2FAF: 23       [26]             INC     HL
2FB0: F5       [37]             PUSH    AF              ; Save num' of dim'ns an status
2FB1: E5       [48]             PUSH    HL              ; Save address of dim'n size
2FB2: CD4437   [65]             CALL    MLDEBC          ; Multiply DE by BC to find
2FB5: EB       [69]             EX      DE,HL           ; amount of mem needed (to DE)
2FB6: E1       [79]             POP     HL              ; Restore address of dimension
2FB7: F1       [89]             POP     AF              ; Restore number of dimensions
2FB8: 3D       [93]             DEC     A               ; Count them
2FB9: C2A42F   [103|103]        JP      NZ,CRARLP       ; Do next dimension if more
2FBC: F5       [114]            PUSH    AF              ; Save locate/create flag
2FBD: 42       [118]            LD      B,D             ; MSB of memory needed
2FBE: 4B       [122]            LD      C,E             ; LSB of memory needed
2FBF: EB       [126]            EX      DE,HL
2FC0: 19       [137]            ADD     HL,DE           ; Add bytes to array start
2FC1: DA9F23   [147|147]        JP      C,OMERR         ; Too big - Error
2FC4: CD9023   [164]            CALL    ENFMEM          ; See if enough memory
2FC7: 221F41   [180]            LD      (ARREND),HL     ; Save new end of array
                        
2FCA: 2B       [ 6]     ZERARY: DEC     HL              ; Back through array data
2FCB: 3600     [16]             LD      (HL),0          ; Set array element to zero
2FCD: CD7226   [33]             CALL    CPDEHL          ; All elements zeroed?
2FD0: C2CA2F   [43|43]          JP      NZ,ZERARY       ; No - Keep on going
2FD3: 03       [49]             INC     BC              ; Number of bytes + 1
2FD4: 57       [53]             LD      D,A             ; A=0
2FD5: 2A0A41   [69]             LD      HL,(CUROPR)     ; Get address of array
2FD8: 5E       [76]             LD      E,(HL)          ; Number of dimensions
2FD9: EB       [80]             EX      DE,HL           ; To HL
2FDA: 29       [91]             ADD     HL,HL           ; Two bytes per dimension size
2FDB: 09       [102]            ADD     HL,BC           ; Add number of bytes
2FDC: EB       [106]            EX      DE,HL           ; Bytes needed to DE
2FDD: 2B       [112]            DEC     HL
2FDE: 2B       [118]            DEC     HL
2FDF: 73       [125]            LD      (HL),E          ; Save LSB of bytes needed
2FE0: 23       [131]            INC     HL
2FE1: 72       [138]            LD      (HL),D          ; Save MSB of bytes needed
2FE2: 23       [144]            INC     HL
2FE3: F1       [154]            POP     AF              ; Locate / Create?
2FE4: DA0B30   [164|164]        JP      C,ENDDIM        ; A is 0 , End if create
2FE7: 47       [ 4]     FINDEL: LD      B,A             ; Find array element
2FE8: 4F       [ 8]             LD      C,A
2FE9: 7E       [15]             LD      A,(HL)          ; Number of dimensions
2FEA: 23       [21]             INC     HL
2FEB: 16                        .BYTE      16H             ; Skip "POP HL"
2FEC: E1       [10]     FNDELP: POP     HL              ; Address of next dim' size
2FED: 5E       [17]             LD      E,(HL)          ; Get LSB of dim'n size
2FEE: 23       [23]             INC     HL
2FEF: 56       [30]             LD      D,(HL)          ; Get MSB of dim'n size
2FF0: 23       [36]             INC     HL
2FF1: E3       [55]             EX      (SP),HL         ; Save address - Get index
2FF2: F5       [66]             PUSH    AF              ; Save number of dim'ns
2FF3: CD7226   [83]             CALL    CPDEHL          ; Dimension too large?
2FF6: D2842F   [93|93]          JP      NC,BSERR        ; Yes - ?BS Error
2FF9: E5       [104]            PUSH    HL              ; Save index
2FFA: CD4437   [121]            CALL    MLDEBC          ; Multiply previous by size
2FFD: D1       [131]            POP     DE              ; Index supplied to DE
2FFE: 19       [142]            ADD     HL,DE           ; Add index to pointer
2FFF: F1       [152]            POP     AF              ; Number of dimensions
3000: 3D       [156]            DEC     A               ; Count them
3001: 44       [160]            LD      B,H             ; MSB of pointer
3002: 4D       [164]            LD      C,L             ; LSB of pointer
3003: C2EC2F   [174|174]        JP      NZ,FNDELP       ; More - Keep going
3006: 29       [185]            ADD     HL,HL           ; 4 Bytes per element
3007: 29       [196]            ADD     HL,HL
3008: C1       [206]            POP     BC              ; Start of array
3009: 09       [217]            ADD     HL,BC           ; Point to element
300A: EB       [221]            EX      DE,HL           ; Address of element to DE
300B: 2A1541   [16]     ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
300E: C9       [26]             RET
                        
300F: 2A1F41   [16]     FRE:    LD      HL,(ARREND)     ; Start of free memory
3012: EB       [20]             EX      DE,HL           ; To DE
3013: 210000   [30]             LD      HL,0            ; End of free memory
3016: 39       [41]             ADD     HL,SP           ; Current stack value
3017: 3AF240   [54]             LD      A,(TYPE)        ; Dummy argument type
301A: B7       [58]             OR      A
301B: CA2B30   [68|68]          JP      Z,FRENUM        ; Numeric - Free variable space
301E: CD9232   [85]             CALL    GSTRCU          ; Current string to pool
3021: CD9231   [102]            CALL    GARBGE          ; Garbage collection
3024: 2A9F40   [118]            LD      HL,(STRSPC)     ; Bottom of string space in use
3027: EB       [122]            EX      DE,HL           ; To DE
3028: 2A0841   [138]            LD      HL,(STRBOT)     ; Bottom of string space
302B: 7D       [ 4]     FRENUM: LD      A,L             ; Get LSB of end
302C: 93       [ 8]             SUB     E               ; Subtract LSB of beginning
302D: 4F       [12]             LD      C,A             ; Save difference if C
302E: 7C       [16]             LD      A,H             ; Get MSB of end
302F: 9A       [20]             SBC     A,D             ; Subtract MSB of beginning
3030: 41       [ 4]     ACPASS: LD      B,C             ; Return integer AC
3031: 50       [ 4]     ABPASS: LD      D,B             ; Return integer AB
3032: 1E00     [11]             LD      E,0
3034: 21F240   [21]             LD      HL,TYPE         ; Point to type
3037: 73       [28]             LD      (HL),E          ; Set type to numeric
3038: 0690     [35]             LD      B,80H+16        ; 16 bit integer
303A: C36F36   [45]             JP      RETINT          ; Return the integr
                        
303D: 3AF040   [13]     POS:    LD      A,(CURPOS)      ; Get cursor position
3040: 47       [ 4]     PASSA:  LD      B,A             ; Put A into AB
3041: AF       [ 8]             XOR     A               ; Zero A
3042: C33130   [18]             JP      ABPASS          ; Return integer AB
                        
3045: CDC830   [17]     DEF:    CALL    CHEKFN          ; Get "FN" and name
3048: CDBA30   [34]             CALL    IDTEST          ; Test for illegal direct
304B: 01A029   [44]             LD      BC,DATA         ; To get next statement
304E: C5       [55]             PUSH    BC              ; Save address for RETurn
304F: D5       [66]             PUSH    DE              ; Save address of function ptr
3050: CD7826   [83]             CALL    CHKSYN          ; Make sure "(" follows
3053: 28                        .BYTE      "("
3054: CD6C2E   [100]            CALL    GETVAR          ; Get argument variable name
3057: E5       [111]            PUSH    HL              ; Save code string address
3058: EB       [115]            EX      DE,HL           ; Argument address to HL
3059: 2B       [121]            DEC     HL
305A: 56       [128]            LD      D,(HL)          ; Get first byte of arg name
305B: 2B       [134]            DEC     HL
305C: 5E       [141]            LD      E,(HL)          ; Get second byte of arg name
305D: E1       [151]            POP     HL              ; Restore code string address
305E: CD792C   [168]            CALL    TSTNUM          ; Make sure numeric argument
3061: CD7826   [185]            CALL    CHKSYN          ; Make sure ")" follows
3064: 29                        .BYTE      ")"
3065: CD7826   [202]            CALL    CHKSYN          ; Make sure "=" follows
3068: B4                        .BYTE      ZEQUAL          ; "=" token
3069: 44       [206]            LD      B,H             ; Code string address to BC
306A: 4D       [210]            LD      C,L
306B: E3       [229]            EX      (SP),HL         ; Save code str , Get FN ptr
306C: 71       [236]            LD      (HL),C          ; Save LSB of FN code string
306D: 23       [242]            INC     HL
306E: 70       [249]            LD      (HL),B          ; Save MSB of FN code string
306F: C30731   [259]            JP      SVSTAD          ; Save address and do function
                        
3072: CDC830   [17]     DOFN:   CALL    CHEKFN          ; Make sure FN follows
3075: D5       [28]             PUSH    DE              ; Save function pointer address
3076: CD4D2D   [45]             CALL    EVLPAR          ; Evaluate expression in "()"
3079: CD792C   [62]             CALL    TSTNUM          ; Make sure numeric result
307C: E3       [81]             EX      (SP),HL         ; Save code str , Get FN ptr
307D: 5E       [88]             LD      E,(HL)          ; Get LSB of FN code string
307E: 23       [94]             INC     HL
307F: 56       [101]            LD      D,(HL)          ; Get MSB of FN code string
3080: 23       [107]            INC     HL
3081: 7A       [111]            LD      A,D             ; And function DEFined?
3082: B3       [115]            OR      E
3083: CAB623   [125|125]        JP      Z,UFERR         ; No - ?UF Error
3086: 7E       [132]            LD      A,(HL)          ; Get LSB of argument address
3087: 23       [138]            INC     HL
3088: 66       [145]            LD      H,(HL)          ; Get MSB of argument address
3089: 6F       [149]            LD      L,A             ; HL = Arg variable address
308A: E5       [160]            PUSH    HL              ; Save it
308B: 2A2341   [176]            LD      HL,(FNRGNM)     ; Get old argument name
308E: E3       [195]            EX      (SP),HL ;       ; Save old , Get new
308F: 222341   [211]            LD      (FNRGNM),HL     ; Set new argument name
3092: 2A2741   [227]            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
3095: E5       [238]            PUSH    HL              ; Save it
3096: 2A2541   [254]            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
3099: E5       [265]            PUSH    HL              ; Save it
309A: 212541   [275]            LD      HL,FNARG        ; HL = Value of argument
309D: D5       [286]            PUSH    DE              ; Save FN code string address
309E: CDB036   [303]            CALL    FPTHL           ; Move FPREG to argument
30A1: E1       [313]            POP     HL              ; Get FN code string address
30A2: CD762C   [330]            CALL    GETNUM          ; Get value from function
30A5: 2B       [336]            DEC     HL              ; DEC 'cos GETCHR INCs
30A6: CD0228   [353]            CALL    GETCHR          ; Get next character
30A9: C2AA23   [363|363]        JP      NZ,SNERR        ; Bad character in FN - Error
30AC: E1       [373]            POP     HL              ; Get MSB,EXP of old arg
30AD: 222541   [389]            LD      (FNARG),HL      ; Restore it
30B0: E1       [399]            POP     HL              ; Get LSB,NLSB of old arg
30B1: 222741   [415]            LD      (FNARG+2),HL    ; Restore it
30B4: E1       [425]            POP     HL              ; Get name of old arg
30B5: 222341   [441]            LD      (FNRGNM),HL     ; Restore it
30B8: E1       [451]            POP     HL              ; Restore code string address
30B9: C9       [461]            RET
                        
30BA: E5       [11]     IDTEST: PUSH    HL              ; Save code string address
30BB: 2AA140   [27]             LD      HL,(LINEAT)     ; Get current line number
30BE: 23       [33]             INC     HL              ; -1 means direct statement
30BF: 7C       [37]             LD      A,H
30C0: B5       [41]             OR      L
30C1: E1       [51]             POP     HL              ; Restore code string address
30C2: C0       [56|62]          RET     NZ              ; Return if in program
30C3: 1E16     [63]             LD      E,ID            ; ?ID Error
30C5: C3BE23   [73]             JP      ERROR
                        
30C8: CD7826   [17]     CHEKFN: CALL    CHKSYN          ; Make sure FN follows
30CB: A7                        .BYTE      ZFN             ; "FN" token
30CC: 3E80     [24]             LD      A,80H
30CE: 321041   [37]             LD      (FORFLG),A      ; Flag FN name to find
30D1: B6       [44]             OR      (HL)            ; FN name has bit 7 set
30D2: 47       [48]             LD      B,A             ; in first byte of name
30D3: CD712E   [65]             CALL    GTFNAM          ; Get FN name
30D6: C3792C   [75]             JP      TSTNUM          ; Make sure numeric function
                        
30D9: CD792C   [17]     STR:    CALL    TSTNUM          ; Make sure it's a number
30DC: CDFD37   [34]             CALL    NUMASC          ; Turn number into text
30DF: CD0D31   [17]     STR1:   CALL    CRTST           ; Create string entry for it
30E2: CD9232   [34]             CALL    GSTRCU          ; Current string to pool
30E5: 01ED32   [44]             LD      BC,TOPOOL       ; Save in string pool
30E8: C5       [55]             PUSH    BC              ; Save address on stack
                        
30E9: 7E       [ 7]     SAVSTR: LD      A,(HL)          ; Get string length
30EA: 23       [13]             INC     HL
30EB: 23       [19]             INC     HL
30EC: E5       [30]             PUSH    HL              ; Save pointer to string
30ED: CD6831   [47]             CALL    TESTR           ; See if enough string space
30F0: E1       [57]             POP     HL              ; Restore pointer to string
30F1: 4E       [64]             LD      C,(HL)          ; Get LSB of address
30F2: 23       [70]             INC     HL
30F3: 46       [77]             LD      B,(HL)          ; Get MSB of address
30F4: CD0131   [94]             CALL    CRTMST          ; Create string entry
30F7: E5       [105]            PUSH    HL              ; Save pointer to MSB of addr
30F8: 6F       [109]            LD      L,A             ; Length of string
30F9: CD8532   [126]            CALL    TOSTRA          ; Move to string area
30FC: D1       [136]            POP     DE              ; Restore pointer to MSB
30FD: C9       [146]            RET
                        
30FE: CD6831   [17]     MKTMST: CALL    TESTR           ; See if enough string space
3101: 210441   [10]     CRTMST: LD      HL,TMPSTR       ; Temporary string
3104: E5       [21]             PUSH    HL              ; Save it
3105: 77       [28]             LD      (HL),A          ; Save length of string
3106: 23       [34]             INC     HL
3107: 23       [ 6]     SVSTAD: INC     HL
3108: 73       [13]             LD      (HL),E          ; Save LSB of address
3109: 23       [19]             INC     HL
310A: 72       [26]             LD      (HL),D          ; Save MSB of address
310B: E1       [36]             POP     HL              ; Restore pointer
310C: C9       [46]             RET
                        
310D: 2B       [ 6]     CRTST:  DEC     HL              ; DEC - INCed after
310E: 0622     [ 7]     QTSTR:  LD      B,'"'           ; Terminating quote
3110: 50       [11]             LD      D,B             ; Quote to D
3111: E5       [11]     DTSTR:  PUSH    HL              ; Save start
3112: 0EFF     [18]             LD      C,-1            ; Set counter to -1
3114: 23       [ 6]     QTSTLP: INC     HL              ; Move on
3115: 7E       [13]             LD      A,(HL)          ; Get byte
3116: 0C       [17]             INC     C               ; Count bytes
3117: B7       [21]             OR      A               ; End of line?
3118: CA2331   [31|31]          JP      Z,CRTSTE        ; Yes - Create string entry
311B: BA       [35]             CP      D               ; Terminator D found?
311C: CA2331   [45|45]          JP      Z,CRTSTE        ; Yes - Create string entry
311F: B8       [49]             CP      B               ; Terminator B found?
3120: C21431   [59|59]          JP      NZ,QTSTLP       ; No - Keep looking
3123: FE22     [ 7]     CRTSTE: CP      '"'             ; End with '"'?
3125: CC0228   [17|24]          CALL    Z,GETCHR        ; Yes - Get next character
3128: E3       [36]             EX      (SP),HL         ; Starting quote
3129: 23       [42]             INC     HL              ; First byte of string
312A: EB       [46]             EX      DE,HL           ; To DE
312B: 79       [50]             LD      A,C             ; Get length
312C: CD0131   [67]             CALL    CRTMST          ; Create string entry
312F: 110441   [10]     TSTOPL: LD      DE,TMPSTR       ; Temporary string
3132: 2AF640   [26]             LD      HL,(TMSTPT)     ; Temporary string pool pointer
3135: 222941   [42]             LD      (FPREG),HL      ; Save address of string ptr
3138: 3E01     [49]             LD      A,1
313A: 32F240   [62]             LD      (TYPE),A        ; Set type to string
313D: CDB336   [79]             CALL    DETHL4          ; Move string to pool
3140: CD7226   [96]             CALL    CPDEHL          ; Out of string pool?
3143: 22F640   [112]            LD      (TMSTPT),HL     ; Save new pointer
3146: E1       [122]            POP     HL              ; Restore code string address
3147: 7E       [129]            LD      A,(HL)          ; Get next code byte
3148: C0       [134|140]        RET     NZ              ; Return if pool OK
3149: 1E1E     [141]            LD      E,ST            ; ?ST Error
314B: C3BE23   [151]            JP      ERROR           ; String pool overflow
                        
314E: 23       [ 6]     PRNUMS: INC     HL              ; Skip leading space
314F: CD0D31   [17]     PRS:    CALL    CRTST           ; Create string entry for it
3152: CD9232   [17]     PRS1:   CALL    GSTRCU          ; Current string to pool
3155: CDA736   [34]             CALL    LOADFP          ; Move string block to BCDE
3158: 1C       [38]             INC     E               ; Length + 1
3159: 1D       [ 4]     PRSLP:  DEC     E               ; Count characters
315A: C8       [ 9|15]          RET     Z               ; End of string
315B: 0A       [16]             LD      A,(BC)          ; Get byte to output
315C: CD8326   [33]             CALL    OUTC            ; Output character in A
315F: FE0D     [40]             CP      CR              ; Return?
3161: CCBB2A   [50|57]          CALL    Z,DONULL        ; Yes - Do nulls
3164: 03       [56]             INC     BC              ; Next byte in string
3165: C35931   [66]             JP      PRSLP           ; More characters to output
                        
3168: B7       [ 4]     TESTR:  OR      A               ; Test if enough room
3169: 0E                        .BYTE      0EH             ; No garbage collection done
316A: F1       [10]     GRBDON: POP     AF              ; Garbage collection done
316B: F5       [21]             PUSH    AF              ; Save status
316C: 2A9F40   [37]             LD      HL,(STRSPC)     ; Bottom of string space in use
316F: EB       [41]             EX      DE,HL           ; To DE
3170: 2A0841   [57]             LD      HL,(STRBOT)     ; Bottom of string area
3173: 2F       [61]             CPL                     ; Negate length (Top down)
3174: 4F       [65]             LD      C,A             ; -Length to BC
3175: 06FF     [72]             LD      B,-1            ; BC = -ve length of string
3177: 09       [83]             ADD     HL,BC           ; Add to bottom of space in use
3178: 23       [89]             INC     HL              ; Plus one for 2's complement
3179: CD7226   [106]            CALL    CPDEHL          ; Below string RAM area?
317C: DA8631   [116|116]        JP      C,TESTOS        ; Tidy up if not done else err
317F: 220841   [132]            LD      (STRBOT),HL     ; Save new bottom of area
3182: 23       [138]            INC     HL              ; Point to first byte of string
3183: EB       [142]            EX      DE,HL           ; Address to DE
3184: F1       [10]     POPAF:  POP     AF              ; Throw away status push
3185: C9       [20]             RET
                        
3186: F1       [10]     TESTOS: POP     AF              ; Garbage collect been done?
3187: 1E1A     [17]             LD      E,OS            ; ?OS Error
3189: CABE23   [27|27]          JP      Z,ERROR         ; Yes - Not enough string apace
318C: BF       [31]             CP      A               ; Flag garbage collect done
318D: F5       [42]             PUSH    AF              ; Save status
318E: 016A31   [52]             LD      BC,GRBDON       ; Garbage collection done
3191: C5       [63]             PUSH    BC              ; Save for RETurn
3192: 2AF440   [16]     GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
3195: 220841   [16]     GARBLP: LD      (STRBOT),HL     ; Reset string pointer
3198: 210000   [26]             LD      HL,0
319B: E5       [37]             PUSH    HL              ; Flag no string found
319C: 2A9F40   [53]             LD      HL,(STRSPC)     ; Get bottom of string space
319F: E5       [64]             PUSH    HL              ; Save bottom of string space
31A0: 21F840   [74]             LD      HL,TMSTPL       ; Temporary string pool
31A3: EB       [ 4]     GRBLP:  EX      DE,HL
31A4: 2AF640   [20]             LD      HL,(TMSTPT)     ; Temporary string pool pointer
31A7: EB       [24]             EX      DE,HL
31A8: CD7226   [41]             CALL    CPDEHL          ; Temporary string pool done?
31AB: 01A331   [51]             LD      BC,GRBLP        ; Loop until string pool done
31AE: C2F731   [61|61]          JP      NZ,STPOOL       ; No - See if in string area
31B1: 2A1B41   [77]             LD      HL,(PROGND)     ; Start of simple variables
31B4: EB       [ 4]     SMPVAR: EX      DE,HL
31B5: 2A1D41   [20]             LD      HL,(VAREND)     ; End of simple variables
31B8: EB       [24]             EX      DE,HL
31B9: CD7226   [41]             CALL    CPDEHL          ; All simple strings done?
31BC: CACA31   [51|51]          JP      Z,ARRLP         ; Yes - Do string arrays
31BF: 7E       [58]             LD      A,(HL)          ; Get type of variable
31C0: 23       [64]             INC     HL
31C1: 23       [70]             INC     HL
31C2: B7       [74]             OR      A               ; "S" flag set if string
31C3: CDFA31   [91]             CALL    STRADD          ; See if string in string area
31C6: C3B431   [101]            JP      SMPVAR          ; Loop until simple ones done
                        
31C9: C1       [10]     GNXARY: POP     BC              ; Scrap address of this array
31CA: EB       [ 4]     ARRLP:  EX      DE,HL
31CB: 2A1F41   [20]             LD      HL,(ARREND)     ; End of string arrays
31CE: EB       [24]             EX      DE,HL
31CF: CD7226   [41]             CALL    CPDEHL          ; All string arrays done?
31D2: CA2032   [51|51]          JP      Z,SCNEND        ; Yes - Move string if found
31D5: CDA736   [68]             CALL    LOADFP          ; Get array name to BCDE
31D8: 7B       [72]             LD      A,E             ; Get type of array     
31D9: E5       [83]             PUSH    HL              ; Save address of num of dim'ns
31DA: 09       [94]             ADD     HL,BC           ; Start of next array
31DB: B7       [98]             OR      A               ; Test type of array
31DC: F2C931   [108|108]        JP      P,GNXARY        ; Numeric array - Ignore it
31DF: 220A41   [124]            LD      (CUROPR),HL     ; Save address of next array
31E2: E1       [134]            POP     HL              ; Get address of num of dim'ns
31E3: 4E       [141]            LD      C,(HL)          ; BC = Number of dimensions
31E4: 0600     [148]            LD      B,0
31E6: 09       [159]            ADD     HL,BC           ; Two bytes per dimension size
31E7: 09       [170]            ADD     HL,BC
31E8: 23       [176]            INC     HL              ; Plus one for number of dim'ns
31E9: EB       [ 4]     GRBARY: EX      DE,HL
31EA: 2A0A41   [20]             LD      HL,(CUROPR)     ; Get address of next array
31ED: EB       [24]             EX      DE,HL
31EE: CD7226   [41]             CALL    CPDEHL          ; Is this array finished?
31F1: CACA31   [51|51]          JP      Z,ARRLP         ; Yes - Get next one
31F4: 01E931   [61]             LD      BC,GRBARY       ; Loop until array all done
31F7: C5       [11]     STPOOL: PUSH    BC              ; Save return address
31F8: F680     [18]             OR      80H             ; Flag string type
31FA: 7E       [ 7]     STRADD: LD      A,(HL)          ; Get string length
31FB: 23       [13]             INC     HL
31FC: 23       [19]             INC     HL
31FD: 5E       [26]             LD      E,(HL)          ; Get LSB of string address
31FE: 23       [32]             INC     HL
31FF: 56       [39]             LD      D,(HL)          ; Get MSB of string address
3200: 23       [45]             INC     HL
3201: F0       [50|56]          RET     P               ; Not a string - Return
3202: B7       [54]             OR      A               ; Set flags on string length
3203: C8       [59|65]          RET     Z               ; Null string - Return
3204: 44       [63]             LD      B,H             ; Save variable pointer
3205: 4D       [67]             LD      C,L
3206: 2A0841   [83]             LD      HL,(STRBOT)     ; Bottom of new area
3209: CD7226   [100]            CALL    CPDEHL          ; String been done?
320C: 60       [104]            LD      H,B             ; Restore variable pointer
320D: 69       [108]            LD      L,C
320E: D8       [113|119]        RET     C               ; String done - Ignore
320F: E1       [123]            POP     HL              ; Return address
3210: E3       [142]            EX      (SP),HL         ; Lowest available string area
3211: CD7226   [159]            CALL    CPDEHL          ; String within string area?
3214: E3       [178]            EX      (SP),HL         ; Lowest available string area
3215: E5       [189]            PUSH    HL              ; Re-save return address
3216: 60       [193]            LD      H,B             ; Restore variable pointer
3217: 69       [197]            LD      L,C
3218: D0       [202|208]        RET     NC              ; Outside string area - Ignore
3219: C1       [212]            POP     BC              ; Get return , Throw 2 away
321A: F1       [222]            POP     AF              ; 
321B: F1       [232]            POP     AF              ; 
321C: E5       [243]            PUSH    HL              ; Save variable pointer
321D: D5       [254]            PUSH    DE              ; Save address of current
321E: C5       [265]            PUSH    BC              ; Put back return address
321F: C9       [275]            RET                     ; Go to it
                        
3220: D1       [10]     SCNEND: POP     DE              ; Addresses of strings
3221: E1       [20]             POP     HL              ; 
3222: 7D       [24]             LD      A,L             ; HL = 0 if no more to do
3223: B4       [28]             OR      H
3224: C8       [33|39]          RET     Z               ; No more to do - Return
3225: 2B       [39]             DEC     HL
3226: 46       [46]             LD      B,(HL)          ; MSB of address of string
3227: 2B       [52]             DEC     HL
3228: 4E       [59]             LD      C,(HL)          ; LSB of address of string
3229: E5       [70]             PUSH    HL              ; Save variable address
322A: 2B       [76]             DEC     HL
322B: 2B       [82]             DEC     HL
322C: 6E       [89]             LD      L,(HL)          ; HL = Length of string
322D: 2600     [96]             LD      H,0
322F: 09       [107]            ADD     HL,BC           ; Address of end of string+1
3230: 50       [111]            LD      D,B             ; String address to DE
3231: 59       [115]            LD      E,C
3232: 2B       [121]            DEC     HL              ; Last byte in string
3233: 44       [125]            LD      B,H             ; Address to BC
3234: 4D       [129]            LD      C,L
3235: 2A0841   [145]            LD      HL,(STRBOT)     ; Current bottom of string area
3238: CD7923   [162]            CALL    MOVSTR          ; Move string to new address
323B: E1       [172]            POP     HL              ; Restore variable address
323C: 71       [179]            LD      (HL),C          ; Save new LSB of address
323D: 23       [185]            INC     HL
323E: 70       [192]            LD      (HL),B          ; Save new MSB of address
323F: 69       [196]            LD      L,C             ; Next string area+1 to HL
3240: 60       [200]            LD      H,B
3241: 2B       [206]            DEC     HL              ; Next string area address
3242: C39531   [216]            JP      GARBLP          ; Look for more strings
                        
3245: C5       [11]     CONCAT: PUSH    BC              ; Save prec' opr & code string
3246: E5       [22]             PUSH    HL              ; 
3247: 2A2941   [38]             LD      HL,(FPREG)      ; Get first string
324A: E3       [57]             EX      (SP),HL         ; Save first string
324B: CDFF2C   [74]             CALL    OPRND           ; Get second string
324E: E3       [93]             EX      (SP),HL         ; Restore first string
324F: CD7A2C   [110]            CALL    TSTSTR          ; Make sure it's a string
3252: 7E       [117]            LD      A,(HL)          ; Get length of second string
3253: E5       [128]            PUSH    HL              ; Save first string
3254: 2A2941   [144]            LD      HL,(FPREG)      ; Get second string
3257: E5       [155]            PUSH    HL              ; Save second string
3258: 86       [162]            ADD     A,(HL)          ; Add length of second string
3259: 1E1C     [169]            LD      E,LS            ; ?LS Error
325B: DABE23   [179|179]        JP      C,ERROR         ; String too long - Error
325E: CDFE30   [196]            CALL    MKTMST          ; Make temporary string
3261: D1       [206]            POP     DE              ; Get second string to DE
3262: CD9632   [223]            CALL    GSTRDE          ; Move to string pool if needed
3265: E3       [242]            EX      (SP),HL         ; Get first string
3266: CD9532   [259]            CALL    GSTRHL          ; Move to string pool if needed
3269: E5       [270]            PUSH    HL              ; Save first string
326A: 2A0641   [286]            LD      HL,(TMPSTR+2)   ; Temporary string address
326D: EB       [290]            EX      DE,HL           ; To DE
326E: CD7C32   [307]            CALL    SSTSA           ; First string to string area
3271: CD7C32   [324]            CALL    SSTSA           ; Second string to string area
3274: 21942C   [334]            LD      HL,EVAL2        ; Return to evaluation loop
3277: E3       [353]            EX      (SP),HL         ; Save return,get code string
3278: E5       [364]            PUSH    HL              ; Save code string address
3279: C32F31   [374]            JP      TSTOPL          ; To temporary string to pool
                        
327C: E1       [10]     SSTSA:  POP     HL              ; Return address
327D: E3       [29]             EX      (SP),HL         ; Get string block,save return
327E: 7E       [36]             LD      A,(HL)          ; Get length of string
327F: 23       [42]             INC     HL
3280: 23       [48]             INC     HL
3281: 4E       [55]             LD      C,(HL)          ; Get LSB of string address
3282: 23       [61]             INC     HL
3283: 46       [68]             LD      B,(HL)          ; Get MSB of string address
3284: 6F       [72]             LD      L,A             ; Length to L
3285: 2C       [ 4]     TOSTRA: INC     L               ; INC - DECed after
3286: 2D       [ 4]     TSALP:  DEC     L               ; Count bytes moved
3287: C8       [ 9|15]          RET     Z               ; End of string - Return
3288: 0A       [16]             LD      A,(BC)          ; Get source
3289: 12       [23]             LD      (DE),A          ; Save destination
328A: 03       [29]             INC     BC              ; Next source
328B: 13       [35]             INC     DE              ; Next destination
328C: C38632   [45]             JP      TSALP           ; Loop until string moved
                        
328F: CD7A2C   [17]     GETSTR: CALL    TSTSTR          ; Make sure it's a string
3292: 2A2941   [16]     GSTRCU: LD      HL,(FPREG)      ; Get current string
3295: EB       [ 4]     GSTRHL: EX      DE,HL           ; Save DE
3296: CDB032   [17]     GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
3299: EB       [21]             EX      DE,HL           ; Restore DE
329A: C0       [26|32]          RET     NZ              ; No - Return
329B: D5       [37]             PUSH    DE              ; Save string
329C: 50       [41]             LD      D,B             ; String block address to DE
329D: 59       [45]             LD      E,C
329E: 1B       [51]             DEC     DE              ; Point to length
329F: 4E       [58]             LD      C,(HL)          ; Get string length
32A0: 2A0841   [74]             LD      HL,(STRBOT)     ; Current bottom of string area
32A3: CD7226   [91]             CALL    CPDEHL          ; Last one in string area?
32A6: C2AE32   [101|101]        JP      NZ,POPHL        ; No - Return
32A9: 47       [105]            LD      B,A             ; Clear B (A=0)
32AA: 09       [116]            ADD     HL,BC           ; Remove string from str' area
32AB: 220841   [132]            LD      (STRBOT),HL     ; Save new bottom of str' area
32AE: E1       [10]     POPHL:  POP     HL              ; Restore string
32AF: C9       [20]             RET
                        
32B0: 2AF640   [16]     BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
32B3: 2B       [22]             DEC     HL              ; Back
32B4: 46       [29]             LD      B,(HL)          ; Get MSB of address
32B5: 2B       [35]             DEC     HL              ; Back
32B6: 4E       [42]             LD      C,(HL)          ; Get LSB of address
32B7: 2B       [48]             DEC     HL              ; Back
32B8: 2B       [54]             DEC     HL              ; Back
32B9: CD7226   [71]             CALL    CPDEHL          ; String last in string pool?
32BC: C0       [76|82]          RET     NZ              ; Yes - Leave it
32BD: 22F640   [92]             LD      (TMSTPT),HL     ; Save new string pool top
32C0: C9       [102]            RET
                        
32C1: 014030   [10]     LEN:    LD      BC,PASSA        ; To return integer A
32C4: C5       [21]             PUSH    BC              ; Save address
32C5: CD8F32   [17]     GETLEN: CALL    GETSTR          ; Get string and its length
32C8: AF       [21]             XOR     A
32C9: 57       [25]             LD      D,A             ; Clear D
32CA: 32F240   [38]             LD      (TYPE),A        ; Set type to numeric
32CD: 7E       [45]             LD      A,(HL)          ; Get length of string
32CE: B7       [49]             OR      A               ; Set status flags
32CF: C9       [59]             RET
                        
32D0: 014030   [10]     ASC:    LD      BC,PASSA        ; To return integer A
32D3: C5       [21]             PUSH    BC              ; Save address
32D4: CDC532   [17]     GTFLNM: CALL    GETLEN          ; Get length of string
32D7: CAD028   [27|27]          JP      Z,FCERR         ; Null string - Error
32DA: 23       [33]             INC     HL
32DB: 23       [39]             INC     HL
32DC: 5E       [46]             LD      E,(HL)          ; Get LSB of address
32DD: 23       [52]             INC     HL
32DE: 56       [59]             LD      D,(HL)          ; Get MSB of address
32DF: 1A       [66]             LD      A,(DE)          ; Get first byte of string
32E0: C9       [76]             RET
                        
32E1: 3E01     [ 7]     CHR:    LD      A,1             ; One character string
32E3: CDFE30   [24]             CALL    MKTMST          ; Make a temporary string
32E6: CDDA33   [41]             CALL    MAKINT          ; Make it integer A
32E9: 2A0641   [57]             LD      HL,(TMPSTR+2)   ; Get address of string
32EC: 73       [64]             LD      (HL),E          ; Save character
32ED: C1       [10]     TOPOOL: POP     BC              ; Clean up stack
32EE: C32F31   [20]             JP      TSTOPL          ; Temporary string to pool
                        
32F1: CD8A33   [17]     LEFT:   CALL    LFRGNM          ; Get number and ending ")"
32F4: AF       [21]             XOR     A               ; Start at first byte in string
32F5: E3       [19]     RIGHT1: EX      (SP),HL         ; Save code string,Get string
32F6: 4F       [23]             LD      C,A             ; Starting position in string
32F7: E5       [11]     MID1:   PUSH    HL              ; Save string block address
32F8: 7E       [18]             LD      A,(HL)          ; Get length of string
32F9: B8       [22]             CP      B               ; Compare with number given
32FA: DAFF32   [32|32]          JP      C,ALLFOL        ; All following bytes required
32FD: 78       [36]             LD      A,B             ; Get new length
32FE: 11                        .BYTE      11H             ; Skip "LD C,0"
32FF: 0E00     [ 7]     ALLFOL: LD      C,0             ; First byte of string
3301: C5       [18]             PUSH    BC              ; Save position in string
3302: CD6831   [35]             CALL    TESTR           ; See if enough string space
3305: C1       [45]             POP     BC              ; Get position in string
3306: E1       [55]             POP     HL              ; Restore string block address
3307: E5       [66]             PUSH    HL              ; And re-save it
3308: 23       [72]             INC     HL
3309: 23       [78]             INC     HL
330A: 46       [85]             LD      B,(HL)          ; Get LSB of address
330B: 23       [91]             INC     HL
330C: 66       [98]             LD      H,(HL)          ; Get MSB of address
330D: 68       [102]            LD      L,B             ; HL = address of string
330E: 0600     [109]            LD      B,0             ; BC = starting address
3310: 09       [120]            ADD     HL,BC           ; Point to that byte
3311: 44       [124]            LD      B,H             ; BC = source string
3312: 4D       [128]            LD      C,L
3313: CD0131   [145]            CALL    CRTMST          ; Create a string entry
3316: 6F       [149]            LD      L,A             ; Length of new string
3317: CD8532   [166]            CALL    TOSTRA          ; Move string to string area
331A: D1       [176]            POP     DE              ; Clear stack
331B: CD9632   [193]            CALL    GSTRDE          ; Move to string pool if needed
331E: C32F31   [203]            JP      TSTOPL          ; Temporary string to pool
                        
3321: CD8A33   [17]     RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
3324: D1       [27]             POP     DE              ; Get string length
3325: D5       [38]             PUSH    DE              ; And re-save
3326: 1A       [45]             LD      A,(DE)          ; Get length
3327: 90       [49]             SUB     B               ; Move back N bytes
3328: C3F532   [59]             JP      RIGHT1          ; Go and get sub-string
                        
332B: EB       [ 4]     MID:    EX      DE,HL           ; Get code string address
332C: 7E       [11]             LD      A,(HL)          ; Get next byte ',' or ")"
332D: CD8F33   [28]             CALL    MIDNUM          ; Get number supplied
3330: 04       [32]             INC     B               ; Is it character zero?
3331: 05       [36]             DEC     B
3332: CAD028   [46|46]          JP      Z,FCERR         ; Yes - Error
3335: C5       [57]             PUSH    BC              ; Save starting position
3336: 1EFF     [64]             LD      E,255           ; All of string
3338: FE29     [71]             CP      ')'             ; Any length given?
333A: CA4433   [81|81]          JP      Z,RSTSTR        ; No - Rest of string
333D: CD7826   [98]             CALL    CHKSYN          ; Make sure ',' follows
3340: 2C                        .BYTE      ','
3341: CDD733   [115]            CALL    GETINT          ; Get integer 0-255
3344: CD7826   [17]     RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
3347: 29                        .BYTE      ")"
3348: F1       [27]             POP     AF              ; Restore starting position
3349: E3       [46]             EX      (SP),HL         ; Get string,8ave code string
334A: 01F732   [56]             LD      BC,MID1         ; Continuation of MID$ routine
334D: C5       [67]             PUSH    BC              ; Save for return
334E: 3D       [71]             DEC     A               ; Starting position-1
334F: BE       [78]             CP      (HL)            ; Compare with length
3350: 0600     [85]             LD      B,0             ; Zero bytes length
3352: D0       [90|96]          RET     NC              ; Null string if start past end
3353: 4F       [94]             LD      C,A             ; Save starting position-1
3354: 7E       [101]            LD      A,(HL)          ; Get length of string
3355: 91       [105]            SUB     C               ; Subtract start
3356: BB       [109]            CP      E               ; Enough string for it?
3357: 47       [113]            LD      B,A             ; Save maximum length available
3358: D8       [118|124]        RET     C               ; Truncate string if needed
3359: 43       [122]            LD      B,E             ; Set specified length
335A: C9       [132]            RET                     ; Go and create string
                        
335B: CDC532   [17]     VAL:    CALL    GETLEN          ; Get length of string
335E: CA7834   [27|27]          JP      Z,RESZER        ; Result zero
3361: 5F       [31]             LD      E,A             ; Save length
3362: 23       [37]             INC     HL
3363: 23       [43]             INC     HL
3364: 7E       [50]             LD      A,(HL)          ; Get LSB of address
3365: 23       [56]             INC     HL
3366: 66       [63]             LD      H,(HL)          ; Get MSB of address
3367: 6F       [67]             LD      L,A             ; HL = String address
3368: E5       [78]             PUSH    HL              ; Save string address
3369: 19       [89]             ADD     HL,DE
336A: 46       [96]             LD      B,(HL)          ; Get end of string+1 byte
336B: 72       [103]            LD      (HL),D          ; Zero it to terminate
336C: E3       [122]            EX      (SP),HL         ; Save string end,get start
336D: C5       [133]            PUSH    BC              ; Save end+1 byte
336E: 7E       [140]            LD      A,(HL)          ; Get starting byte
336F: FE24     [147]        CP	'$'		; Hex number indicated? [function added]
3371: C27933   [157|157]    JP	NZ,VAL1
3374: CDAA3B   [174]        CALL	HEXTFP		; Convert Hex to FPREG
3377: 180D     [186]        JR	VAL3
3379: FE25     [ 7]     VAL1:	CP	'%'		; Binary number indicated? [function added]
337B: C28333   [17|17]      JP	NZ,VAL2
337E: CD1A3C   [34]         CALL	BINTFP		; Convert Bin to FPREG
3381: 1803     [46]         JR	VAL3
3383: CD5F37   [17]     VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
3386: C1       [10]     VAL3:   POP     BC              ; Restore end+1 byte
3387: E1       [20]             POP     HL              ; Restore end+1 address
3388: 70       [27]             LD      (HL),B          ; Put back original byte
3389: C9       [37]             RET
                        
338A: EB       [ 4]     LFRGNM: EX      DE,HL           ; Code string address to HL
338B: CD7826   [21]             CALL    CHKSYN          ; Make sure ")" follows
338E: 29                        .BYTE      ")"
338F: C1       [10]     MIDNUM: POP     BC              ; Get return address
3390: D1       [20]             POP     DE              ; Get number supplied
3391: C5       [31]             PUSH    BC              ; Re-save return address
3392: 43       [35]             LD      B,E             ; Number to B
3393: C9       [45]             RET
                        
3394: CDDA33   [17]     INP:    CALL    MAKINT          ; Make it integer A
3397: 328440   [30]             LD      (INPORT),A      ; Set input port
339A: CD8340   [47]             CALL    INPSUB          ; Get input from port
339D: C34030   [57]             JP      PASSA           ; Return integer A
                        
33A0: CDC433   [17]     POUT:   CALL    SETIO           ; Set up port number
33A3: C34B40   [27]             JP      OUTSUB          ; Output data and return
                        
33A6: CDC433   [17]     WAIT:   CALL    SETIO           ; Set up port number
33A9: F5       [28]             PUSH    AF              ; Save AND mask
33AA: 1E00     [35]             LD      E,0             ; Assume zero if none given
33AC: 2B       [41]             DEC     HL              ; DEC 'cos GETCHR INCs
33AD: CD0228   [58]             CALL    GETCHR          ; Get next character
33B0: CABA33   [68|68]          JP      Z,NOXOR         ; No XOR byte given
33B3: CD7826   [85]             CALL    CHKSYN          ; Make sure ',' follows
33B6: 2C                        .BYTE      ','
33B7: CDD733   [102]            CALL    GETINT          ; Get integer 0-255 to XOR with
33BA: C1       [10]     NOXOR:  POP     BC              ; Restore AND mask
33BB: CD8340   [17]     WAITLP: CALL    INPSUB          ; Get input
33BE: AB       [21]             XOR     E               ; Flip selected bits
33BF: A0       [25]             AND     B               ; Result non-zero?
33C0: CABB33   [35|35]          JP      Z,WAITLP        ; No = keep waiting
33C3: C9       [45]             RET
                        
33C4: CDD733   [17]     SETIO:  CALL    GETINT          ; Get integer 0-255
33C7: 328440   [30]             LD      (INPORT),A      ; Set input port
33CA: 324C40   [43]             LD      (OTPORT),A      ; Set output port
33CD: CD7826   [60]             CALL    CHKSYN          ; Make sure ',' follows
33D0: 2C                        .BYTE      ','
33D1: C3D733   [70]             JP      GETINT          ; Get integer 0-255 and return
                        
33D4: CD0228   [17]     FNDNUM: CALL    GETCHR          ; Get next character
33D7: CD762C   [17]     GETINT: CALL    GETNUM          ; Get a number from 0 to 255
33DA: CDB528   [17]     MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
33DD: 7A       [21]             LD      A,D             ; Get MSB of number
33DE: B7       [25]             OR      A               ; Zero?
33DF: C2D028   [35|35]          JP      NZ,FCERR        ; No - Error
33E2: 2B       [41]             DEC     HL              ; DEC 'cos GETCHR INCs
33E3: CD0228   [58]             CALL    GETCHR          ; Get next character
33E6: 7B       [62]             LD      A,E             ; Get number to A
33E7: C9       [72]             RET
                        
33E8: CDBB28   [17]     PEEK:   CALL    DEINT           ; Get memory address
33EB: 1A       [24]             LD      A,(DE)          ; Get byte in memory
33EC: C34030   [34]             JP      PASSA           ; Return integer A
                        
33EF: CD762C   [17]     POKE:   CALL    GETNUM          ; Get memory address
33F2: CDBB28   [34]             CALL    DEINT           ; Get integer -32768 to 3276
33F5: D5       [45]             PUSH    DE              ; Save memory address
33F6: CD7826   [62]             CALL    CHKSYN          ; Make sure ',' follows
33F9: 2C                        .BYTE      ','
33FA: CDD733   [79]             CALL    GETINT          ; Get integer 0-255
33FD: D1       [89]             POP     DE              ; Restore memory address
33FE: 12       [96]             LD      (DE),A          ; Load it into memory
33FF: C9       [106]            RET
                        
3400: 21D638   [10]     ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3403: CDA736   [17]     ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3406: C31234   [27]             JP      FPADD           ; Add BCDE to FPREG
                        
3409: CDA736   [17]     SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
340C: 21                        .BYTE      21H             ; Skip "POP BC" and "POP DE"
340D: C1       [10]     PSUB:   POP     BC              ; Get FP number from stack
340E: D1       [20]             POP     DE
340F: CD8136   [17]     SUBCDE: CALL    INVSGN          ; Negate FPREG
3412: 78       [ 4]     FPADD:  LD      A,B             ; Get FP exponent
3413: B7       [ 8]             OR      A               ; Is number zero?
3414: C8       [13|19]          RET     Z               ; Yes - Nothing to add
3415: 3A2C41   [26]             LD      A,(FPEXP)       ; Get FPREG exponent
3418: B7       [30]             OR      A               ; Is this number zero?
3419: CA9936   [40|40]          JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
341C: 90       [44]             SUB     B               ; BCDE number larger?
341D: D22C34   [54|54]          JP      NC,NOSWAP       ; No - Don't swap them
3420: 2F       [58]             CPL                     ; Two's complement
3421: 3C       [62]             INC     A               ;  FP exponent
3422: EB       [66]             EX      DE,HL
3423: CD8936   [83]             CALL    STAKFP          ; Put FPREG on stack
3426: EB       [87]             EX      DE,HL
3427: CD9936   [104]            CALL    FPBCDE          ; Move BCDE to FPREG
342A: C1       [114]            POP     BC              ; Restore number from stack
342B: D1       [124]            POP     DE
342C: FE19     [ 7]     NOSWAP: CP      24+1            ; Second number insignificant?
342E: D0       [12|18]          RET     NC              ; Yes - First number is result
342F: F5       [23]             PUSH    AF              ; Save number of bits to scale
3430: CDBE36   [40]             CALL    SIGNS           ; Set MSBs & sign of result
3433: 67       [44]             LD      H,A             ; Save sign of result
3434: F1       [54]             POP     AF              ; Restore scaling factor
3435: CDD734   [71]             CALL    SCALE           ; Scale BCDE to same exponent
3438: B4       [75]             OR      H               ; Result to be positive?
3439: 212941   [85]             LD      HL,FPREG        ; Point to FPREG
343C: F25234   [95|95]          JP      P,MINCDE        ; No - Subtract FPREG from CDE
343F: CDB734   [112]            CALL    PLUCDE          ; Add FPREG to CDE
3442: D29834   [122|122]        JP      NC,RONDUP       ; No overflow - Round it up
3445: 23       [128]            INC     HL              ; Point to exponent
3446: 34       [139]            INC     (HL)            ; Increment it
3447: CAB923   [149|149]        JP      Z,OVERR         ; Number overflowed - Error
344A: 2E01     [156]            LD      L,1             ; 1 bit to shift right
344C: CDED34   [173]            CALL    SHRT1           ; Shift result right
344F: C39834   [183]            JP      RONDUP          ; Round it up
                        
3452: AF       [ 4]     MINCDE: XOR     A               ; Clear A and carry
3453: 90       [ 8]             SUB     B               ; Negate exponent
3454: 47       [12]             LD      B,A             ; Re-save exponent
3455: 7E       [19]             LD      A,(HL)          ; Get LSB of FPREG
3456: 9B       [23]             SBC     A, E            ; Subtract LSB of BCDE
3457: 5F       [27]             LD      E,A             ; Save LSB of BCDE
3458: 23       [33]             INC     HL
3459: 7E       [40]             LD      A,(HL)          ; Get NMSB of FPREG
345A: 9A       [44]             SBC     A,D             ; Subtract NMSB of BCDE
345B: 57       [48]             LD      D,A             ; Save NMSB of BCDE
345C: 23       [54]             INC     HL
345D: 7E       [61]             LD      A,(HL)          ; Get MSB of FPREG
345E: 99       [65]             SBC     A,C             ; Subtract MSB of BCDE
345F: 4F       [69]             LD      C,A             ; Save MSB of BCDE
3460: DCC334   [10|17]  CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                        
3463: 68       [ 4]     BNORM:  LD      L,B             ; L = Exponent
3464: 63       [ 8]             LD      H,E             ; H = LSB
3465: AF       [12]             XOR     A
3466: 47       [ 4]     BNRMLP: LD      B,A             ; Save bit count
3467: 79       [ 8]             LD      A,C             ; Get MSB
3468: B7       [12]             OR      A               ; Is it zero?
3469: C28534   [22|22]          JP      NZ,PNORM        ; No - Do it bit at a time
346C: 4A       [26]             LD      C,D             ; MSB = NMSB
346D: 54       [30]             LD      D,H             ; NMSB= LSB
346E: 65       [34]             LD      H,L             ; LSB = VLSB
346F: 6F       [38]             LD      L,A             ; VLSB= 0
3470: 78       [42]             LD      A,B             ; Get exponent
3471: D608     [49]             SUB     8               ; Count 8 bits
3473: FEE0     [56]             CP      -24-8           ; Was number zero?
3475: C26634   [66|66]          JP      NZ,BNRMLP       ; No - Keep normalising
3478: AF       [ 4]     RESZER: XOR     A               ; Result is zero
3479: 322C41   [13]     SAVEXP: LD      (FPEXP),A       ; Save result as zero
347C: C9       [23]             RET
                        
347D: 05       [ 4]     NORMAL: DEC     B               ; Count bits
347E: 29       [15]             ADD     HL,HL           ; Shift HL left
347F: 7A       [19]             LD      A,D             ; Get NMSB
3480: 17       [23]             RLA                     ; Shift left with last bit
3481: 57       [27]             LD      D,A             ; Save NMSB
3482: 79       [31]             LD      A,C             ; Get MSB
3483: 8F       [35]             ADC     A,A             ; Shift left with last bit
3484: 4F       [39]             LD      C,A             ; Save MSB
3485: F27D34   [10|10]  PNORM:  JP      P,NORMAL        ; Not done - Keep going
3488: 78       [14]             LD      A,B             ; Number of bits shifted
3489: 5C       [18]             LD      E,H             ; Save HL in EB
348A: 45       [22]             LD      B,L
348B: B7       [26]             OR      A               ; Any shifting done?
348C: CA9834   [36|36]          JP      Z,RONDUP        ; No - Round it up
348F: 212C41   [46]             LD      HL,FPEXP        ; Point to exponent
3492: 86       [53]             ADD     A,(HL)          ; Add shifted bits
3493: 77       [60]             LD      (HL),A          ; Re-save exponent
3494: D27834   [70|70]          JP      NC,RESZER       ; Underflow - Result is zero
3497: C8       [75|81]          RET     Z               ; Result is zero
3498: 78       [ 4]     RONDUP: LD      A,B             ; Get VLSB of number
3499: 212C41   [10]     RONDB:  LD      HL,FPEXP        ; Point to exponent
349C: B7       [14]             OR      A               ; Any rounding?
349D: FCAA34   [24|31]          CALL    M,FPROND        ; Yes - Round number up
34A0: 46       [31]             LD      B,(HL)          ; B = Exponent
34A1: 23       [37]             INC     HL
34A2: 7E       [44]             LD      A,(HL)          ; Get sign of result
34A3: E680     [51]             AND     10000000B       ; Only bit 7 needed
34A5: A9       [55]             XOR     C               ; Set correct sign
34A6: 4F       [59]             LD      C,A             ; Save correct sign in number
34A7: C39936   [69]             JP      FPBCDE          ; Move BCDE to FPREG
                        
34AA: 1C       [ 4]     FPROND: INC     E               ; Round LSB
34AB: C0       [ 9|15]          RET     NZ              ; Return if ok
34AC: 14       [13]             INC     D               ; Round NMSB
34AD: C0       [18|24]          RET     NZ              ; Return if ok
34AE: 0C       [22]             INC     C               ; Round MSB
34AF: C0       [27|33]          RET     NZ              ; Return if ok
34B0: 0E80     [34]             LD      C,80H           ; Set normal value
34B2: 34       [45]             INC     (HL)            ; Increment exponent
34B3: C0       [50|56]          RET     NZ              ; Return if ok
34B4: C3B923   [60]             JP      OVERR           ; Overflow error
                        
34B7: 7E       [ 7]     PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
34B8: 83       [11]             ADD     A,E             ; Add LSB of BCDE
34B9: 5F       [15]             LD      E,A             ; Save LSB of BCDE
34BA: 23       [21]             INC     HL
34BB: 7E       [28]             LD      A,(HL)          ; Get NMSB of FPREG
34BC: 8A       [32]             ADC     A,D             ; Add NMSB of BCDE
34BD: 57       [36]             LD      D,A             ; Save NMSB of BCDE
34BE: 23       [42]             INC     HL
34BF: 7E       [49]             LD      A,(HL)          ; Get MSB of FPREG
34C0: 89       [53]             ADC     A,C             ; Add MSB of BCDE
34C1: 4F       [57]             LD      C,A             ; Save MSB of BCDE
34C2: C9       [67]             RET
                        
34C3: 212D41   [10]     COMPL:  LD      HL,SGNRES       ; Sign of result
34C6: 7E       [17]             LD      A,(HL)          ; Get sign of result
34C7: 2F       [21]             CPL                     ; Negate it
34C8: 77       [28]             LD      (HL),A          ; Put it back
34C9: AF       [32]             XOR     A
34CA: 6F       [36]             LD      L,A             ; Set L to zero
34CB: 90       [40]             SUB     B               ; Negate exponent,set carry
34CC: 47       [44]             LD      B,A             ; Re-save exponent
34CD: 7D       [48]             LD      A,L             ; Load zero
34CE: 9B       [52]             SBC     A,E             ; Negate LSB
34CF: 5F       [56]             LD      E,A             ; Re-save LSB
34D0: 7D       [60]             LD      A,L             ; Load zero
34D1: 9A       [64]             SBC     A,D             ; Negate NMSB
34D2: 57       [68]             LD      D,A             ; Re-save NMSB
34D3: 7D       [72]             LD      A,L             ; Load zero
34D4: 99       [76]             SBC     A,C             ; Negate MSB
34D5: 4F       [80]             LD      C,A             ; Re-save MSB
34D6: C9       [90]             RET
                        
34D7: 0600     [ 7]     SCALE:  LD      B,0             ; Clear underflow
34D9: D608     [ 7]     SCALLP: SUB     8               ; 8 bits (a whole byte)?
34DB: DAE634   [17|17]          JP      C,SHRITE        ; No - Shift right A bits
34DE: 43       [21]             LD      B,E             ; <- Shift
34DF: 5A       [25]             LD      E,D             ; <- right
34E0: 51       [29]             LD      D,C             ; <- eight
34E1: 0E00     [36]             LD      C,0             ; <- bits
34E3: C3D934   [46]             JP      SCALLP          ; More bits to shift
                        
34E6: C609     [ 7]     SHRITE: ADD     A,8+1           ; Adjust count
34E8: 6F       [11]             LD      L,A             ; Save bits to shift
34E9: AF       [ 4]     SHRLP:  XOR     A               ; Flag for all done
34EA: 2D       [ 8]             DEC     L               ; All shifting done?
34EB: C8       [13|19]          RET     Z               ; Yes - Return
34EC: 79       [17]             LD      A,C             ; Get MSB
34ED: 1F       [ 4]     SHRT1:  RRA                     ; Shift it right
34EE: 4F       [ 8]             LD      C,A             ; Re-save
34EF: 7A       [12]             LD      A,D             ; Get NMSB
34F0: 1F       [16]             RRA                     ; Shift right with last bit
34F1: 57       [20]             LD      D,A             ; Re-save it
34F2: 7B       [24]             LD      A,E             ; Get LSB
34F3: 1F       [28]             RRA                     ; Shift right with last bit
34F4: 5F       [32]             LD      E,A             ; Re-save it
34F5: 78       [36]             LD      A,B             ; Get underflow
34F6: 1F       [40]             RRA                     ; Shift right with last bit
34F7: 47       [44]             LD      B,A             ; Re-save underflow
34F8: C3E934   [54]             JP      SHRLP           ; More bits to do
                        
34FB: 00000081          UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
                        
34FF: 03                LOGTAB: .BYTE      3                       ; Table used by LOG
3500: AA561980                  .BYTE      0AAH,056H,019H,080H     ; 0.59898
3504: F1227680                  .BYTE      0F1H,022H,076H,080H     ; 0.96147
3508: 45AA3882                  .BYTE      045H,0AAH,038H,082H     ; 2.88539
                        
350C: CD5836   [17]     LOG:    CALL    TSTSGN          ; Test sign of value
350F: B7       [21]             OR      A
3510: EAD028   [31|31]          JP      PE,FCERR        ; ?FC Error if <= zero
3513: 212C41   [41]             LD      HL,FPEXP        ; Point to exponent
3516: 7E       [48]             LD      A,(HL)          ; Get exponent
3517: 013580   [58]             LD      BC,8035H        ; BCDE = SQR(1/2)
351A: 11F304   [68]             LD      DE,04F3H
351D: 90       [72]             SUB     B               ; Scale value to be < 1
351E: F5       [83]             PUSH    AF              ; Save scale factor
351F: 70       [90]             LD      (HL),B          ; Save new exponent
3520: D5       [101]            PUSH    DE              ; Save SQR(1/2)
3521: C5       [112]            PUSH    BC
3522: CD1234   [129]            CALL    FPADD           ; Add SQR(1/2) to value
3525: C1       [139]            POP     BC              ; Restore SQR(1/2)
3526: D1       [149]            POP     DE
3527: 04       [153]            INC     B               ; Make it SQR(2)
3528: CDAE35   [170]            CALL    DVBCDE          ; Divide by SQR(2)
352B: 21FB34   [180]            LD      HL,UNITY        ; Point to 1.
352E: CD0934   [197]            CALL    SUBPHL          ; Subtract FPREG from 1
3531: 21FF34   [207]            LD      HL,LOGTAB       ; Coefficient table
3534: CDA039   [224]            CALL    SUMSER          ; Evaluate sum of series
3537: 018080   [234]            LD      BC,8080H        ; BCDE = -0.5
353A: 110000   [244]            LD      DE,0000H
353D: CD1234   [261]            CALL    FPADD           ; Subtract 0.5 from FPREG
3540: F1       [271]            POP     AF              ; Restore scale factor
3541: CDD337   [288]            CALL    RSCALE          ; Re-scale number
3544: 013180   [10]     MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3547: 111872   [20]             LD      DE,7218H
354A: 21                        .BYTE      21H             ; Skip "POP BC" and "POP DE"
                        
354B: C1       [10]     MULT:   POP     BC              ; Get number from stack
354C: D1       [20]             POP     DE
354D: CD5836   [17]     FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3550: C8       [22|28]          RET     Z               ; Return zero if zero
3551: 2E00     [29]             LD      L,0             ; Flag add exponents
3553: CD1636   [46]             CALL    ADDEXP          ; Add exponents
3556: 79       [50]             LD      A,C             ; Get MSB of multiplier
3557: 323B41   [63]             LD      (MULVAL),A      ; Save MSB of multiplier
355A: EB       [67]             EX      DE,HL
355B: 223C41   [83]             LD      (MULVAL+1),HL   ; Save rest of multiplier
355E: 010000   [93]             LD      BC,0            ; Partial product (BCDE) = zero
3561: 50       [97]             LD      D,B
3562: 58       [101]            LD      E,B
3563: 216334   [111]            LD      HL,BNORM        ; Address of normalise
3566: E5       [122]            PUSH    HL              ; Save for return
3567: 216F35   [132]            LD      HL,MULT8        ; Address of 8 bit multiply
356A: E5       [143]            PUSH    HL              ; Save for NMSB,MSB
356B: E5       [154]            PUSH    HL              ; 
356C: 212941   [164]            LD      HL,FPREG        ; Point to number
356F: 7E       [ 7]     MULT8:  LD      A,(HL)          ; Get LSB of number
3570: 23       [13]             INC     HL              ; Point to NMSB
3571: B7       [17]             OR      A               ; Test LSB
3572: CA9B35   [27|27]          JP      Z,BYTSFT        ; Zero - shift to next byte
3575: E5       [38]             PUSH    HL              ; Save address of number
3576: 2E08     [45]             LD      L,8             ; 8 bits to multiply by
3578: 1F       [ 4]     MUL8LP: RRA                     ; Shift LSB right
3579: 67       [ 8]             LD      H,A             ; Save LSB
357A: 79       [12]             LD      A,C             ; Get MSB
357B: D28935   [22|22]          JP      NC,NOMADD       ; Bit was zero - Don't add
357E: E5       [33]             PUSH    HL              ; Save LSB and count
357F: 2A3C41   [49]             LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3582: 19       [60]             ADD     HL,DE           ; Add NMSB and LSB
3583: EB       [64]             EX      DE,HL           ; Leave sum in DE
3584: E1       [74]             POP     HL              ; Restore MSB and count
3585: 3A3B41   [87]             LD      A,(MULVAL)      ; Get MSB of multiplier
3588: 89       [91]             ADC     A,C             ; Add MSB
3589: 1F       [ 4]     NOMADD: RRA                     ; Shift MSB right
358A: 4F       [ 8]             LD      C,A             ; Re-save MSB
358B: 7A       [12]             LD      A,D             ; Get NMSB
358C: 1F       [16]             RRA                     ; Shift NMSB right
358D: 57       [20]             LD      D,A             ; Re-save NMSB
358E: 7B       [24]             LD      A,E             ; Get LSB
358F: 1F       [28]             RRA                     ; Shift LSB right
3590: 5F       [32]             LD      E,A             ; Re-save LSB
3591: 78       [36]             LD      A,B             ; Get VLSB
3592: 1F       [40]             RRA                     ; Shift VLSB right
3593: 47       [44]             LD      B,A             ; Re-save VLSB
3594: 2D       [48]             DEC     L               ; Count bits multiplied
3595: 7C       [52]             LD      A,H             ; Get LSB of multiplier
3596: C27835   [62|62]          JP      NZ,MUL8LP       ; More - Do it
3599: E1       [10]     POPHRT: POP     HL              ; Restore address of number
359A: C9       [20]             RET
                        
359B: 43       [ 4]     BYTSFT: LD      B,E             ; Shift partial product left
359C: 5A       [ 8]             LD      E,D
359D: 51       [12]             LD      D,C
359E: 4F       [16]             LD      C,A
359F: C9       [26]             RET
                        
35A0: CD8936   [17]     DIV10:  CALL    STAKFP          ; Save FPREG on stack
35A3: 012084   [27]             LD      BC,8420H        ; BCDE = 10.
35A6: 110000   [37]             LD      DE,0000H
35A9: CD9936   [54]             CALL    FPBCDE          ; Move 10 to FPREG
                        
35AC: C1       [10]     DIV:    POP     BC              ; Get number from stack
35AD: D1       [20]             POP     DE
35AE: CD5836   [17]     DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
35B1: CAAD23   [27|27]          JP      Z,DZERR         ; Error if division by zero
35B4: 2EFF     [34]             LD      L,-1            ; Flag subtract exponents
35B6: CD1636   [51]             CALL    ADDEXP          ; Subtract exponents
35B9: 34       [62]             INC     (HL)            ; Add 2 to exponent to adjust
35BA: 34       [73]             INC     (HL)
35BB: 2B       [79]             DEC     HL              ; Point to MSB
35BC: 7E       [86]             LD      A,(HL)          ; Get MSB of dividend
35BD: 325740   [99]             LD      (DIV3),A        ; Save for subtraction
35C0: 2B       [105]            DEC     HL
35C1: 7E       [112]            LD      A,(HL)          ; Get NMSB of dividend
35C2: 325340   [125]            LD      (DIV2),A        ; Save for subtraction
35C5: 2B       [131]            DEC     HL
35C6: 7E       [138]            LD      A,(HL)          ; Get MSB of dividend
35C7: 324F40   [151]            LD      (DIV1),A        ; Save for subtraction
35CA: 41       [155]            LD      B,C             ; Get MSB
35CB: EB       [159]            EX      DE,HL           ; NMSB,LSB to HL
35CC: AF       [163]            XOR     A
35CD: 4F       [167]            LD      C,A             ; Clear MSB of quotient
35CE: 57       [171]            LD      D,A             ; Clear NMSB of quotient
35CF: 5F       [175]            LD      E,A             ; Clear LSB of quotient
35D0: 325A40   [188]            LD      (DIV4),A        ; Clear overflow count
35D3: E5       [11]     DIVLP:  PUSH    HL              ; Save divisor
35D4: C5       [22]             PUSH    BC
35D5: 7D       [26]             LD      A,L             ; Get LSB of number
35D6: CD4E40   [43]             CALL    DIVSUP          ; Subt' divisor from dividend
35D9: DE00     [50]             SBC     A,0             ; Count for overflows
35DB: 3F       [54]             CCF
35DC: D2E635   [64|64]          JP      NC,RESDIV       ; Restore divisor if borrow
35DF: 325A40   [77]             LD      (DIV4),A        ; Re-save overflow count
35E2: F1       [87]             POP     AF              ; Scrap divisor
35E3: F1       [97]             POP     AF
35E4: 37       [101]            SCF                     ; Set carry to
35E5: D2                        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
                        
35E6: C1       [10]     RESDIV: POP     BC              ; Restore divisor
35E7: E1       [20]             POP     HL
35E8: 79       [24]             LD      A,C             ; Get MSB of quotient
35E9: 3C       [28]             INC     A
35EA: 3D       [32]             DEC     A
35EB: 1F       [36]             RRA                     ; Bit 0 to bit 7
35EC: FA9934   [46|46]          JP      M,RONDB         ; Done - Normalise result
35EF: 17       [50]             RLA                     ; Restore carry
35F0: 7B       [54]             LD      A,E             ; Get LSB of quotient
35F1: 17       [58]             RLA                     ; Double it
35F2: 5F       [62]             LD      E,A             ; Put it back
35F3: 7A       [66]             LD      A,D             ; Get NMSB of quotient
35F4: 17       [70]             RLA                     ; Double it
35F5: 57       [74]             LD      D,A             ; Put it back
35F6: 79       [78]             LD      A,C             ; Get MSB of quotient
35F7: 17       [82]             RLA                     ; Double it
35F8: 4F       [86]             LD      C,A             ; Put it back
35F9: 29       [97]             ADD     HL,HL           ; Double NMSB,LSB of divisor
35FA: 78       [101]            LD      A,B             ; Get MSB of divisor
35FB: 17       [105]            RLA                     ; Double it
35FC: 47       [109]            LD      B,A             ; Put it back
35FD: 3A5A40   [122]            LD      A,(DIV4)        ; Get VLSB of quotient
3600: 17       [126]            RLA                     ; Double it
3601: 325A40   [139]            LD      (DIV4),A        ; Put it back
3604: 79       [143]            LD      A,C             ; Get MSB of quotient
3605: B2       [147]            OR      D               ; Merge NMSB
3606: B3       [151]            OR      E               ; Merge LSB
3607: C2D335   [161|161]        JP      NZ,DIVLP        ; Not done - Keep dividing
360A: E5       [172]            PUSH    HL              ; Save divisor
360B: 212C41   [182]            LD      HL,FPEXP        ; Point to exponent
360E: 35       [193]            DEC     (HL)            ; Divide by 2
360F: E1       [203]            POP     HL              ; Restore divisor
3610: C2D335   [213|213]        JP      NZ,DIVLP        ; Ok - Keep going
3613: C3B923   [223]            JP      OVERR           ; Overflow error
                        
3616: 78       [ 4]     ADDEXP: LD      A,B             ; Get exponent of dividend
3617: B7       [ 8]             OR      A               ; Test it
3618: CA3A36   [18|18]          JP      Z,OVTST3        ; Zero - Result zero
361B: 7D       [22]             LD      A,L             ; Get add/subtract flag
361C: 212C41   [32]             LD      HL,FPEXP        ; Point to exponent
361F: AE       [39]             XOR     (HL)            ; Add or subtract it
3620: 80       [43]             ADD     A,B             ; Add the other exponent
3621: 47       [47]             LD      B,A             ; Save new exponent
3622: 1F       [51]             RRA                     ; Test exponent for overflow
3623: A8       [55]             XOR     B
3624: 78       [59]             LD      A,B             ; Get exponent
3625: F23936   [69|69]          JP      P,OVTST2        ; Positive - Test for overflow
3628: C680     [76]             ADD     A,80H           ; Add excess 128
362A: 77       [83]             LD      (HL),A          ; Save new exponent
362B: CA9935   [93|93]          JP      Z,POPHRT        ; Zero - Result zero
362E: CDBE36   [110]            CALL    SIGNS           ; Set MSBs and sign of result
3631: 77       [117]            LD      (HL),A          ; Save new exponent
3632: 2B       [123]            DEC     HL              ; Point to MSB
3633: C9       [133]            RET
                        
3634: CD5836   [17]     OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3637: 2F       [21]             CPL                     ; Invert sign
3638: E1       [31]             POP     HL              ; Clean up stack
3639: B7       [ 4]     OVTST2: OR      A               ; Test if new exponent zero
363A: E1       [10]     OVTST3: POP     HL              ; Clear off return address
363B: F27834   [20|20]          JP      P,RESZER        ; Result zero
363E: C3B923   [30]             JP      OVERR           ; Overflow error
                        
3641: CDA436   [17]     MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3644: 78       [21]             LD      A,B             ; Get exponent
3645: B7       [25]             OR      A               ; Is it zero?
3646: C8       [30|36]          RET     Z               ; Yes - Result is zero
3647: C602     [37]             ADD     A,2             ; Multiply by 4
3649: DAB923   [47|47]          JP      C,OVERR         ; Overflow - ?OV Error
364C: 47       [51]             LD      B,A             ; Re-save exponent
364D: CD1234   [68]             CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3650: 212C41   [78]             LD      HL,FPEXP        ; Point to exponent
3653: 34       [89]             INC     (HL)            ; Double number (Times 10)
3654: C0       [94|100]         RET     NZ              ; Ok - Return
3655: C3B923   [104]            JP      OVERR           ; Overflow error
                        
3658: 3A2C41   [13]     TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
365B: B7       [17]             OR      A
365C: C8       [22|28]          RET     Z               ; RETurn if number is zero
365D: 3A2B41   [35]             LD      A,(FPREG+2)     ; Get MSB of FPREG
3660: FE                        .BYTE      0FEH            ; Test sign
3661: 2F       [ 4]     RETREL: CPL                     ; Invert sign
3662: 17       [ 8]             RLA                     ; Sign bit to carry
3663: 9F       [ 4]     FLGDIF: SBC     A,A             ; Carry to all bits of A
3664: C0       [ 9|15]          RET     NZ              ; Return -1 if negative
3665: 3C       [13]             INC     A               ; Bump to +1
3666: C9       [23]             RET                     ; Positive - Return +1
                        
3667: CD5836   [17]     SGN:    CALL    TSTSGN          ; Test sign of FPREG
366A: 0688     [ 7]     FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
366C: 110000   [17]             LD      DE,0            ; Zero NMSB and LSB
366F: 212C41   [10]     RETINT: LD      HL,FPEXP        ; Point to exponent
3672: 4F       [14]             LD      C,A             ; CDE = MSB,NMSB and LSB
3673: 70       [21]             LD      (HL),B          ; Save exponent
3674: 0600     [28]             LD      B,0             ; CDE = integer to normalise
3676: 23       [34]             INC     HL              ; Point to sign of result
3677: 3680     [44]             LD      (HL),80H        ; Set sign of result
3679: 17       [48]             RLA                     ; Carry = sign of integer
367A: C36034   [58]             JP      CONPOS          ; Set sign of result
                        
367D: CD5836   [17]     ABS:    CALL    TSTSGN          ; Test sign of FPREG
3680: F0       [22|28]          RET     P               ; Return if positive
3681: 212B41   [10]     INVSGN: LD      HL,FPREG+2      ; Point to MSB
3684: 7E       [17]             LD      A,(HL)          ; Get sign of mantissa
3685: EE80     [24]             XOR     80H             ; Invert sign of mantissa
3687: 77       [31]             LD      (HL),A          ; Re-save sign of mantissa
3688: C9       [41]             RET
                        
3689: EB       [ 4]     STAKFP: EX      DE,HL           ; Save code string address
368A: 2A2941   [20]             LD      HL,(FPREG)      ; LSB,NLSB of FPREG
368D: E3       [39]             EX      (SP),HL         ; Stack them,get return
368E: E5       [50]             PUSH    HL              ; Re-save return
368F: 2A2B41   [66]             LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3692: E3       [85]             EX      (SP),HL         ; Stack them,get return
3693: E5       [96]             PUSH    HL              ; Re-save return
3694: EB       [100]            EX      DE,HL           ; Restore code string address
3695: C9       [110]            RET
                        
3696: CDA736   [17]     PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3699: EB       [ 4]     FPBCDE: EX      DE,HL           ; Save code string address
369A: 222941   [20]             LD      (FPREG),HL      ; Save LSB,NLSB of number
369D: 60       [24]             LD      H,B             ; Exponent of number
369E: 69       [28]             LD      L,C             ; MSB of number
369F: 222B41   [44]             LD      (FPREG+2),HL    ; Save MSB and exponent
36A2: EB       [48]             EX      DE,HL           ; Restore code string address
36A3: C9       [58]             RET
                        
36A4: 212941   [10]     BCDEFP: LD      HL,FPREG        ; Point to FPREG
36A7: 5E       [ 7]     LOADFP: LD      E,(HL)          ; Get LSB of number
36A8: 23       [13]             INC     HL
36A9: 56       [20]             LD      D,(HL)          ; Get NMSB of number
36AA: 23       [26]             INC     HL
36AB: 4E       [33]             LD      C,(HL)          ; Get MSB of number
36AC: 23       [39]             INC     HL
36AD: 46       [46]             LD      B,(HL)          ; Get exponent of number
36AE: 23       [ 6]     INCHL:  INC     HL              ; Used for conditional "INC HL"
36AF: C9       [16]             RET
                        
36B0: 112941   [10]     FPTHL:  LD      DE,FPREG        ; Point to FPREG
36B3: 0604     [ 7]     DETHL4: LD      B,4             ; 4 bytes to move
36B5: 1A       [ 7]     DETHLB: LD      A,(DE)          ; Get source
36B6: 77       [14]             LD      (HL),A          ; Save destination
36B7: 13       [20]             INC     DE              ; Next source
36B8: 23       [26]             INC     HL              ; Next destination
36B9: 05       [30]             DEC     B               ; Count bytes
36BA: C2B536   [40|40]          JP      NZ,DETHLB       ; Loop if more
36BD: C9       [50]             RET
                        
36BE: 212B41   [10]     SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
36C1: 7E       [17]             LD      A,(HL)          ; Get MSB
36C2: 07       [21]             RLCA                    ; Old sign to carry
36C3: 37       [25]             SCF                     ; Set MSBit
36C4: 1F       [29]             RRA                     ; Set MSBit of MSB
36C5: 77       [36]             LD      (HL),A          ; Save new MSB
36C6: 3F       [40]             CCF                     ; Complement sign
36C7: 1F       [44]             RRA                     ; Old sign to carry
36C8: 23       [50]             INC     HL
36C9: 23       [56]             INC     HL
36CA: 77       [63]             LD      (HL),A          ; Set sign of result
36CB: 79       [67]             LD      A,C             ; Get MSB
36CC: 07       [71]             RLCA                    ; Old sign to carry
36CD: 37       [75]             SCF                     ; Set MSBit
36CE: 1F       [79]             RRA                     ; Set MSBit of MSB
36CF: 4F       [83]             LD      C,A             ; Save MSB
36D0: 1F       [87]             RRA
36D1: AE       [94]             XOR     (HL)            ; New sign of result
36D2: C9       [104]            RET
                        
36D3: 78       [ 4]     CMPNUM: LD      A,B             ; Get exponent of number
36D4: B7       [ 8]             OR      A
36D5: CA5836   [18|18]          JP      Z,TSTSGN        ; Zero - Test sign of FPREG
36D8: 216136   [28]             LD      HL,RETREL       ; Return relation routine
36DB: E5       [39]             PUSH    HL              ; Save for return
36DC: CD5836   [56]             CALL    TSTSGN          ; Test sign of FPREG
36DF: 79       [60]             LD      A,C             ; Get MSB of number
36E0: C8       [65|71]          RET     Z               ; FPREG zero - Number's MSB
36E1: 212B41   [75]             LD      HL,FPREG+2      ; MSB of FPREG
36E4: AE       [82]             XOR     (HL)            ; Combine signs
36E5: 79       [86]             LD      A,C             ; Get MSB of number
36E6: F8       [91|97]          RET     M               ; Exit if signs different
36E7: CDED36   [108]            CALL    CMPFP           ; Compare FP numbers
36EA: 1F       [112]            RRA                     ; Get carry to sign
36EB: A9       [116]            XOR     C               ; Combine with MSB of number
36EC: C9       [126]            RET
                        
36ED: 23       [ 6]     CMPFP:  INC     HL              ; Point to exponent
36EE: 78       [10]             LD      A,B             ; Get exponent
36EF: BE       [17]             CP      (HL)            ; Compare exponents
36F0: C0       [22|28]          RET     NZ              ; Different
36F1: 2B       [28]             DEC     HL              ; Point to MBS
36F2: 79       [32]             LD      A,C             ; Get MSB
36F3: BE       [39]             CP      (HL)            ; Compare MSBs
36F4: C0       [44|50]          RET     NZ              ; Different
36F5: 2B       [50]             DEC     HL              ; Point to NMSB
36F6: 7A       [54]             LD      A,D             ; Get NMSB
36F7: BE       [61]             CP      (HL)            ; Compare NMSBs
36F8: C0       [66|72]          RET     NZ              ; Different
36F9: 2B       [72]             DEC     HL              ; Point to LSB
36FA: 7B       [76]             LD      A,E             ; Get LSB
36FB: 96       [83]             SUB     (HL)            ; Compare LSBs
36FC: C0       [88|94]          RET     NZ              ; Different
36FD: E1       [98]             POP     HL              ; Drop RETurn
36FE: E1       [108]            POP     HL              ; Drop another RETurn
36FF: C9       [118]            RET
                        
3700: 47       [ 4]     FPINT:  LD      B,A             ; <- Move
3701: 4F       [ 8]             LD      C,A             ; <- exponent
3702: 57       [12]             LD      D,A             ; <- to all
3703: 5F       [16]             LD      E,A             ; <- bits
3704: B7       [20]             OR      A               ; Test exponent
3705: C8       [25|31]          RET     Z               ; Zero - Return zero
3706: E5       [36]             PUSH    HL              ; Save pointer to number
3707: CDA436   [53]             CALL    BCDEFP          ; Move FPREG to BCDE
370A: CDBE36   [70]             CALL    SIGNS           ; Set MSBs & sign of result
370D: AE       [77]             XOR     (HL)            ; Combine with sign of FPREG
370E: 67       [81]             LD      H,A             ; Save combined signs
370F: FC2437   [91|98]          CALL    M,DCBCDE        ; Negative - Decrement BCDE
3712: 3E98     [98]             LD      A,80H+24        ; 24 bits
3714: 90       [102]            SUB     B               ; Bits to shift
3715: CDD734   [119]            CALL    SCALE           ; Shift BCDE
3718: 7C       [123]            LD      A,H             ; Get combined sign
3719: 17       [127]            RLA                     ; Sign to carry
371A: DCAA34   [137|144]        CALL    C,FPROND        ; Negative - Round number up
371D: 0600     [144]            LD      B,0             ; Zero exponent
371F: DCC334   [154|161]        CALL    C,COMPL         ; If negative make positive
3722: E1       [164]            POP     HL              ; Restore pointer to number
3723: C9       [174]            RET
                        
3724: 1B       [ 6]     DCBCDE: DEC     DE              ; Decrement BCDE
3725: 7A       [10]             LD      A,D             ; Test LSBs
3726: A3       [14]             AND     E
3727: 3C       [18]             INC     A
3728: C0       [23|29]          RET     NZ              ; Exit if LSBs not FFFF
3729: 0B       [29]             DEC     BC              ; Decrement MSBs
372A: C9       [39]             RET
                        
372B: 212C41   [10]     INT:    LD      HL,FPEXP        ; Point to exponent
372E: 7E       [17]             LD      A,(HL)          ; Get exponent
372F: FE98     [24]             CP      80H+24          ; Integer accuracy only?
3731: 3A2941   [37]             LD      A,(FPREG)       ; Get LSB
3734: D0       [42|48]          RET     NC              ; Yes - Already integer
3735: 7E       [49]             LD      A,(HL)          ; Get exponent
3736: CD0037   [66]             CALL    FPINT           ; F.P to integer
3739: 3698     [76]             LD      (HL),80H+24     ; Save 24 bit integer
373B: 7B       [80]             LD      A,E             ; Get LSB of number
373C: F5       [91]             PUSH    AF              ; Save LSB
373D: 79       [95]             LD      A,C             ; Get MSB of number
373E: 17       [99]             RLA                     ; Sign to carry
373F: CD6034   [116]            CALL    CONPOS          ; Set sign of result
3742: F1       [126]            POP     AF              ; Restore LSB of number
3743: C9       [136]            RET
                        
3744: 210000   [10]     MLDEBC: LD      HL,0            ; Clear partial product
3747: 78       [14]             LD      A,B             ; Test multiplier
3748: B1       [18]             OR      C
3749: C8       [23|29]          RET     Z               ; Return zero if zero
374A: 3E10     [30]             LD      A,16            ; 16 bits
374C: 29       [11]     MLDBLP: ADD     HL,HL           ; Shift P.P left
374D: DA842F   [21|21]          JP      C,BSERR         ; ?BS Error if overflow
3750: EB       [25]             EX      DE,HL
3751: 29       [36]             ADD     HL,HL           ; Shift multiplier left
3752: EB       [40]             EX      DE,HL
3753: D25A37   [50|50]          JP      NC,NOMLAD       ; Bit was zero - No add
3756: 09       [61]             ADD     HL,BC           ; Add multiplicand
3757: DA842F   [71|71]          JP      C,BSERR         ; ?BS Error if overflow
375A: 3D       [ 4]     NOMLAD: DEC     A               ; Count bits
375B: C24C37   [14|14]          JP      NZ,MLDBLP       ; More
375E: C9       [24]             RET
                        
375F: FE2D     [ 7]     ASCTFP: CP      '-'             ; Negative?
3761: F5       [18]             PUSH    AF              ; Save it and flags
3762: CA6B37   [28|28]          JP      Z,CNVNUM        ; Yes - Convert number
3765: FE2B     [35]             CP      '+'             ; Positive?
3767: CA6B37   [45|45]          JP      Z,CNVNUM        ; Yes - Convert number
376A: 2B       [51]             DEC     HL              ; DEC 'cos GETCHR INCs
376B: CD7834   [17]     CNVNUM: CALL    RESZER          ; Set result to zero
376E: 47       [21]             LD      B,A             ; Digits after point counter
376F: 57       [25]             LD      D,A             ; Sign of exponent
3770: 5F       [29]             LD      E,A             ; Exponent of ten
3771: 2F       [33]             CPL
3772: 4F       [37]             LD      C,A             ; Before or after point flag
3773: CD0228   [17]     MANLP:  CALL    GETCHR          ; Get next character
3776: DABC37   [27|27]          JP      C,ADDIG         ; Digit - Add to number
3779: FE2E     [34]             CP      '.'
377B: CA9737   [44|44]          JP      Z,DPOINT        ; '.' - Flag point
377E: FE45     [51]             CP      'E'
3780: C29B37   [61|61]          JP      NZ,CONEXP       ; Not 'E' - Scale number
3783: CD0228   [78]             CALL    GETCHR          ; Get next character
3786: CDAF2D   [95]             CALL    SGNEXP          ; Get sign of exponent
3789: CD0228   [17]     EXPLP:  CALL    GETCHR          ; Get next character
378C: DADE37   [27|27]          JP      C,EDIGIT        ; Digit - Add to exponent
378F: 14       [31]             INC     D               ; Is sign negative?
3790: C29B37   [41|41]          JP      NZ,CONEXP       ; No - Scale number
3793: AF       [45]             XOR     A
3794: 93       [49]             SUB     E               ; Negate exponent
3795: 5F       [53]             LD      E,A             ; And re-save it
3796: 0C       [57]             INC     C               ; Flag end of number
3797: 0C       [ 4]     DPOINT: INC     C               ; Flag point passed
3798: CA7337   [14|14]          JP      Z,MANLP         ; Zero - Get another digit
379B: E5       [11]     CONEXP: PUSH    HL              ; Save code string address
379C: 7B       [15]             LD      A,E             ; Get exponent
379D: 90       [19]             SUB     B               ; Subtract digits after point
379E: F4B437   [10|17]  SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
37A1: F2AA37   [20|20]          JP      P,ENDCON        ; Positive - All done
37A4: F5       [31]             PUSH    AF              ; Save number of times to /10
37A5: CDA035   [48]             CALL    DIV10           ; Divide by 10
37A8: F1       [58]             POP     AF              ; Restore count
37A9: 3C       [62]             INC     A               ; Count divides
                        
37AA: C29E37   [10|10]  ENDCON: JP      NZ,SCALMI       ; More to do
37AD: D1       [20]             POP     DE              ; Restore code string address
37AE: F1       [30]             POP     AF              ; Restore sign of number
37AF: CC8136   [40|47]          CALL    Z,INVSGN        ; Negative - Negate number
37B2: EB       [44]             EX      DE,HL           ; Code string address to HL
37B3: C9       [54]             RET
                        
37B4: C8       [ 5|11]  SCALPL: RET     Z               ; Exit if no scaling needed
37B5: F5       [11]     MULTEN: PUSH    AF              ; Save count
37B6: CD4136   [28]             CALL    MLSP10          ; Multiply number by 10
37B9: F1       [38]             POP     AF              ; Restore count
37BA: 3D       [42]             DEC     A               ; Count multiplies
37BB: C9       [52]             RET
                        
37BC: D5       [11]     ADDIG:  PUSH    DE              ; Save sign of exponent
37BD: 57       [15]             LD      D,A             ; Save digit
37BE: 78       [19]             LD      A,B             ; Get digits after point
37BF: 89       [23]             ADC     A,C             ; Add one if after point
37C0: 47       [27]             LD      B,A             ; Re-save counter
37C1: C5       [38]             PUSH    BC              ; Save point flags
37C2: E5       [49]             PUSH    HL              ; Save code string address
37C3: D5       [60]             PUSH    DE              ; Save digit
37C4: CD4136   [77]             CALL    MLSP10          ; Multiply number by 10
37C7: F1       [87]             POP     AF              ; Restore digit
37C8: D630     [94]             SUB     '0'             ; Make it absolute
37CA: CDD337   [111]            CALL    RSCALE          ; Re-scale number
37CD: E1       [121]            POP     HL              ; Restore code string address
37CE: C1       [131]            POP     BC              ; Restore point flags
37CF: D1       [141]            POP     DE              ; Restore sign of exponent
37D0: C37337   [151]            JP      MANLP           ; Get another digit
                        
37D3: CD8936   [17]     RSCALE: CALL    STAKFP          ; Put number on stack
37D6: CD6A36   [34]             CALL    FLGREL          ; Digit to add to FPREG
37D9: C1       [10]     PADD:   POP     BC              ; Restore number
37DA: D1       [20]             POP     DE
37DB: C31234   [30]             JP      FPADD           ; Add BCDE to FPREG and return
                        
37DE: 7B       [ 4]     EDIGIT: LD      A,E             ; Get digit
37DF: 07       [ 8]             RLCA                    ; Times 2
37E0: 07       [12]             RLCA                    ; Times 4
37E1: 83       [16]             ADD     A,E             ; Times 5
37E2: 07       [20]             RLCA                    ; Times 10
37E3: 86       [27]             ADD     A,(HL)          ; Add next digit
37E4: D630     [34]             SUB     '0'             ; Make it absolute
37E6: 5F       [38]             LD      E,A             ; Save new digit
37E7: C38937   [48]             JP      EXPLP           ; Look for another digit
                        
37EA: E5       [11]     LINEIN: PUSH    HL              ; Save code string address
37EB: 214223   [21]             LD      HL,INMSG        ; Output " in "
37EE: CD4F31   [38]             CALL    PRS             ; Output string at HL
37F1: E1       [48]             POP     HL              ; Restore code string address
37F2: EB       [ 4]     PRNTHL: EX      DE,HL           ; Code string address to DE
37F3: AF       [ 8]             XOR     A
37F4: 0698     [15]             LD      B,80H+24        ; 24 bits
37F6: CD6F36   [32]             CALL    RETINT          ; Return the integer
37F9: 214E31   [42]             LD      HL,PRNUMS       ; Print number string
37FC: E5       [53]             PUSH    HL              ; Save for return
37FD: 212E41   [10]     NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3800: E5       [21]             PUSH    HL              ; Save for return
3801: CD5836   [38]             CALL    TSTSGN          ; Test sign of FPREG
3804: 3620     [48]             LD      (HL),' '        ; Space at start
3806: F20B38   [58|58]          JP      P,SPCFST        ; Positive - Space to start
3809: 362D     [68]             LD      (HL),'-'        ; '-' sign at start
380B: 23       [ 6]     SPCFST: INC     HL              ; First byte of number
380C: 3630     [16]             LD      (HL),'0'        ; '0' if zero
380E: CAC138   [26|26]          JP      Z,JSTZER        ; Return '0' if zero
3811: E5       [37]             PUSH    HL              ; Save buffer address
3812: FC8136   [47|54]          CALL    M,INVSGN        ; Negate FPREG if negative
3815: AF       [51]             XOR     A               ; Zero A
3816: F5       [62]             PUSH    AF              ; Save it
3817: CDC738   [79]             CALL    RNGTST          ; Test number is in range
381A: 014391   [10]     SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
381D: 11F84F   [20]             LD      DE,4FF8H
3820: CDD336   [37]             CALL    CMPNUM          ; Compare numbers
3823: B7       [41]             OR      A
3824: E23838   [51|51]          JP      PO,INRNG        ; > 99999.9 - Sort it out
3827: F1       [61]             POP     AF              ; Restore count
3828: CDB537   [78]             CALL    MULTEN          ; Multiply by ten
382B: F5       [89]             PUSH    AF              ; Re-save count
382C: C31A38   [99]             JP      SIXDIG          ; Test it again
                        
382F: CDA035   [17]     GTSIXD: CALL    DIV10           ; Divide by 10
3832: F1       [27]             POP     AF              ; Get count
3833: 3C       [31]             INC     A               ; Count divides
3834: F5       [42]             PUSH    AF              ; Re-save count
3835: CDC738   [59]             CALL    RNGTST          ; Test number is in range
3838: CD0034   [17]     INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
383B: 3C       [21]             INC     A
383C: CD0037   [38]             CALL    FPINT           ; F.P to integer
383F: CD9936   [55]             CALL    FPBCDE          ; Move BCDE to FPREG
3842: 010603   [65]             LD      BC,0306H        ; 1E+06 to 1E-03 range
3845: F1       [75]             POP     AF              ; Restore count
3846: 81       [79]             ADD     A,C             ; 6 digits before point
3847: 3C       [83]             INC     A               ; Add one
3848: FA5438   [93|93]          JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
384B: FE08     [100]            CP      6+1+1           ; More than 999999 ?
384D: D25438   [110|110]        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3850: 3C       [114]            INC     A               ; Adjust for exponent
3851: 47       [118]            LD      B,A             ; Exponent of number
3852: 3E02     [125]            LD      A,2             ; Make it zero after
                        
3854: 3D       [ 4]     MAKNUM: DEC     A               ; Adjust for digits to do
3855: 3D       [ 8]             DEC     A
3856: E1       [18]             POP     HL              ; Restore buffer address
3857: F5       [29]             PUSH    AF              ; Save count
3858: 11DA38   [39]             LD      DE,POWERS       ; Powers of ten
385B: 05       [43]             DEC     B               ; Count digits before point
385C: C26538   [53|53]          JP      NZ,DIGTXT       ; Not zero - Do number
385F: 362E     [63]             LD      (HL),'.'        ; Save point
3861: 23       [69]             INC     HL              ; Move on
3862: 3630     [79]             LD      (HL),'0'        ; Save zero
3864: 23       [85]             INC     HL              ; Move on
3865: 05       [ 4]     DIGTXT: DEC     B               ; Count digits before point
3866: 362E     [14]             LD      (HL),'.'        ; Save point in case
3868: CCAE36   [24|31]          CALL    Z,INCHL         ; Last digit - move on
386B: C5       [35]             PUSH    BC              ; Save digits before point
386C: E5       [46]             PUSH    HL              ; Save buffer address
386D: D5       [57]             PUSH    DE              ; Save powers of ten
386E: CDA436   [74]             CALL    BCDEFP          ; Move FPREG to BCDE
3871: E1       [84]             POP     HL              ; Powers of ten table
3872: 062F     [91]             LD      B, '0'-1        ; ASCII '0' - 1
3874: 04       [ 4]     TRYAGN: INC     B               ; Count subtractions
3875: 7B       [ 8]             LD      A,E             ; Get LSB
3876: 96       [15]             SUB     (HL)            ; Subtract LSB
3877: 5F       [19]             LD      E,A             ; Save LSB
3878: 23       [25]             INC     HL
3879: 7A       [29]             LD      A,D             ; Get NMSB
387A: 9E       [36]             SBC     A,(HL)          ; Subtract NMSB
387B: 57       [40]             LD      D,A             ; Save NMSB
387C: 23       [46]             INC     HL
387D: 79       [50]             LD      A,C             ; Get MSB
387E: 9E       [57]             SBC     A,(HL)          ; Subtract MSB
387F: 4F       [61]             LD      C,A             ; Save MSB
3880: 2B       [67]             DEC     HL              ; Point back to start
3881: 2B       [73]             DEC     HL
3882: D27438   [83|83]          JP      NC,TRYAGN       ; No overflow - Try again
3885: CDB734   [100]            CALL    PLUCDE          ; Restore number
3888: 23       [106]            INC     HL              ; Start of next number
3889: CD9936   [123]            CALL    FPBCDE          ; Move BCDE to FPREG
388C: EB       [127]            EX      DE,HL           ; Save point in table
388D: E1       [137]            POP     HL              ; Restore buffer address
388E: 70       [144]            LD      (HL),B          ; Save digit in buffer
388F: 23       [150]            INC     HL              ; And move on
3890: C1       [160]            POP     BC              ; Restore digit count
3891: 0D       [164]            DEC     C               ; Count digits
3892: C26538   [174|174]        JP      NZ,DIGTXT       ; More - Do them
3895: 05       [178]            DEC     B               ; Any decimal part?
3896: CAA538   [188|188]        JP      Z,DOEBIT        ; No - Do 'E' bit
3899: 2B       [ 6]     SUPTLZ: DEC     HL              ; Move back through buffer
389A: 7E       [13]             LD      A,(HL)          ; Get character
389B: FE30     [20]             CP      '0'             ; '0' character?
389D: CA9938   [30|30]          JP      Z,SUPTLZ        ; Yes - Look back for more
38A0: FE2E     [37]             CP      '.'             ; A decimal point?
38A2: C4AE36   [47|54]          CALL    NZ,INCHL        ; Move back over digit
                        
38A5: F1       [10]     DOEBIT: POP     AF              ; Get 'E' flag
38A6: CAC438   [20|20]          JP      Z,NOENED        ; No 'E' needed - End buffer
38A9: 3645     [30]             LD      (HL),'E'        ; Put 'E' in buffer
38AB: 23       [36]             INC     HL              ; And move on
38AC: 362B     [46]             LD      (HL),'+'        ; Put '+' in buffer
38AE: F2B538   [56|56]          JP      P,OUTEXP        ; Positive - Output exponent
38B1: 362D     [66]             LD      (HL),'-'        ; Put '-' in buffer
38B3: 2F       [70]             CPL                     ; Negate exponent
38B4: 3C       [74]             INC     A
38B5: 062F     [ 7]     OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
38B7: 04       [ 4]     EXPTEN: INC     B               ; Count subtractions
38B8: D60A     [11]             SUB     10              ; Tens digit
38BA: D2B738   [21|21]          JP      NC,EXPTEN       ; More to do
38BD: C63A     [28]             ADD     A,'0'+10        ; Restore and make ASCII
38BF: 23       [34]             INC     HL              ; Move on
38C0: 70       [41]             LD      (HL),B          ; Save MSB of exponent
38C1: 23       [ 6]     JSTZER: INC     HL              ;
38C2: 77       [13]             LD      (HL),A          ; Save LSB of exponent
38C3: 23       [19]             INC     HL
38C4: 71       [ 7]     NOENED: LD      (HL),C          ; Mark end of buffer
38C5: E1       [17]             POP     HL              ; Restore code string address
38C6: C9       [27]             RET
                        
38C7: 017494   [10]     RNGTST: LD      BC,9474H        ; BCDE = 999999.
38CA: 11F723   [20]             LD      DE,23F7H
38CD: CDD336   [37]             CALL    CMPNUM          ; Compare numbers
38D0: B7       [41]             OR      A
38D1: E1       [51]             POP     HL              ; Return address to HL
38D2: E22F38   [61|61]          JP      PO,GTSIXD       ; Too big - Divide by ten
38D5: E9       [65]             JP      (HL)            ; Otherwise return to caller
                        
38D6: 00000080          HALF:   .BYTE      00H,00H,00H,80H ; 0.5
                        
38DA: A08601            POWERS: .BYTE      0A0H,086H,001H  ; 100000
38DD: 102700                    .BYTE      010H,027H,000H  ;  10000
38E0: E80300                    .BYTE      0E8H,003H,000H  ;   1000
38E3: 640000                    .BYTE      064H,000H,000H  ;    100
38E6: 0A0000                    .BYTE      00AH,000H,000H  ;     10
38E9: 010000                    .BYTE      001H,000H,000H  ;      1
                        
38EC: 218136   [10]     NEGAFT: LD  HL,INVSGN           ; Negate result
38EF: E3       [29]             EX      (SP),HL         ; To be done after caller
38F0: E9       [33]             JP      (HL)            ; Return to caller
                        
38F1: CD8936   [17]     SQR:    CALL    STAKFP          ; Put value on stack
38F4: 21D638   [27]             LD      HL,HALF         ; Set power to 1/2
38F7: CD9636   [44]             CALL    PHLTFP          ; Move 1/2 to FPREG
                        
38FA: C1       [10]     POWER:  POP     BC              ; Get base
38FB: D1       [20]             POP     DE
38FC: CD5836   [37]             CALL    TSTSGN          ; Test sign of power
38FF: 78       [41]             LD      A,B             ; Get exponent of base
3900: CA3F39   [51|51]          JP      Z,EXP           ; Make result 1 if zero
3903: F20A39   [61|61]          JP      P,POWER1        ; Positive base - Ok
3906: B7       [65]             OR      A               ; Zero to negative power?
3907: CAAD23   [75|75]          JP      Z,DZERR         ; Yes - ?/0 Error
390A: B7       [ 4]     POWER1: OR      A               ; Base zero?
390B: CA7934   [14|14]          JP      Z,SAVEXP        ; Yes - Return zero
390E: D5       [25]             PUSH    DE              ; Save base
390F: C5       [36]             PUSH    BC
3910: 79       [40]             LD      A,C             ; Get MSB of base
3911: F67F     [47]             OR      01111111B       ; Get sign status
3913: CDA436   [64]             CALL    BCDEFP          ; Move power to BCDE
3916: F22739   [74|74]          JP      P,POWER2        ; Positive base - Ok
3919: D5       [85]             PUSH    DE              ; Save power
391A: C5       [96]             PUSH    BC
391B: CD2B37   [113]            CALL    INT             ; Get integer of power
391E: C1       [123]            POP     BC              ; Restore power
391F: D1       [133]            POP     DE
3920: F5       [144]            PUSH    AF              ; MSB of base
3921: CDD336   [161]            CALL    CMPNUM          ; Power an integer?
3924: E1       [171]            POP     HL              ; Restore MSB of base
3925: 7C       [175]            LD      A,H             ; but don't affect flags
3926: 1F       [179]            RRA                     ; Exponent odd or even?
3927: E1       [10]     POWER2: POP     HL              ; Restore MSB and exponent
3928: 222B41   [26]             LD      (FPREG+2),HL    ; Save base in FPREG
392B: E1       [36]             POP     HL              ; LSBs of base
392C: 222941   [52]             LD      (FPREG),HL      ; Save in FPREG
392F: DCEC38   [62|69]          CALL    C,NEGAFT        ; Odd power - Negate result
3932: CC8136   [72|79]          CALL    Z,INVSGN        ; Negative base - Negate it
3935: D5       [83]             PUSH    DE              ; Save power
3936: C5       [94]             PUSH    BC
3937: CD0C35   [111]            CALL    LOG             ; Get LOG of base
393A: C1       [121]            POP     BC              ; Restore power
393B: D1       [131]            POP     DE
393C: CD4D35   [148]            CALL    FPMULT          ; Multiply LOG by power
                        
393F: CD8936   [17]     EXP:    CALL    STAKFP          ; Put value on stack
3942: 013881   [27]             LD      BC,08138H       ; BCDE = 1/Ln(2)
3945: 113BAA   [37]             LD      DE,0AA3BH
3948: CD4D35   [54]             CALL    FPMULT          ; Multiply value by 1/LN(2)
394B: 3A2C41   [67]             LD      A,(FPEXP)       ; Get exponent
394E: FE88     [74]             CP      80H+8           ; Is it in range?
3950: D23436   [84|84]          JP      NC,OVTST1       ; No - Test for overflow
3953: CD2B37   [101]            CALL    INT             ; Get INT of FPREG
3956: C680     [108]            ADD     A,80H           ; For excess 128
3958: C602     [115]            ADD     A,2             ; Exponent > 126?
395A: DA3436   [125|125]        JP      C,OVTST1        ; Yes - Test for overflow
395D: F5       [136]            PUSH    AF              ; Save scaling factor
395E: 21FB34   [146]            LD      HL,UNITY        ; Point to 1.
3961: CD0334   [163]            CALL    ADDPHL          ; Add 1 to FPREG
3964: CD4435   [180]            CALL    MULLN2          ; Multiply by LN(2)
3967: F1       [190]            POP     AF              ; Restore scaling factor
3968: C1       [200]            POP     BC              ; Restore exponent
3969: D1       [210]            POP     DE
396A: F5       [221]            PUSH    AF              ; Save scaling factor
396B: CD0F34   [238]            CALL    SUBCDE          ; Subtract exponent from FPREG
396E: CD8136   [255]            CALL    INVSGN          ; Negate result
3971: 217F39   [265]            LD      HL,EXPTAB       ; Coefficient table
3974: CDAF39   [282]            CALL    SMSER1          ; Sum the series
3977: 110000   [292]            LD      DE,0            ; Zero LSBs
397A: C1       [302]            POP     BC              ; Scaling factor
397B: 4A       [306]            LD      C,D             ; Zero MSB
397C: C34D35   [316]            JP      FPMULT          ; Scale result to correct value
                        
397F: 08                EXPTAB: .BYTE      8                       ; Table used by EXP
3980: 402E9474                  .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3984: 704F2E77                  .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3988: 6E02887A                  .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
398C: E6A02A7C                  .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3990: 50AAAA7E                  .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3994: FFFF7F7F                  .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3998: 00008081                  .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
399C: 00000081                  .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
                        
39A0: CD8936   [17]     SUMSER: CALL    STAKFP          ; Put FPREG on stack
39A3: 114B35   [27]             LD      DE,MULT         ; Multiply by "X"
39A6: D5       [38]             PUSH    DE              ; To be done after
39A7: E5       [49]             PUSH    HL              ; Save address of table
39A8: CDA436   [66]             CALL    BCDEFP          ; Move FPREG to BCDE
39AB: CD4D35   [83]             CALL    FPMULT          ; Square the value
39AE: E1       [93]             POP     HL              ; Restore address of table
39AF: CD8936   [17]     SMSER1: CALL    STAKFP          ; Put value on stack
39B2: 7E       [24]             LD      A,(HL)          ; Get number of coefficients
39B3: 23       [30]             INC     HL              ; Point to start of table
39B4: CD9636   [47]             CALL    PHLTFP          ; Move coefficient to FPREG
39B7: 06                        .BYTE      06H             ; Skip "POP AF"
39B8: F1       [10]     SUMLP:  POP     AF              ; Restore count
39B9: C1       [20]             POP     BC              ; Restore number
39BA: D1       [30]             POP     DE
39BB: 3D       [34]             DEC     A               ; Cont coefficients
39BC: C8       [39|45]          RET     Z               ; All done
39BD: D5       [50]             PUSH    DE              ; Save number
39BE: C5       [61]             PUSH    BC
39BF: F5       [72]             PUSH    AF              ; Save count
39C0: E5       [83]             PUSH    HL              ; Save address in table
39C1: CD4D35   [100]            CALL    FPMULT          ; Multiply FPREG by BCDE
39C4: E1       [110]            POP     HL              ; Restore address in table
39C5: CDA736   [127]            CALL    LOADFP          ; Number at HL to BCDE
39C8: E5       [138]            PUSH    HL              ; Save address in table
39C9: CD1234   [155]            CALL    FPADD           ; Add coefficient to FPREG
39CC: E1       [165]            POP     HL              ; Restore address in table
39CD: C3B839   [175]            JP      SUMLP           ; More coefficients
                        
39D0: CD5836   [17]     RND:    CALL    TSTSGN          ; Test sign of FPREG
39D3: 215E40   [27]             LD      HL,SEED+2       ; Random number seed
39D6: FA313A   [37|37]          JP      M,RESEED        ; Negative - Re-seed
39D9: 217F40   [47]             LD      HL,LSTRND       ; Last random number
39DC: CD9636   [64]             CALL    PHLTFP          ; Move last RND to FPREG
39DF: 215E40   [74]             LD      HL,SEED+2       ; Random number seed
39E2: C8       [79|85]          RET     Z               ; Return if RND(0)
39E3: 86       [86]             ADD     A,(HL)          ; Add (SEED)+2)
39E4: E607     [93]             AND     00000111B       ; 0 to 7
39E6: 0600     [100]            LD      B,0
39E8: 77       [107]            LD      (HL),A          ; Re-save seed
39E9: 23       [113]            INC     HL              ; Move to coefficient table
39EA: 87       [117]            ADD     A,A             ; 4 bytes
39EB: 87       [121]            ADD     A,A             ; per entry
39EC: 4F       [125]            LD      C,A             ; BC = Offset into table
39ED: 09       [136]            ADD     HL,BC           ; Point to coefficient
39EE: CDA736   [153]            CALL    LOADFP          ; Coefficient to BCDE
39F1: CD4D35   [170]            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
39F4: 3A5D40   [183]            LD      A,(SEED+1)      ; Get (SEED+1)
39F7: 3C       [187]            INC     A               ; Add 1
39F8: E603     [194]            AND     00000011B       ; 0 to 3
39FA: 0600     [201]            LD      B,0
39FC: FE01     [208]            CP      1               ; Is it zero?
39FE: 88       [212]            ADC     A,B             ; Yes - Make it 1
39FF: 325D40   [225]            LD      (SEED+1),A      ; Re-save seed
3A02: 21353A   [235]            LD      HL,RNDTAB-4     ; Addition table
3A05: 87       [239]            ADD     A,A             ; 4 bytes
3A06: 87       [243]            ADD     A,A             ; per entry
3A07: 4F       [247]            LD      C,A             ; BC = Offset into table
3A08: 09       [258]            ADD     HL,BC           ; Point to value
3A09: CD0334   [275]            CALL    ADDPHL          ; Add value to FPREG
3A0C: CDA436   [17]     RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3A0F: 7B       [21]             LD      A,E             ; Get LSB
3A10: 59       [25]             LD      E,C             ; LSB = MSB
3A11: EE4F     [32]             XOR     01001111B       ; Fiddle around
3A13: 4F       [36]             LD      C,A             ; New MSB
3A14: 3680     [46]             LD      (HL),80H        ; Set exponent
3A16: 2B       [52]             DEC     HL              ; Point to MSB
3A17: 46       [59]             LD      B,(HL)          ; Get MSB
3A18: 3680     [69]             LD      (HL),80H        ; Make value -0.5
3A1A: 215C40   [79]             LD      HL,SEED         ; Random number seed
3A1D: 34       [90]             INC     (HL)            ; Count seed
3A1E: 7E       [97]             LD      A,(HL)          ; Get seed
3A1F: D6AB     [104]            SUB     171             ; Do it modulo 171
3A21: C2283A   [114|114]        JP      NZ,RND2         ; Non-zero - Ok
3A24: 77       [121]            LD      (HL),A          ; Zero seed
3A25: 0C       [125]            INC     C               ; Fillde about
3A26: 15       [129]            DEC     D               ; with the
3A27: 1C       [133]            INC     E               ; number
3A28: CD6334   [17]     RND2:   CALL    BNORM           ; Normalise number
3A2B: 217F40   [27]             LD      HL,LSTRND       ; Save random number
3A2E: C3B036   [37]             JP      FPTHL           ; Move FPREG to last and return
                        
3A31: 77       [ 7]     RESEED: LD      (HL),A          ; Re-seed random numbers
3A32: 2B       [13]             DEC     HL
3A33: 77       [20]             LD      (HL),A
3A34: 2B       [26]             DEC     HL
3A35: 77       [33]             LD      (HL),A
3A36: C30C3A   [43]             JP      RND1            ; Return RND seed
                        
3A39: 68B14668          RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
3A3D: 99E99269                  .BYTE   099H,0E9H,092H,069H
3A41: 10D17568                  .BYTE   010H,0D1H,075H,068H
                        
3A45: 218F3A   [10]     COS:    LD      HL,HALFPI       ; Point to PI/2
3A48: CD0334   [27]             CALL    ADDPHL          ; Add it to PPREG
3A4B: CD8936   [17]     SIN:    CALL    STAKFP          ; Put angle on stack
3A4E: 014983   [27]             LD      BC,8349H        ; BCDE = 2 PI
3A51: 11DB0F   [37]             LD      DE,0FDBH
3A54: CD9936   [54]             CALL    FPBCDE          ; Move 2 PI to FPREG
3A57: C1       [64]             POP     BC              ; Restore angle
3A58: D1       [74]             POP     DE
3A59: CDAE35   [91]             CALL    DVBCDE          ; Divide angle by 2 PI
3A5C: CD8936   [108]            CALL    STAKFP          ; Put it on stack
3A5F: CD2B37   [125]            CALL    INT             ; Get INT of result
3A62: C1       [135]            POP     BC              ; Restore number
3A63: D1       [145]            POP     DE
3A64: CD0F34   [162]            CALL    SUBCDE          ; Make it 0 <= value < 1
3A67: 21933A   [172]            LD      HL,QUARTR       ; Point to 0.25
3A6A: CD0934   [189]            CALL    SUBPHL          ; Subtract value from 0.25
3A6D: CD5836   [206]            CALL    TSTSGN          ; Test sign of value
3A70: 37       [210]            SCF                     ; Flag positive
3A71: F27B3A   [220|220]        JP      P,SIN1          ; Positive - Ok
3A74: CD0034   [237]            CALL    ROUND           ; Add 0.5 to value
3A77: CD5836   [254]            CALL    TSTSGN          ; Test sign of value
3A7A: B7       [258]            OR      A               ; Flag negative
3A7B: F5       [11]     SIN1:   PUSH    AF              ; Save sign
3A7C: F48136   [21|28]          CALL    P,INVSGN        ; Negate value if positive
3A7F: 21933A   [31]             LD      HL,QUARTR       ; Point to 0.25
3A82: CD0334   [48]             CALL    ADDPHL          ; Add 0.25 to value
3A85: F1       [58]             POP     AF              ; Restore sign
3A86: D48136   [68|75]          CALL    NC,INVSGN       ; Negative - Make positive
3A89: 21973A   [78]             LD      HL,SINTAB       ; Coefficient table
3A8C: C3A039   [88]             JP      SUMSER          ; Evaluate sum of series
                        
3A8F: DB0F4981          HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
                        
3A93: 0000007F          QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
                        
3A97: 05                SINTAB: .BYTE   5                       ; Table used by SIN
3A98: BAD71E86                  .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
3A9C: 64269987                  .BYTE   064H,026H,099H,087H     ;-76.575
3AA0: 58342387                  .BYTE   058H,034H,023H,087H     ; 81.602
3AA4: E05DA586                  .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
3AA8: DA0F4983                  .BYTE   0DAH,00FH,049H,083H     ;  6.2832
                        
3AAC: CD8936   [17]     TAN:    CALL    STAKFP          ; Put angle on stack
3AAF: CD4B3A   [34]             CALL    SIN             ; Get SIN of angle
3AB2: C1       [44]             POP     BC              ; Restore angle
3AB3: E1       [54]             POP     HL
3AB4: CD8936   [71]             CALL    STAKFP          ; Save SIN of angle
3AB7: EB       [75]             EX      DE,HL           ; BCDE = Angle
3AB8: CD9936   [92]             CALL    FPBCDE          ; Angle to FPREG
3ABB: CD453A   [109]            CALL    COS             ; Get COS of angle
3ABE: C3AC35   [119]            JP      DIV             ; TAN = SIN / COS
                        
3AC1: CD5836   [17]     ATN:    CALL    TSTSGN          ; Test sign of value
3AC4: FCEC38   [27|34]          CALL    M,NEGAFT        ; Negate result after if -ve
3AC7: FC8136   [37|44]          CALL    M,INVSGN        ; Negate value if -ve
3ACA: 3A2C41   [50]             LD      A,(FPEXP)       ; Get exponent
3ACD: FE81     [57]             CP      81H             ; Number less than 1?
3ACF: DADE3A   [67|67]          JP      C,ATN1          ; Yes - Get arc tangnt
3AD2: 010081   [77]             LD      BC,8100H        ; BCDE = 1
3AD5: 51       [81]             LD      D,C
3AD6: 59       [85]             LD      E,C
3AD7: CDAE35   [102]            CALL    DVBCDE          ; Get reciprocal of number
3ADA: 210934   [112]            LD      HL,SUBPHL       ; Sub angle from PI/2
3ADD: E5       [123]            PUSH    HL              ; Save for angle > 1
3ADE: 21E83A   [10]     ATN1:   LD      HL,ATNTAB       ; Coefficient table
3AE1: CDA039   [27]             CALL    SUMSER          ; Evaluate sum of series
3AE4: 218F3A   [37]             LD      HL,HALFPI       ; PI/2 - angle in case > 1
3AE7: C9       [47]             RET                     ; Number > 1 - Sub from PI/2
                        
3AE8: 09                ATNTAB: .BYTE   9                       ; Table used by ATN
3AE9: 4AD73B78                  .BYTE   04AH,0D7H,03BH,078H     ; 1/17
3AED: 026E847B                  .BYTE   002H,06EH,084H,07BH     ;-1/15
3AF1: FEC12F7C                  .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
3AF5: 74319A7D                  .BYTE   074H,031H,09AH,07DH     ;-1/11
3AF9: 843D5A7D                  .BYTE   084H,03DH,05AH,07DH     ; 1/9
3AFD: C87F917E                  .BYTE   0C8H,07FH,091H,07EH     ;-1/7
3B01: E4BB4C7E                  .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
3B05: 6CAAAA7F                  .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
3B09: 00000081                  .BYTE   000H,000H,000H,081H     ; 1/1
                        
                        
3B0D: C9       [10]     ARET:   RET                     ; A RETurn instruction
                        
3B0E:                   GETINP:			        ; input a character
                        #local
3B0E:                   waitRX:
                            ; wait for an input character
3B0E: DB22     [11]         in	    a, (PORT_SIOACTL)
3B10: CB47     [19]         bit	    SIORR0_IDX_RCA, a
3B12: 28FA     [26|31]      jr	    z, waitRX
                            ; read input character
3B14: DB20     [37]         in	    a, (PORT_SIOADAT)
3B16: C9       [47]         ret
                        #endlocal
                        
3B17:                   CLS: 
3B17: 3E0C     [ 7]             LD      A,CS            ; ASCII Clear screen
3B19: C3513C   [17]             JP      MONOUT          ; Output character
                        
3B1C: CDD733   [17]     WIDTH:  CALL    GETINT          ; Get integer 0-255
3B1F: 7B       [21]             LD      A,E             ; Width to A
3B20: 328740   [34]             LD      (LWIDTH),A      ; Set width
3B23: C9       [44]             RET
                        
3B24: CD762C   [17]     LINES:  CALL    GETNUM          ; Get a number
3B27: CDBB28   [34]             CALL    DEINT           ; Get integer -32768 to 32767
3B2A: ED538B40 [54]             LD      (LINESC),DE     ; Set lines counter
3B2E: ED538D40 [74]             LD      (LINESN),DE     ; Set lines number
3B32: C9       [84]             RET
                        
3B33: CDBB28   [17]     DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
3B36: D5       [28]             PUSH    DE              ; Save number
3B37: E1       [38]             POP     HL              ; Number to HL
3B38: 46       [45]             LD      B,(HL)          ; Get LSB of contents
3B39: 23       [51]             INC     HL
3B3A: 7E       [58]             LD      A,(HL)          ; Get MSB of contents
3B3B: C33130   [68]             JP      ABPASS          ; Return integer AB
                        
3B3E: CD762C   [17]     DOKE:   CALL    GETNUM          ; Get a number
3B41: CDBB28   [34]             CALL    DEINT           ; Get integer -32768 to 32767
3B44: D5       [45]             PUSH    DE              ; Save address
3B45: CD7826   [62]             CALL    CHKSYN          ; Make sure ',' follows
3B48: 2C                        .BYTE      ','
3B49: CD762C   [79]             CALL    GETNUM          ; Get a number
3B4C: CDBB28   [96]             CALL    DEINT           ; Get integer -32768 to 32767
3B4F: E3       [115]            EX      (SP),HL         ; Save value,get address
3B50: 73       [122]            LD      (HL),E          ; Save LSB of value
3B51: 23       [128]            INC     HL
3B52: 72       [135]            LD      (HL),D          ; Save MSB of value
3B53: E1       [145]            POP     HL              ; Restore code string address
3B54: C9       [155]            RET
                        
                        
                        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        
3B55: CD792C   [17]     HEX: 	CALL	TSTNUM          ; Verify it's a number
3B58: CDBB28   [34]             CALL	DEINT           ; Get integer -32768 to 32767
3B5B: C5       [45]             PUSH	BC              ; Save contents of BC
3B5C: 212E41   [55]             LD	    HL,PBUFF
3B5F: 7A       [59]             LD	    A,D             ; Get high order into A
3B60: FE00     [66]             CP      $0
3B62: 280C     [73|78]  		JR      Z,HEX2          ; Skip output if both high digits are zero
3B64: CD8D3B   [90]             CALL    BYT2ASC         ; Convert D to ASCII
3B67: 78       [94]     		LD      A,B
3B68: FE30     [101]    		CP      '0'
3B6A: 2802     [108|113]		JR      Z,HEX1          ; Don't store high digit if zero
3B6C: 70       [115]            LD	    (HL),B          ; Store it to PBUFF
3B6D: 23       [121]            INC	    HL              ; Next location
3B6E: 71       [ 7]     HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
3B6F: 23       [13]             INC     HL              ; Next location
3B70: 7B       [ 4]     HEX2:   LD	    A,E             ; Get lower byte
3B71: CD8D3B   [21]             CALL    BYT2ASC         ; Convert E to ASCII
3B74: 7A       [25]     		LD      A,D
3B75: FE00     [32]             CP      $0
3B77: 2005     [39|44]  		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
3B79: 78       [43]     		LD      A,B
3B7A: FE30     [50]     		CP      '0'             ; If high digit of lower byte is zero then don't print
3B7C: 2802     [57|62]  		JR      Z,HEX4
3B7E: 70       [ 7]     HEX3:   LD      (HL),B          ; to PBUFF+2
3B7F: 23       [13]             INC     HL              ; Next location
3B80: 71       [ 7]     HEX4:   LD      (HL),C          ; to PBUFF+3
3B81: 23       [13]             INC     HL              ; PBUFF+4 to zero
3B82: AF       [17]             XOR     A               ; Terminating character
3B83: 77       [24]             LD      (HL),A          ; Store zero to terminate
3B84: 23       [30]             INC     HL              ; Make sure PBUFF is terminated
3B85: 77       [37]             LD      (HL),A          ; Store the double zero there
3B86: C1       [47]             POP     BC              ; Get BC back
3B87: 212E41   [57]             LD      HL,PBUFF        ; Reset to start of PBUFF
3B8A: C3DF30   [67]             JP      STR1            ; Convert the PBUFF to a string and return it
                        
3B8D: 47       [ 4]     BYT2ASC	LD      B,A             ; Save original value
3B8E: E60F     [11]             AND     $0F             ; Strip off upper nybble
3B90: FE0A     [18]             CP      $0A             ; 0-9?
3B92: 3802     [25|30]          JR      C,ADD30         ; If A-F, add 7 more
3B94: C607     [32]             ADD     A,$07           ; Bring value up to ASCII A-F
3B96: C630     [ 7]     ADD30	ADD     A,$30           ; And make ASCII
3B98: 4F       [11]             LD      C,A             ; Save converted char to C
3B99: 78       [15]             LD      A,B             ; Retrieve original value
3B9A: 0F       [19]             RRCA                    ; and Rotate it right
3B9B: 0F       [23]             RRCA
3B9C: 0F       [27]             RRCA
3B9D: 0F       [31]             RRCA
3B9E: E60F     [38]             AND     $0F             ; Mask off upper nybble
3BA0: FE0A     [45]             CP      $0A             ; 0-9? < A hex?
3BA2: 3802     [52|57]          JR      C,ADD301        ; Skip Add 7
3BA4: C607     [59]             ADD     A,$07           ; Bring it up to ASCII A-F
3BA6: C630     [ 7]     ADD301	ADD     A,$30           ; And make it full ASCII
3BA8: 47       [11]             LD      B,A             ; Store high order byte
3BA9: C9       [21]             RET	
                        
                        ; Convert "&Hnnnn" to FPREG
                        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
3BAA: EB       [ 4]     HEXTFP  EX      DE,HL           ; Move code string pointer to DE
3BAB: 210000   [14]             LD      HL,$0000        ; Zero out the value
3BAE: CDC33B   [31]             CALL    GETHEX          ; Check the number for valid hex
3BB1: DAE33B   [41|41]          JP      C,HXERR         ; First value wasn't hex, HX error
3BB4: 1805     [53]             JR      HEXLP1          ; Convert first character
3BB6: CDC33B   [17]     HEXLP   CALL    GETHEX          ; Get second and addtional characters
3BB9: 381F     [24|29]          JR      C,HEXIT         ; Exit if not a hex character
3BBB: 29       [11]     HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
3BBC: 29       [22]             ADD     HL,HL
3BBD: 29       [33]             ADD     HL,HL
3BBE: 29       [44]             ADD     HL,HL
3BBF: B5       [48]             OR      L               ; Add in D0-D3 into L
3BC0: 6F       [52]             LD      L,A             ; Save new value
3BC1: 18F3     [64]             JR      HEXLP           ; And continue until all hex characters are in
                        
3BC3: 13       [ 6]     GETHEX  INC     DE              ; Next location
3BC4: 1A       [13]             LD      A,(DE)          ; Load character at pointer
3BC5: FE20     [20]             CP      ' '
3BC7: CAC33B   [30|30]          JP      Z,GETHEX        ; Skip spaces
3BCA: D630     [37]             SUB     $30             ; Get absolute value
3BCC: D8       [42|48]          RET     C               ; < "0", error
3BCD: FE0A     [49]             CP      $0A
3BCF: 3805     [56|61]          JR      C,NOSUB7        ; Is already in the range 0-9
3BD1: D607     [63]             SUB     $07             ; Reduce to A-F
3BD3: FE0A     [70]             CP      $0A             ; Value should be $0A-$0F at this point
3BD5: D8       [75|81]          RET     C               ; CY set if was :            ; < = > ? @
3BD6: FE10     [ 7]     NOSUB7  CP      $10             ; > Greater than "F"?
3BD8: 3F       [11]             CCF
3BD9: C9       [21]             RET                     ; CY set if it wasn't valid hex
                            
3BDA: EB       [ 4]     HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
3BDB: 7A       [ 8]             LD      A,D             ; Load DE into AC
3BDC: 4B       [12]             LD      C,E             ; For prep to 
3BDD: E5       [23]             PUSH    HL
3BDE: CD3030   [40]             CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
3BE1: E1       [50]             POP     HL
3BE2: C9       [60]             RET
                        
3BE3: 1E26     [ 7]     HXERR:  LD      E,HX            ; ?HEX Error
3BE5: C3BE23   [17]             JP      ERROR
                        
                        ; BIN$(NN) Convert integer to a 1-16 char binary string
3BE8: CD792C   [17]     BIN:    CALL    TSTNUM          ; Verify it's a number
3BEB: CDBB28   [34]             CALL    DEINT           ; Get integer -32768 to 32767
3BEE: C5       [11]     BIN2:   PUSH    BC              ; Save contents of BC
3BEF: 212E41   [21]             LD      HL,PBUFF
3BF2: 0611     [28]             LD      B,17            ; One higher than max char count
3BF4:                   ZEROSUP:                        ; Suppress leading zeros
3BF4: 05       [ 4]             DEC     B               ; Max 16 chars
3BF5: 78       [ 8]             LD      A,B
3BF6: FE01     [15]             CP      $01
3BF8: 2808     [22|27]          JR      Z,BITOUT        ; Always output at least one character
3BFA: CB13     [30]             RL      E
3BFC: CB12     [38]             RL      D
3BFE: 30F4     [45|50]          JR      NC,ZEROSUP
3C00: 1804     [57]             JR      BITOUT2
3C02:                   BITOUT:      
3C02: CB13     [ 8]             RL      E
3C04: CB12     [16]             RL      D               ; Top bit now in carry
3C06:                   BITOUT2:
3C06: 3E30     [ 7]             LD      A,'0'           ; Char for '0'
3C08: CE00     [14]             ADC     A,0             ; If carry set then '0' --> '1'
3C0A: 77       [21]             LD      (HL),A
3C0B: 23       [27]             INC     HL
3C0C: 05       [31]             DEC     B
3C0D: 20F3     [38|43]          JR      NZ,BITOUT
3C0F: AF       [42]             XOR     A               ; Terminating character
3C10: 77       [49]             LD      (HL),A          ; Store zero to terminate
3C11: 23       [55]             INC     HL              ; Make sure PBUFF is terminated
3C12: 77       [62]             LD      (HL),A          ; Store the double zero there
3C13: C1       [72]             POP     BC
3C14: 212E41   [82]             LD      HL,PBUFF
3C17: C3DF30   [92]             JP      STR1
                        
                        ; Convert "&Bnnnn" to FPREG
                        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
3C1A: EB       [ 4]     BINTFP: EX      DE,HL           ; Move code string pointer to DE
3C1B: 210000   [14]             LD      HL,$0000        ; Zero out the value
3C1E: CD373C   [31]             CALL    CHKBIN          ; Check the number for valid bin
3C21: DA453C   [41|41]          JP      C,BINERR        ; First value wasn't bin, HX error
3C24: D630     [ 7]     BINIT:  SUB     '0'
3C26: 29       [18]             ADD     HL,HL           ; Rotate HL left
3C27: B5       [22]             OR      L
3C28: 6F       [26]             LD      L,A
3C29: CD373C   [43]             CALL    CHKBIN          ; Get second and addtional characters
3C2C: 30F6     [50|55]          JR      NC,BINIT        ; Process if a bin character
3C2E: EB       [54]             EX      DE,HL           ; Value into DE, Code string into HL
3C2F: 7A       [58]             LD      A,D             ; Load DE into AC
3C30: 4B       [62]             LD      C,E             ; For prep to 
3C31: E5       [73]             PUSH    HL
3C32: CD3030   [90]             CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
3C35: E1       [100]            POP     HL
3C36: C9       [110]            RET
                        
                        ; Char is in A, NC if char is 0 or 1
3C37: 13       [ 6]     CHKBIN: INC     DE
3C38: 1A       [13]             LD      A,(DE)
3C39: FE20     [20]             CP      ' '
3C3B: CA373C   [30|30]          JP      Z,CHKBIN        ; Skip spaces
3C3E: FE30     [37]             CP      '0'             ; Set C if < '0'
3C40: D8       [42|48]          RET     C
3C41: FE32     [49]             CP      '2'
3C43: 3F       [53]             CCF                     ; Set C if > '1'
3C44: C9       [63]             RET
                        
3C45: 1E28     [ 7]     BINERR: LD      E,BN            ; ?BIN Error
3C47: C3BE23   [17]             JP      ERROR
                        
                        
3C4A:                   JJUMP1: 
3C4A: DD21FFFF [14]             LD      IX,-1           ; Flag cold start
3C4E: C30E20   [24]             JP      CSTART          ; Go and initialise
                        
3C51:                   MONOUT:				; output a char
                        #local
3C51: F5       [11]         push    af
3C52:                   waitTX:
                            ; wait until transmitter is idle
3C52: DB22     [11]         in	    a, (PORT_SIOACTL)
3C54: CB57     [19]         bit	    SIORR0_IDX_TBE, a
3C56: 28FA     [26|31]      jr	    z, waitTX
3C58: F1       [36]         pop	    af
                            ; write output character
3C59: D320     [47]         out	    (PORT_SIOADAT), a	; send byte out serial port
3C5B: C9       [57]         ret
                        #endlocal
                        
3C5C:                   MONITR: 
3C5C: C30000   [10]             JP      $0000           ; Restart (Normally Monitor Start)
                        
                        
3C5F: 3E00     [ 7]     INITST: LD      A,0             ; Clear break flag
3C61: 329240   [20]             LD      (BRKFLG),A
3C64: C31520   [30]             JP      INIT
                        
3C67: ED45     [14]     ARETN:  RETN                    ; Return from NMI
                        
                        
3C69: F5       [11]     TSTBIT: PUSH    AF              ; Save bit mask
3C6A: A0       [15]             AND     B               ; Get common bits
3C6B: C1       [25]             POP     BC              ; Restore bit mask
3C6C: B8       [29]             CP      B               ; Same bit set?
3C6D: 3E00     [36]             LD      A,0             ; Return 0 in A
3C6F: C9       [46]             RET
                        
3C70: CD8326   [17]     OUTNCR: CALL    OUTC            ; Output character in A
3C73: C3B12A   [27]             JP      PRNTCRLF        ; Output CRLF
                        
                        .end
                        


total time: 0.0705 sec.
no errors
