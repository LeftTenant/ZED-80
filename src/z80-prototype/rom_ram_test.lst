                        ; --------------------------------------
                        ; zasm: assemble "rom_ram_test.asm"
                        ; date: 2018-06-19 15:04:28
                        ; --------------------------------------


                        ; Calling convention used in this file
                        ; ------------------------------------
                        ;
                        ; Unless otherwise noted, the first parameter, and the return value are stored as follows:
                        ; 8 bits: L
                        ; 16 bits: HL
                        ; 32 bits: DEHL
                        ;
                        ; Additional parameters are passed on the stack, left-to-right.
                        ; Parameters and return values larger than 32 bits are passed on the stack (return value
                        ; space set up by caller as a hidden first argument).
                        ; Callee saves/restores any modified registers.
                        ; Caller pops arguments after call returns.
                        ; AF registers are scratch (caller preserves, if needed).
                        
                        ; same as 'bin', except that the default fill byte for 'defs' etc. is 0xff
                        #target rom
                        
                        #include "7segdisp.inc"
0000:                   PORT_SEG0	equ 0x00	    ; port address for first 7-segment display element
0010:                   PORT_SEG1	equ 0x10	    ; port address for second 7-segment display element
                        
                        ; 7-segment display map
                        ;      A
                        ;  +-------+
                        ;  |       |
                        ; F|       |B
                        ;  |   G   |
                        ;  +-------+
                        ;  |       |
                        ; E|       |C
                        ;  |   D   |
                        ;  +-------+  .DP
                        
                        ; These values are the bit masks.
0001:                   SEG_A		equ 0x01	; segment A
0002:                   SEG_B		equ 0x02	; segment B
0004:                   SEG_C		equ 0x04	; segment C
0008:                   SEG_D		equ 0x08	; segment D
0010:                   SEG_E		equ 0x10	; segment E
0020:                   SEG_F		equ 0x20	; segment F
0040:                   SEG_G		equ 0x40	; segment G
0080:                   SEG_DP		equ 0x80	; decimal point
                        
                        ; These are the bit numbers (useful for bit, set, and res instructions).
0000:                   SEG_IDX_A	equ 0
0001:                   SEG_IDX_B	equ 1
0002:                   SEG_IDX_C	equ 2
0003:                   SEG_IDX_D	equ 3
0004:                   SEG_IDX_E	equ 4
0005:                   SEG_IDX_F	equ 5
0006:                   SEG_IDX_G	equ 6
0007:                   SEG_IDX_DP	equ 7
                        #include "joystick.inc"
0000:                   PORT_JOY0	equ 0x00	    ; port address for first joystick (read-only)
0010:                   PORT_JOY1	equ 0x10	    ; port address for second joystick (read-only)
                        
                        ; Bit masks for the values in the joystick status register.
                        ; These bits are active-low (normally high).
0001:                   JOY_UP		equ 0x01
0002:                   JOY_DOWN	equ 0x02
0004:                   JOY_LEFT	equ 0x04
0008:                   JOY_RIGHT	equ 0x08
0010:                   JOY_FIRE	equ 0x10
0020:                   JOY_RESERVED1	equ 0x20
0040:                   JOY_RESERVED2	equ 0x40
0080:                   JOY_RESERVED3	equ 0x80
                        
                        ; The bit numbers (useful for bit, set, and res instructions).
0000:                   JOY_IDX_UP	equ 0
0001:                   JOY_IDX_DOWN	equ 1
0002:                   JOY_IDX_LEFT	equ 2
0003:                   JOY_IDX_RIGHT	equ 3
0004:                   JOY_IDX_FIRE	equ 4
                        #include "z84c20.inc"
                        ; The Z84C20 is the Z80's PIO peripheral. See um0081.pdf for documentation.
                        
0030:                   PORT_PIOBASE	equ 0x30		; base port address for PIO chip
0030:                   PORT_PIOADAT	equ PORT_PIOBASE	; port address for PIO port A, data register
0031:                   PORT_PIOBDAT	equ PORT_PIOBASE + 1    ; port address for PIO port B, data register
0032:                   PORT_PIOACTL	equ PORT_PIOBASE + 2    ; port address for PIO port A, control register
0033:                   PORT_PIOBCTL	equ PORT_PIOBASE + 3    ; port address for PIO port B, control register
                        
                        ; PIO Control Register commands
0000:                   PIOC_IVEC	equ 0x00	; OR in the high 7 bits of the interrupt vector
000F:                   PIOC_MODE	equ 0x0F	; OR in the desired PIOMODE_xxx setting
0007:                   PIOC_ICTL	equ 0x07	; OR in the desired PIOICTL_xxx settings
                        
                        ; PIOC_MODE values
0000:                   PIOMODE_OUTPUT	equ 0x00
0040:                   PIOMODE_INPUT	equ 0x40
0080:                   PIOMODE_BIDIREC	equ 0x80
00C0:                   PIOMODE_CONTROL	equ 0xC0	; next control byte written must be the IO direction byte
                        				; 1 = input, 0 = output
                        
                        ; PIOC_ICTL values
0080:                   PIOICTL_INTENA	equ 0x80	; enable interrupts
0000:                   PIOICTL_INTDIS	equ 0x00	; disable interrupts
0040:                   PIOICTL_AND	equ 0x40	; AND inputs together for port monitoring interrupt
0000:                   PIOICTL_OR	equ 0x00	; OR inputs together for port monitoring interrupt
0020:                   PIOICTL_HIGH	equ 0x20	; interrupt on high (1) inputs
0000:                   PIOICTL_LOW	equ 0x00	; interrupt on low (0) inputs
0010:                   PIOICTL_MASKNXT equ 0x10	; next control byte written must be the input interrupt mask
                        				; 1 = input masked, 0 = input enabled
                        #include "z84c30.inc"
                        ; The Z84C30 is the Z80's CTC peripheral. See um0081.pdf for documentation.
                        
0040:                   PORT_CTCBASE	equ 0x40		; base port address for CTC chip
0040:                   PORT_CTCIVEC	equ PORT_CTCBASE	; port address for Interrupt Vector Register
0040:                   PORT_CTC0	equ PORT_CTCBASE	; port address for CTC channel 0
0041:                   PORT_CTC1	equ PORT_CTCBASE + 1	; port address for CTC channel 1
0042:                   PORT_CTC2	equ PORT_CTCBASE + 2	; port address for CTC channel 2
0043:                   PORT_CTC3	equ PORT_CTCBASE + 3	; port address for CTC channel 3
                        
                        ; CTC Channel Control Word bits
0080:                   CTC_INTENA	equ 0x80		; enable interrupts
0000:                   CTC_INTDIS	equ 0x00		; disable interrupts
0040:                   CTC_MODECTR	equ 0x40		; COUNTER mode
0000:                   CTC_MODETMR	equ 0x00		; TIMER mode
0020:                   CTC_SCALE256	equ 0x20		; prescale by 256
0000:                   CTC_SCALE16	equ 0x00		; prescale by 16
0010:                   CTC_RISING	equ 0x10		; CLK/TRG on rising edges
0000:                   CTC_FALLING	equ 0x00		; CLK/TRG on falling edges
0008:                   CTC_CLKTRG	equ 0x08		; CLK/TRG pulse starts timer
0000:                   CTC_AUTO	equ 0x00		; automatic timer start after loading time constant
0004:                   CTC_TIMENXT	equ 0x04		; next control byte written is the time constant
0002:                   CTC_RESET	equ 0x02		; software reset
0001:                   CTC_CONTROL	equ 0x01		; always set to indicate this is a control word, not IVEC 
                        #include "z84c40.inc"
                        ; The Z84C40 is the Z80's SIO peripheral. See um0081.pdf for documentation.
                        
0020:                   PORT_SIOBASE	    equ 0x20		    ; base port address for SIO chip
0020:                   PORT_SIOADAT	    equ PORT_SIOBASE	    ; port address for SIO port A, data register
0021:                   PORT_SIOBDAT	    equ PORT_SIOBASE + 1    ; port address for SIO port B, data register
0022:                   PORT_SIOACTL	    equ PORT_SIOBASE + 2    ; port address for SIO port A, control register
0023:                   PORT_SIOBCTL	    equ PORT_SIOBASE + 3    ; port address for SIO port B, control register
                        
                        ; WR0 "CRC Reset Code" values (bits 7-6)
0000:                   SIOWR0_CRC_NOP		equ 0x00	    ; no CRC reset code
0040:                   SIOWR0_CRC_RST_RX_CHK	equ 1 << 6	    ; reset RX CRC checker
0080:                   SIOWR0_CRC_RST_TX_GEN	equ 2 << 6	    ; reset TX CRC generator
00C0:                   SIOWR0_CRC_RST_TX_UNDR  equ 3 << 6	    ; reset TX underrun/EOM latch
                        
                        ; WR0 "Command" values (bits 5-3)
0000:                   SIOWR0_CMD_NOP		equ 0x00	    ; no command
0008:                   SIOWR0_CMD_SND_ABRT	equ 1 << 3	    ; send abort (SDLC only)
0010:                   SIOWR0_CMD_RST_EXTINT	equ 2 << 3	    ; reset external/status interrupts
0018:                   SIOWR0_CMD_RST_CHAN	equ 3 << 3	    ; reset channel
0020:                   SIOWR0_CMD_INTENA_NXTRX	equ 4 << 3	    ; enable interrupt on next receive character
0028:                   SIOWR0_CMD_RST_TXINTPND equ 5 << 3	    ; reset TX interrupt pending
0030:                   SIOWR0_CMD_RST_ERR	equ 6 << 3	    ; reset error latches
0038:                   SIOWR0_CMD_INTRETN	equ 7 << 3	    ; return from interrupt (not needed with Z80)
                        
                        ; WR0 "Pointer" values (bits 2-0)
0000:                   SIOWR0_PTR_R0		equ 0x00	    ; set pointer to register 0
0001:                   SIOWR0_PTR_R1		equ 0x01	    ; set pointer to register 1
0002:                   SIOWR0_PTR_R2		equ 0x02	    ; set pointer to register 2
0003:                   SIOWR0_PTR_R3		equ 0x03	    ; set pointer to register 3
0004:                   SIOWR0_PTR_R4		equ 0x04	    ; set pointer to register 4
0005:                   SIOWR0_PTR_R5		equ 0x05	    ; set pointer to register 5
0006:                   SIOWR0_PTR_R6		equ 0x06	    ; set pointer to register 6
0007:                   SIOWR0_PTR_R7		equ 0x07	    ; set pointer to register 7
                        
                        ; WR1 interrupt & wait/ready control bits
0001:                   SIOWR1_EXTINTENA	equ 0x01	    ; external/status interrupt enable
0002:                   SIOWR1_TXINTENA		equ 0x02	    ; TX interrupt enable
0004:                   SIOWR1_STATIVEC		equ 0x04	    ; status affects interrupt vector (set in ch. B only)
0000:                   SIOWR1_RXINT_DISABLE	equ 0 << 3	    ; RX interrupts disabled
0008:                   SIOWR1_RXINT_FIRST	equ 1 << 3	    ; RX interrupt on first character
0010:                   SIOWR1_RXINT_ALLPRTY	equ 2 << 3	    ; RX interrupt on all characters, parity err is SR cond
0018:                   SIOWR1_RXINT_ALLNPRTY	equ 3 << 3	    ; RX interrupt on all characters, parity err no intr
                        ; bits 7-5 are for WAIT/READY functions, which we don't use (always write as 0)
                        
                        ; WR2 is the interrupt vector register (set in channel B only)
                        
                        ; WR3 receiver logic control bits
0001:                   SIOWR3_RXENA		equ 0x01	    ; receiver enable
0002:                   SIOWR3_SYNC_INHIBIT	equ 0x02	    ; sync character load inhibit
0004:                   SIOWR3_ADDR_SRCHMODE	equ 0x04	    ; address search mode
0008:                   SIOWR3_RXCRCENA		equ 0x08	    ; receiver CRC enable
0010:                   SIOWR3_ENTER_HUNT	equ 0x10	    ; enter hunt phase
0020:                   SIOWR3_AUTO_ENABLES	equ 0x20	    ; auto enables (DCD/CTS are RX/TX enables)
0000:                   SIOWR3_RX_5_BITS	equ 0 << 6	    ; receive 5 bits/character
0040:                   SIOWR3_RX_7_BITS	equ 1 << 6	    ; receive 7 bits/character
0080:                   SIOWR3_RX_6_BITS	equ 2 << 6	    ; receive 6 bits/character
00C0:                   SIOWR3_RX_8_BITS	equ 3 << 6	    ; receive 8 bits/character
                        
                        ; WR4 RX/TX configuration (set first before WR1, WR3, WR5, WR6, and WR7)
0001:                   SIOWR4_PARITY		equ 0x01	    ; parity on/off
0002:                   SIOWR4_PRTY_EVEN	equ 0x02	    ; even parity
0000:                   SIOWR4_PRTY_ODD		equ 0x00	    ; odd parity
0000:                   SIOWR4_TXSTOP_SYNC	equ 0 << 2	    ; synchronous mode (no TX stop bits)
0004:                   SIOWR4_TXSTOP_1		equ 1 << 2	    ; 1 TX stop bit
0008:                   SIOWR4_TXSTOP_1_5	equ 2 << 2	    ; 1.5 TX stop bits
000C:                   SIOWR4_TXSTOP_2		equ 3 << 2	    ; 2 TX stop bits
                        ; bits 5-4 set the sync modes, which we don't use (always write as 0)
0000:                   SIOWR4_CLK_x1		equ 0 << 6	    ; data rate x1 = clock rate
0040:                   SIOWR4_CLK_x16		equ 1 << 6	    ; data rate x16 = clock rate
0080:                   SIOWR4_CLK_x32		equ 2 << 6	    ; data rate x32 = clock rate
00C0:                   SIOWR4_CLK_x64		equ 3 << 6	    ; data rate x64 = clock rate
                        
                        ; WR5 transmitter logic control bits
0001:                   SIOWR5_TXCRCENA		equ 0x01	    ; transmitter CRC enable
0002:                   SIOWR5_RTS		equ 0x02	    ; request to send
0004:                   SIOWR5_CRC16_SDLC	equ 0x04	    ; CRC-16 vs. SDLC polynomial
0008:                   SIOWR5_TXENA		equ 0x08	    ; transmitter enable
0010:                   SIOWR5_SND_BRK		equ 0x10	    ; send break
0000:                   SIOWR5_TX_5_BITS	equ 0 << 5	    ; transmit 5 bits/character
0020:                   SIOWR5_TX_7_BITS	equ 1 << 5	    ; transmit 7 bits/character
0040:                   SIOWR5_TX_6_BITS	equ 2 << 5	    ; transmit 6 bits/character
0060:                   SIOWR5_TX_8_BITS	equ 3 << 5	    ; transmit 8 bits/character
0080:                   SIOWR5_DTR		equ 0x80	    ; data terminal ready
                        
                        ; WR6 transmitter sync register for use in synchronous modes, which we don't use
                        ; WR7 receiver sync register for use in synchronous modes, which we don't use
                        
                        ; RR0 status bits (mostly normal operation)
0001:                   SIORR0_RCA		equ 0x01	    ; RX character available
0002:                   SIORR0_INTPND		equ 0x02	    ; interrupt pending (channel A only)
0004:                   SIORR0_TBE		equ 0x04	    ; TX buffer empty
0008:                   SIORR0_DCD		equ 0x08	    ; latched DCD input bit
0010:                   SIORR0_SYNC		equ 0x10	    ; latched SYNC input bit (hunt in SDLC)
0020:                   SIORR0_CTS		equ 0x20	    ; latched CTS input bit
0040:                   SIORR0_TX_UNDR		equ 0x40	    ; TX underrun / end of message
0080:                   SIORR0_BRK_ABRT		equ 0x80	    ; break/abort detected
                        ; As bit numbers, useful for the "bit" instruction, to test individual bit flags
0000:                   SIORR0_IDX_RCA		equ 0
0001:                   SIORR0_IDX_INTPND	equ 1
0002:                   SIORR0_IDX_TBE		equ 2
0003:                   SIORR0_IDX_DCD		equ 3
0004:                   SIORR0_IDX_SYNC		equ 4
0005:                   SIORR0_IDX_CTS		equ 5
0006:                   SIORR0_IDX_TX_UNDR	equ 6
0007:                   SIORR0_IDX_BRK_ABRT	equ 7
                        
                        ; RR1 status bits (mostly errors)
0001:                   SIORR1_ALLSENT		equ 0x01	    ; all characters fully sent
                        ; bits 3-1 are SDLC-only
0010:                   SIORR1_PRTYERR		equ 0x10	    ; parity error
0020:                   SIORR1_ROE		equ 0x20	    ; RX overrun error
0040:                   SIORR1_CRCFRMERR	equ 0x40	    ; CRC/framing error
                        ; bit 7 is SDLC-only
                        
                        ; RR2 is the interrupt vector register (read from channel B only)
                        ; - if "Status Affects Vector" bit is set, this will be the current vector value,
                        ;   modified by whatever interrupt conditions are pending
                        
                        ; 128KB Static RAM - AS6C1008-55PCN
                        ; The first 8KB is shadowed by the EPROM.
                        ; The next 56KB is mapped from 0x2000-0xFFFF.
                        ; The top 64KB is not addressable (A16 tied low).
2000:                   #data RAM, 0x2000, 0xE000
                        ; define static variables here
2000: 00                Seg0_data:: defs 1	; current value of first 7-segment display byte
2001: 00                Seg1_data:: defs 1	; current value of second 7-segment display byte
                        
                        ; 128KB Flash ROM - SST39SF010A
                        ; The first 8KB is mapped from 0-0x1FFF.
0000:                   #code ROM, 0, 0x2000
                        
                        ; reset vector
0000:                   RST0::
0000: F3       [ 4]         di
0001: 31FFFF   [14]         ld	    sp, RAM_end-1
0004: C38800   [24]         jp	    init
0007: FF                    defs    0x08-$
                        
0008:                   RST1::
0008: ED4D     [14]         reti
000A: FFFFFFFF              defs    0x10-$
000E: FFFF              
                        
0010:                   RST2::
0010: ED4D     [14]         reti
0012: FFFFFFFF              defs    0x18-$
0016: FFFF              
                        
0018:                   RST3::
0018: ED4D     [14]         reti
001A: FFFFFFFF              defs    0x20-$
001E: FFFF              
                        
0020:                   RST4::
0020: ED4D     [14]         reti
0022: FFFFFFFF              defs    0x28-$
0026: FFFF              
                        
0028:                   RST5::
0028: ED4D     [14]         reti
002A: FFFFFFFF              defs    0x30-$
002E: FFFF              
                        
0030:                   RST6::
0030: ED4D     [14]         reti
0032: FFFFFFFF              defs    0x38-$
0036: FFFF              
                        
                        ; maskable interrupt handler in interrupt mode 1:
0038:                   RST7::
0038: ED4D     [14]         reti
                        
                        ; non maskable interrupt:
                        ; e.g. call debugger and on exit resume.
003A: FFFFFFFF              defs    0x66-$
003E: FF...             
0066:                   NMI::
0066: ED45     [14]         retn
                        
                        ; Empty ISR for interrupts we want to ignore
0068:                   ISR_nop::
0068: FB       [ 4]         ei
0069: ED4D     [18]         reti
                        
006B: FFFFFFFF              defs    0x80-$
006F: FF...             
                        ; Interrupt Vector Table
0080:                   IVT::
                        ; Table starts at 0x0080
                        ; CTC has first 4 slots, so CTC Interrupt Vector register should be 0x80
0080: 6800                  .word   ISR_nop	    ; CTC channel 0
0082: 6800                  .word   ISR_nop	    ; CTC channel 1
0084: 6800                  .word   ISR_nop	    ; CTC channel 2
0086: 8901                  .word   ISR_ctc3	    ; CTC channel 3
                        ; TODO: ISRs for PIO & SIO
                        
                        ; void init()
0088:                   init::
                            ; set up interrupts
0088: 3E00     [ 7]         ld	    a, hi(IVT)
008A: ED47     [16]         ld	    i, a	    ; I gets high byte of IVT address
008C: ED5E     [24]         im	    2		    ; select interrupt mode 2
008E: FB       [28]         ei
                            ; clear 7-segment display
008F: 2E00     [35]         ld	    l, 0
0091: CD6802   [52]         call    seg0_write
0094: CD6F02   [69]         call    seg1_write
0097: CD6401   [86]         call    ctc_test	    ; need to set up CTC to get SIO working (need baud rate gen)
009A: CD1801   [103]        call    sio_test
                        ;    call    figure8
                        ;    call    countup
                        ;    call    pio_test
                        ;    call    joy_test
009D: 18FE     [115]        jr	    $		    ; loop forever
                        
                        ; void countup()
                        #local
009F:                   countup::
009F: E5       [11]         push    hl
00A0: 2600     [18]         ld	    h, 0	; counter in h
                        ; increment count every 500ms and toggle DP
00A2:                   forever:
00A2: 6C       [ 4]         ld	    l, h
00A3: CDE401   [21]         call    seg_writehex    ; display counter
00A6: 2E80     [28]         ld	    l, SEG_DP
00A8: CD5202   [45]         call    seg0_toggle	    ; toggle DP
00AB: 2EFA     [52]         ld	    l, 250
00AD: CD7602   [69]         call    delay_ms	    ; delay 250ms
00B0: CD7602   [86]         call    delay_ms	    ; delay 250ms
00B3: 24       [90]         inc	    h
00B4: 18EC     [102]        jr	    forever
00B6: E1       [112]        pop	    hl
00B7: C9       [122]        ret
                        #endlocal
                        
                        ; void figure8()
                        #local
00B8:                   figure8::
00B8: E5       [11]         push    hl
00B9: C5       [22]         push    bc
                        ; step fig8 every 125ms; toggle DP every 1s
00BA:                   forever:
00BA: 0607     [ 7]         ld	    b, 7
00BC:                   fig8_loop:
00BC: 68       [ 4]         ld	    l, b
00BD: CD3502   [21]         call    seg0_fig8
00C0: 2E7D     [28]         ld	    l, 125
00C2: CD7602   [45]         call    delay_ms
00C5: 05       [49]         dec	    b
00C6: F2BC00   [59|59]      jp	    p, fig8_loop
00C9: 2E80     [66]         ld	    l, SEG_DP
00CB: CD5202   [83]         call    seg0_toggle
00CE: 18EA     [95]         jr	    forever
00D0: C1       [105]        pop	    bc
00D1: E1       [115]        pop	    hl
00D2: C9       [125]        ret
                        #endlocal
                        
                        ; void pio_test()
                        #local
00D3:                   pio_test::
00D3: E5       [11]         push    hl
00D4: C5       [22]         push    bc
                            ; configure PIO ports A and B
00D5: 013204   [32]         ld	    bc, 0x0400 | PORT_PIOACTL
00D8: 210901   [42]         ld	    hl, pioA_cfg
00DB: EDB3     [58|21]      otir
00DD: 013303   [68]         ld	    bc, 0x0300 | PORT_PIOBCTL
                            ; HL already points to pioB_cfg
00E0: EDB3     [84|21]      otir
00E2: CD1001   [101]        call    pio_srclr		; clear shift register at startup
00E5:                   forever:
00E5: 2E80     [ 7]         ld	    l, SEG_DP
00E7: CD5D02   [24]         call    seg1_toggle
00EA: DB30     [35]         in	    a, (PORT_PIOADAT)	; read PIO port A
00EC: 2F       [39]         cpl				; invert SRPRTY and SRSTRT signals
00ED: CB6F     [47]         bit	    5, a		; if SRSTRT is high, keep polling
00EF: 20F4     [54|59]      jr	    nz, forever
                            ; put SRPRTY onto segment 0's DP
00F1: E610     [61]         and	    0x10		; mask off other bits
00F3: 87       [65]         add	    a, a
00F4: 87       [69]         add	    a, a
00F5: 87       [73]         add	    a, a		; shift SRPRTY left 3 bits to bit 7 (SEG_DP)
00F6: 6F       [77]         ld	    l, a
00F7: CD6802   [94]         call    seg0_write
                            ; read port B, displaying hex value after inverting
00FA: DB31     [105]        in	    a, (PORT_PIOBDAT)
00FC: 2F       [109]        cpl
00FD: 6F       [113]        ld	    l, a
00FE: CD1001   [130]        call    pio_srclr		; clear shift register to prepare for next byte
0101: CDE401   [147]        call    seg_writehex
0104: 18DF     [159]        jr	    forever
0106: C1       [169]        pop	    bc
0107: E1       [179]        pop	    hl
0108: C9       [189]        ret
0109:                   pioA_cfg:
0109: CF                    .byte PIOC_MODE | PIOMODE_CONTROL
010A: F7                    .byte 0xF7	    ; A3 is an output (~SRCLR), everything else is an input
010B: 37                    .byte PIOC_ICTL | PIOICTL_INTDIS | PIOICTL_OR | PIOICTL_HIGH | PIOICTL_MASKNXT
010C: DF                    .byte 0xDF	    ; interrupt on A5 only (SRSTRT)
010D:                   pioB_cfg:
010D: CF                    .byte PIOC_MODE | PIOMODE_CONTROL
010E: FF                    .byte 0xFF	    ; everything is an input
010F: 27                    .byte PIOC_ICTL | PIOICTL_INTDIS | PIOICTL_OR | PIOICTL_HIGH
                        #endlocal
                        
                        ; void pio_srclr()
                        ; - clear shift register by toggling ~SRCLR line, leaving it HIGH
                        #local
0110:                   pio_srclr::
0110: AF       [ 4]         xor	    a
0111: D330     [15]         out	    (PORT_PIOADAT), a
0113: 3E08     [22]         ld	    a, 0x08	; bit 3
0115: D330     [33]         out	    (PORT_PIOADAT), a
0117: C9       [43]         ret
                        #endlocal
                        
                        ; void sio_test()
                        #local
0118:                   sio_test::
0118: E5       [11]         push    hl
0119: C5       [22]         push    bc
                            ; configure SIO port A
011A: 012207   [32]         ld	    bc, 0x0700 | PORT_SIOACTL
011D: 215D01   [42]         ld	    hl, sioA_cfg
0120: EDB3     [58|21]      otir
                            ; configure SIO port B
0122: 012307   [68]         ld	    bc, 0x0700 | PORT_SIOBCTL
0125: 215D01   [78]         ld	    hl, sioA_cfg
0128: EDB3     [94|21]      otir
012A:                   forever:
                            ; wait for an input character
012A:                   waitRX:
012A: DB22     [11]         in	    a, (PORT_SIOACTL)
012C: CB47     [19]         bit	    SIORR0_IDX_RCA, a
012E: 2014     [26|31]      jr	    nz, doRXA
0130: DB23     [37]         in	    a, (PORT_SIOBCTL)
0132: CB47     [45]         bit	    SIORR0_IDX_RCA, a
0134: 28F4     [52|57]      jr	    z, waitRX
0136:                   doRXB:
                            ; read input character
0136: DB21     [11]         in	    a, (PORT_SIOBDAT)
0138: 6F       [15]         ld	    l, a
0139:                   waitTXB:
                            ; wait until transmitter is idle
0139: DB23     [11]         in	    a, (PORT_SIOBCTL)
013B: CB57     [19]         bit	    SIORR0_IDX_TBE, a
013D: 28FA     [26|31]      jr	    z, waitTXB
                            ; write output character
013F: 7D       [30]         ld	    a, l
0140: D321     [41]         out	    (PORT_SIOBDAT), a	; send byte out serial port
0142: 180C     [53]         jr	    writeSeg
0144:                   doRXA:
                            ; read input character
0144: DB20     [11]         in	    a, (PORT_SIOADAT)
0146: 6F       [15]         ld	    l, a
0147:                   waitTXA:
                            ; wait until transmitter is idle
0147: DB22     [11]         in	    a, (PORT_SIOACTL)
0149: CB57     [19]         bit	    SIORR0_IDX_TBE, a
014B: 28FA     [26|31]      jr	    z, waitTXA
                            ; write output character
014D: 7D       [30]         ld	    a, l
014E: D320     [41]         out	    (PORT_SIOADAT), a	; send byte out serial port
0150:                   writeSeg:
                            ; write it to the 7-segment display
0150: CDE401   [17]         call    seg_writehex
0153: 2E80     [24]         ld	    l, SEG_DP		; toggle DP on segment 0
0155: CD5202   [41]         call    seg0_toggle
                            ; repeat
0158: 18D0     [53]         jr	    forever
015A: C1       [63]         pop	    bc
015B: E1       [73]         pop	    hl
015C: C9       [83]         ret
015D:                   sioA_cfg:
015D: 18                    .byte SIOWR0_CMD_RST_CHAN
015E: 04                    .byte SIOWR0_PTR_R4
015F: C4                    .byte SIOWR4_TXSTOP_1 | SIOWR4_CLK_x64
                            ; No need to set up WR1/WR2, as they are only used for interrupts
0160: 03                    .byte SIOWR0_PTR_R3
0161: C1                    .byte SIOWR3_RXENA | SIOWR3_RX_8_BITS
0162: 05                    .byte SIOWR0_PTR_R5
0163: EA                    .byte SIOWR5_RTS | SIOWR5_TXENA | SIOWR5_TX_8_BITS | SIOWR5_DTR
                            ; No need to set up WR6/WR7, as they are only used for synchronous modes
                        #endlocal
                        
                        ; void ctc_test()
                        #local
0164:                   ctc_test::
                            ; load CTC Interrupt Vector Register
0164: 3E80     [ 7]         ld	    a, lo(IVT)	    ; CTC interrupt vectors are the first 4 in the IVT
0166: D340     [18]         out	    (PORT_CTCIVEC), a
                            ; channel 0 is the baud rate generator for serial 0
0168: 3E57     [25]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
016A: D340     [36]         out	    (PORT_CTC0), a
016C: 3E03     [43]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x64 gives 9600 baud)
016E: D340     [54]         out	    (PORT_CTC0), a
                            ; channel 1 is the baud rate generator for serial 1
0170: 3E57     [61]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR
0172: D341     [72]         out	    (PORT_CTC1), a
0174: 3E03     [79]         ld	    a, 3	    ; 1.8432MHz divided by 3 is 614.4kHz (SIO at x64 gives 9600 baud)
0176: D341     [90]         out	    (PORT_CTC1), a
                            ; channel 2 is used as a timer to divide down the system clock for channel 3
0178: 3E17     [97]         ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_AUTO | CTC_RISING | CTC_SCALE16 | CTC_MODETMR
017A: D342     [108]        out	    (PORT_CTC2), a
017C: 3EFA     [115]        ld	    a, 250	    ; 10MHz prescale by 16, divide by 250 is 2.5kHz
017E: D342     [126]        out	    (PORT_CTC2), a
                            ; channel 3 is used as a counter on the 2.5kHz signal from channel 2
0180: 3ED7     [133]        ld	    a, CTC_CONTROL | CTC_RESET | CTC_TIMENXT | CTC_RISING | CTC_MODECTR | CTC_INTENA
0182: D343     [144]        out	    (PORT_CTC3), a
0184: 3EFA     [151]        ld	    a, 250	    ; 2.5kHz divided by 250 is 10Hz
0186: D343     [162]        out	    (PORT_CTC3), a
0188: C9       [172]        ret
                        #endlocal
                        
                        ; CTC channel 3 ISR
0189:                   ISR_ctc3::
0189: 08       [ 4]         ex	    af, af'
018A: D9       [ 8]         exx
018B: 2E80     [15]         ld	    l, SEG_DP
018D: CD5D02   [32]         call    seg1_toggle
0190: D9       [36]         exx
0191: 08       [40]         ex	    af, af'
0192: FB       [44]         ei
0193: ED4D     [58]         reti
                        
                        ; void joy_test()
                        #local
0195:                   joy_test::
0195: E5       [11]         push    hl
0196:                   forever:
0196: DB00     [11]         in	    a, (PORT_JOY0)	; read joystick 0
0198: 6F       [15]         ld	    l, a
0199: CDA301   [32]         call    joy_map2seg
019C: CD6802   [49]         call    seg0_write
                        ;    in	    a, (PORT_JOY1)	; read joystick 1
                        ;    ld	    l, a
                        ;    call    joy_map2seg
                        ;    call    seg1_write
019F: 18F5     [61]         jr	    forever
01A1: E1       [71]         pop	    hl
01A2: C9       [81]         ret
                        #endlocal
                        
                        ; uint8_t joy_map2seg(uint8_t joy)
                        ; - map the joystick status bits in "joy" to a value suitable for writing to the 7-segment display
                        #local
01A3:                   joy_map2seg::
01A3: AF       [ 4]         xor	    a			; start with no bits on 7-segment display
01A4: CB45     [12]         bit	    JOY_IDX_UP, l	; test for UP
01A6: 2002     [19|24]      jr	    nz, done_up
01A8: CBC7     [27]         set	    SEG_IDX_A, a	; turn on top segment
01AA:                   done_up:
01AA: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; test for DOWN
01AC: 2002     [15|20]      jr	    nz, done_down
01AE: CBDF     [23]         set	    SEG_IDX_D, a	; turn on bottom segment
01B0:                   done_down:
                            ; if neither UP nor DOWN are active, activate (clear) both to get both top & bottom side segments
01B0: CB45     [ 8]         bit	    JOY_IDX_UP, l
01B2: 2808     [15|20]      jr	    z, sides
01B4: CB4D     [23]         bit	    JOY_IDX_DOWN, l
01B6: 2804     [30|35]      jr	    z, sides
01B8: CB85     [38]         res	    JOY_IDX_UP, l
01BA: CB8D     [46]         res	    JOY_IDX_DOWN, l
01BC:                   sides:
01BC: CB55     [ 8]         bit	    JOY_IDX_LEFT, l	; test for LEFT
01BE: 200C     [15|20]      jr	    nz, done_left
01C0: CB45     [23]         bit	    JOY_IDX_UP, l	; if UP, set top-left segment
01C2: 2002     [30|35]      jr	    nz, no_top_left
01C4: CBEF     [38]         set	    SEG_IDX_F, a
01C6:                   no_top_left:
01C6: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; if DOWN, set bottom-left segment
01C8: 2002     [15|20]      jr	    nz, done_left
01CA: CBE7     [23]         set	    SEG_IDX_E, a
01CC:                   done_left:
01CC: CB5D     [ 8]         bit	    JOY_IDX_RIGHT, l	; test for RIGHT
01CE: 200C     [15|20]      jr	    nz, done_right
01D0: CB45     [23]         bit	    JOY_IDX_UP, l	; if UP, set top-right segment
01D2: 2002     [30|35]      jr	    nz, no_top_right
01D4: CBCF     [38]         set	    SEG_IDX_B, a
01D6:                   no_top_right:
01D6: CB4D     [ 8]         bit	    JOY_IDX_DOWN, l	; if DOWN, set bottom-right segment
01D8: 2002     [15|20]      jr	    nz, done_right
01DA: CBD7     [23]         set	    SEG_IDX_C, a
01DC:                   done_right:
01DC: CB65     [ 8]         bit	    JOY_IDX_FIRE, l	; test for FIRE
01DE: 2002     [15|20]      jr	    nz, done_fire
01E0: CBFF     [23]         set	    SEG_IDX_DP, a
01E2:                   done_fire:
01E2: 6F       [ 4]         ld	    l, a		; return segment mask
01E3: C9       [14]         ret
                        #endlocal
                        
                        ; Library routines
                        ; ----------------
                        
                        ; void seg_writehex(uint8_t val)
                        ; - write the two hex digits of "val" to the 7-segment displays
01E4:                   seg_writehex::
01E4: E5       [11]         push    hl
01E5: CD0C02   [28]         call    seg1_writehex
01E8: 7D       [32]         ld	    a, l
01E9: 07       [36]         rlca
01EA: 07       [40]         rlca
01EB: 07       [44]         rlca
01EC: 07       [48]         rlca
01ED: 6F       [52]         ld	    l, a
01EE: CDF301   [69]         call    seg0_writehex
01F1: E1       [79]         pop	    hl
01F2: C9       [89]         ret
                        
                        ; void seg0_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
01F3:                   seg0_writehex::
01F3: E5       [11]         push    hl
01F4: C5       [22]         push    bc
01F5: 012502   [32]         ld	    bc, HEX_table
01F8: 7D       [36]         ld	    a, l
01F9: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
01FB: 6F       [47]         ld	    l, a
01FC: 2600     [54]         ld	    h, 0
01FE: 09       [65]         add	    hl, bc  ; hl = HEX_table + (val & 0xF)
01FF: 3A0020   [78]         ld	    a, (Seg0_data)
0202: E680     [85]         and	    SEG_DP
0204: B6       [92]         or	    (hl)
0205: 6F       [96]         ld	    l, a    ; l = (*Seg0_data & SEG_DP) | HEX_table[val & 0xF]
0206: CD6802   [113]        call    seg0_write
0209: C1       [123]        pop	    bc
020A: E1       [133]        pop	    hl
020B: C9       [143]        ret
                        
                        ; void seg1_writehex(uint8_t val)
                        ; - write hex digit in lower nybble of "val" to 7-segment display
020C:                   seg1_writehex::
020C: E5       [11]         push    hl
020D: C5       [22]         push    bc
020E: 012502   [32]         ld	    bc, HEX_table
0211: 7D       [36]         ld	    a, l
0212: E60F     [43]         and	    0xF	    ; mask off upper nybble of l
0214: 6F       [47]         ld	    l, a
0215: 2600     [54]         ld	    h, 0
0217: 09       [65]         add	    hl, bc  ; hl = HEX_table + (val & 0xF)
0218: 3A0120   [78]         ld	    a, (Seg1_data)
021B: E680     [85]         and	    SEG_DP
021D: B6       [92]         or	    (hl)
021E: 6F       [96]         ld	    l, a    ; l = (*Seg1_data & SEG_DP) | HEX_table[val & 0xF]
021F: CD6F02   [113]        call    seg1_write
0222: C1       [123]        pop	    bc
0223: E1       [133]        pop	    hl
0224: C9       [143]        ret
                        
0225:                   HEX_table::
                            ; 0
0225: 3F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F
                            ; 1
0226: 06                    .byte SEG_B | SEG_C
                            ; 2
0227: 5B                    .byte SEG_A | SEG_B | SEG_G | SEG_E | SEG_D
                            ; 3
0228: 4F                    .byte SEG_A | SEG_B | SEG_G | SEG_C | SEG_D
                            ; 4
0229: 66                    .byte SEG_F | SEG_G | SEG_B | SEG_C
                            ; 5
022A: 6D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D
                            ; 6
022B: 7D                    .byte SEG_A | SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; 7
022C: 07                    .byte SEG_A | SEG_B | SEG_C
                            ; 8
022D: 7F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G
                            ; 9
022E: 6F                    .byte SEG_A | SEG_B | SEG_C | SEG_D | SEG_F | SEG_G
                            ; A
022F: 77                    .byte SEG_A | SEG_B | SEG_C | SEG_E | SEG_F | SEG_G
                            ; b
0230: 7C                    .byte SEG_F | SEG_G | SEG_C | SEG_D | SEG_E
                            ; C
0231: 39                    .byte SEG_A | SEG_D | SEG_E | SEG_F
                            ; d
0232: 5E                    .byte SEG_B | SEG_C | SEG_D | SEG_E | SEG_G
                            ; E
0233: 79                    .byte SEG_A | SEG_D | SEG_E | SEG_F | SEG_G
                            ; F
0234: 71                    .byte SEG_A | SEG_E | SEG_F | SEG_G
                        
                        ; void seg0_fig8(uint8_t step)
                        ; - advance first 7-segment display to specified figure-8 step (0-7)
0235:                   seg0_fig8::
0235: E5       [11]         push    hl
0236: C5       [22]         push    bc
0237: 014A02   [32]         ld	    bc, FIG8_table
023A: 2600     [39]         ld	    h, 0
023C: 09       [50]         add	    hl, bc	; hl = FIG8_table + step
023D: 3A0020   [63]         ld	    a, (Seg0_data)
0240: E680     [70]         and	    SEG_DP
0242: B6       [77]         or	    (hl)
0243: 6F       [81]         ld	    l, a	; l = (*Seg0_data & SEG_DP) | FIG8_table[step]
0244: CD6802   [98]         call    seg0_write
0247: C1       [108]        pop	    bc
0248: E1       [118]        pop	    hl
0249: C9       [128]        ret
                        
024A:                   FIG8_table::
024A: 01024010              .byte SEG_A, SEG_B, SEG_G, SEG_E, SEG_D, SEG_C, SEG_G, SEG_F
024E: 08044020          
                        
                        ; void seg0_toggle(uint8_t bits)
                        ; - toggle specified bits of first 7-segment display register
0252:                   seg0_toggle::
0252: E5       [11]         push    hl
0253: 3A0020   [24]         ld	    a, (Seg0_data)
0256: AD       [28]         xor	    l
0257: 6F       [32]         ld	    l, a
0258: CD6802   [49]         call    seg0_write
025B: E1       [59]         pop	    hl
025C: C9       [69]         ret
                        
                        ; void seg1_toggle(uint8_t bits)
                        ; - toggle specified bits of second 7-segment display register
025D:                   seg1_toggle::
025D: E5       [11]         push    hl
025E: 3A0120   [24]         ld	    a, (Seg1_data)
0261: AD       [28]         xor	    l
0262: 6F       [32]         ld	    l, a
0263: CD6F02   [49]         call    seg1_write
0266: E1       [59]         pop	    hl
0267: C9       [69]         ret
                        
                        ; void seg0_write(uint8_t bits)
                        ; - write raw bits to first 7-segment display register
0268:                   seg0_write::
0268: 7D       [ 4]         ld	    a, l
0269: 320020   [17]         ld	    (Seg0_data), a
026C: D300     [28]         out	    (PORT_SEG0), a
026E: C9       [38]         ret
                        
                        ; void seg1_write(uint8_t bits)
                        ; - write raw bits to second 7-segment display register
026F:                   seg1_write::
026F: 7D       [ 4]         ld	    a, l
0270: 320120   [17]         ld	    (Seg1_data), a
0273: D310     [28]         out	    (PORT_SEG1), a
0275: C9       [38]         ret
                        
                        ; void delay_ms(uint8_t ms)
                        ; - delay for at least the specified number of milliseconds
                        #local
0276:                   delay_ms::
0276: 2C       [ 4]         inc	    l
0277: 2D       [ 8]         dec	    l
0278: C8       [13|19]      ret	    z		; delay of 0 returns immediately
0279: C5       [24]         push    bc
027A: 45       [28]         ld	    b, l
027B:                   loop:
027B: CD8202   [17]         call    delay_1ms
027E: 10FB     [25|30]      djnz    loop
0280: C1       [35]         pop	    bc
0281: C9       [45]         ret
                        #endlocal
                        
                        ; void delay_1ms()
                        ; - delay for 1ms (technically, 0.9999ms)
                        #local
0282:                   delay_1ms::
0282: C5       [11]         push    bc		; 11 T-states
                        ; To delay 1ms, we want to wait 10,000 T-states (@10MHz)
                        ; The loop is (38*b + 13*(b-1) + 8) T-states long
                        ; Rearranging: 51*b - 5
                        ; Solve for b: b = (10000 + 5 / 51) = 196.17
0283: 06C3     [18]         ld	    b, 195	; 7 T-states
0285:                   loop:
0285: E3       [19]         ex	    (sp), hl	; 19 T-states
0286: E3       [38]         ex	    (sp), hl	; 19 T-states
0287: 10FC     [46|51]      djnz    loop	; (b-1)*13+8 T-states
0289: C1       [56]         pop	    bc		; 10 T-states
028A: 00       [60]         nop			; 4 T-states
028B: C9       [70]         ret			; 10 T-states
                        ; We also assume the routine is CALLed, for 17 T-states.
                        ; Total delay is therefore:
                        ;   17 + 11 + 7 + 51*195 - 5 + 10 + 4 + 10 = 9,999
                        #endlocal
                        
                        ; Remaining 56KB and 64KB segments to fill up ROM image
0000:                   #code FILLER1, 0, 0xE000
0000:                   #code FILLER2, 0, 0x10000


total time: 0.0146 sec.
no errors
